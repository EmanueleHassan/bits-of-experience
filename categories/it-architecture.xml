<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bits of Experience (Posts about IT Architecture)</title><link>https://marcohassan.github.io/bits-of-experience/</link><description></description><atom:link href="https://marcohassan.github.io/bits-of-experience/categories/it-architecture.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:marco.hassan30@gmail.com"&gt;Marco Hassan&lt;/a&gt; </copyright><lastBuildDate>Wed, 05 Feb 2020 13:23:04 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Openshift and Kubernetes Commands</title><link>https://marcohassan.github.io/bits-of-experience/posts/openshift-and-kubernetes-commands/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
This post outlines some of the commands to operate on your Kubernetes
and Openshift cluster via CLI.
&lt;/p&gt;

&lt;br&gt;

&lt;div id="outline-container-orgba324ac" class="outline-2"&gt;
&lt;h2 id="orgba324ac"&gt;Kubernetes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgba324ac"&gt;
&lt;p&gt;
Particularly useful when working with Kubernetes is the dashboard. It
provides you a neat overview over your cluster. It allows to view and
edit single &lt;code&gt;.yaml&lt;/code&gt; files for each resource. 
&lt;/p&gt;

&lt;p&gt;
It is a powerful way to navigate your way through and get the
structure. You can access it from the ibm cloud on your browser directly. INC4429361
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-org735ceae" class="outline-3"&gt;
&lt;h3 id="org735ceae"&gt;Configure your Kubeconfig file&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org735ceae"&gt;
&lt;p&gt;
This is the foremost important step as you have to specify the
kubernetes/openshift cluster you want to operate on.
&lt;/p&gt;

&lt;p&gt;
Kubectl is a command line tool for controlling Kubernetes
clusters. 
&lt;/p&gt;

&lt;p&gt;
kubectl looks for a file named config in the $HOME/.kube
directory. You can specify other kubeconfig files by setting the
KUBECONFIG environment variable or by setting the –kubeconfig
flag. 
&lt;/p&gt;

&lt;p&gt;
In this sense you can look up for instance the various clusters
running on your IBM cloud by running
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ibmcloud ks cluster ls
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can then withdraw the specific configuration settings for a
cluster by running
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ibmcloud ks cluster config &amp;lt;cluster-ID&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Finally you can export it and configuring the KUBECONFIG file by running.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;KUBECONFIG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/Users/marcohassan/.bluemix/plugins/container-service/clusters/&amp;lt;cluster-id&amp;gt;/&amp;lt;configuration .yaml&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0743a7a" class="outline-3"&gt;
&lt;h3 id="org0743a7a"&gt;General Clutster Info&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0743a7a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl cluster-info
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgad89c6d" class="outline-3"&gt;
&lt;h3 id="orgad89c6d"&gt;Look at the running pods and Namespaces&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgad89c6d"&gt;
&lt;p&gt;
In a similar way to Openshift; you can operate on your IKS cluster
using the &lt;code&gt;kubectl&lt;/code&gt; command. The important thing is that you properly
configured and exported the &lt;code&gt;KUBECONFIG&lt;/code&gt; yaml with the necessary
information on the cluster you wish to operate in the first place.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl get pods

    kubectl get namespaces 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In contrast to Openshift there is not a single command to change namespace
in Kubernetes.
&lt;/p&gt;

&lt;p&gt;
In order to do that you can follow the steps under the following post: &lt;a href="https://suraj.io/post/changing-k8s-ns/"&gt;link&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgeaaffa3" class="outline-3"&gt;
&lt;h3 id="orgeaaffa3"&gt;Apply changes to resource&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgeaaffa3"&gt;
&lt;p&gt;
With the &lt;code&gt;kubectl apply&lt;/code&gt; command you are actually changing some
&lt;code&gt;.yaml&lt;/code&gt; file of your images. 
&lt;/p&gt;

&lt;p&gt;
This is for instance useful when you don't want to validate the
input before sending it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl apply --validate&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt; -f https://github.com/jetstack/cert-manager/releases/download/v0.10.0/cert-manager-openshift.yaml 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org1631163" class="outline-3"&gt;
&lt;h3 id="org1631163"&gt;Gather more info for dealing with specific errors.&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1631163"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl describe pod &amp;lt;my-pod&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is for instance helpful when dealing with
CrashloopBackOff. This happens when you have a pod starting,
crashing, starting again, and then crashing again. 
&lt;/p&gt;

&lt;p&gt;
A quick Google search will show us that crash loop events can happen
for a number of different reasons (and they happen frequently). Here
are some of the umbrella causes for why they occur:
&lt;/p&gt;

&lt;p&gt;
The application inside the container keeps crashing Some type of
parameters of the pod or container have been configured incorrectly An
error has been made when deploying Kubernetes
&lt;/p&gt;

&lt;p&gt;
Doing a kubectl describe pod will give you more information on that
pod. 
&lt;/p&gt;

&lt;p&gt;
There you can read the specific error code - for instance in a
case of mine -  a &lt;code&gt;255 error&lt;/code&gt;, which means that there likely is a
file specification error and this could not be found.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf74f60e" class="outline-3"&gt;
&lt;h3 id="orgf74f60e"&gt;When disrupting the Kubernetes Backend&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf74f60e"&gt;
&lt;p&gt;
It happened to me, when trying to debug Kubernetes issues that
I somehow altered the kubernetes structure and got the following error.
&lt;/p&gt;

&lt;pre class="example"&gt;
Error: could not get apiVersions from Kubernetes: unable to retrieve
the complete list of server APIs:
admission.certmanager.k8s.io/v1beta1: the server is currently unable
to handle the request
&lt;/pre&gt;

&lt;p&gt;
This turned out to be the case when the api-services no longer have backends running.
&lt;/p&gt;

&lt;p&gt;
To fix it I run:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl get apiservice
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This will list the kubernetes api services of your cluster and
issues arises for ones where the AVAILABLE entry is False.
&lt;/p&gt;

&lt;p&gt;
If you don't need those APIs any more, delete them:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    kubectl delete apiservce &amp;lt;service-name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You should be back to a normal behaving cluster then.
&lt;/p&gt;

&lt;br&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7623973" class="outline-2"&gt;
&lt;h2 id="org7623973"&gt;Openshift&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7623973"&gt;
&lt;p&gt;
Openshift is also a cluster management tool. This is a more well
rounded management tool. Especially in monitoring the cluster and
creating new services and resources it is particularly strong. 
&lt;/p&gt;

&lt;p&gt;
The GUI interface is very well done and comprehensive. This section
looks at the CLI to directly operate on your openshift
cluster. Here is important to configure your cluster as previously
noted in the kubernetes section. The KUBECONFIG of your openshift
cluster will allow you to directly operate on your cluster.
&lt;/p&gt;

&lt;p&gt;
Commands are pretty similar to Kubernetes CLI.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org556b536" class="outline-3"&gt;
&lt;h3 id="org556b536"&gt;General glimpse of Cluster&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org556b536"&gt;
&lt;p&gt;
Look at the general settings of your cluster 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    oc config view
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In order to list the current namespaces or pods make use of
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org712b2c7" class="outline-3"&gt;
&lt;h3 id="org712b2c7"&gt;Look at namespaces and pods&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org712b2c7"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    oc get pods

    oc get namespace
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge5681a2" class="outline-3"&gt;
&lt;h3 id="orge5681a2"&gt;Get satatus of running pods&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge5681a2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     oc status
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7afb575" class="outline-3"&gt;
&lt;h3 id="org7afb575"&gt;Look at specific pod configuration&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7afb575"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    oc edit pod &amp;lt;pod-name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd9dcd7d" class="outline-3"&gt;
&lt;h3 id="orgd9dcd7d"&gt;Switch among namespaces&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd9dcd7d"&gt;
&lt;p&gt;
To switch between different namespaces use
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     oc project &amp;lt;namespace&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Look at the user configuration in the &lt;code&gt;kube config&lt;/code&gt; file.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     oc get users
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/openshift-and-kubernetes-commands/</guid><pubDate>Wed, 05 Feb 2020 12:26:21 GMT</pubDate></item><item><title>Helm</title><link>https://marcohassan.github.io/bits-of-experience/posts/helm/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;br&gt;
&lt;br&gt;


&lt;p&gt;
This post contains the basic logic of Helm and should act as a
repository listing the most important ways to work with Helm.
&lt;/p&gt;

&lt;br&gt;

&lt;div id="outline-container-orgdcb498c" class="outline-2"&gt;
&lt;h2 id="orgdcb498c"&gt;Helm - Why?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdcb498c"&gt;
&lt;p&gt;
Using virtualization capabilities ensures scaling, yes. Just keep in
mind that an AMI, ARM (or a Docker container for that matter) you use
to launch the app will be dependent on the Virtual Machine it is
stored on and will be able to scale only the way the virtual machines
are scaled — by adding more resources to the pool.
&lt;/p&gt;

&lt;p&gt;
With Helm, we have quite another picture. The application can be
composed of clearly defined microservices and we can scale only the
ones we need to scale, adding more Kubernetes nodes and pods to the
cluster. Instead of working with a holistic image and growing all the
resources, you operate a set of images and scale them independently.
&lt;/p&gt;

&lt;p&gt;
The problems begin when you want to launch a new instance of an
application that runs, let’s say, 50 microservices. Starting and
combining them all will be a laborious and error-prone task. However,
with Helm, all you need to know is the name of the charts for the
images responsible. Launching a new instance is the question of
executing the corresponding Helm chart.
&lt;/p&gt;

&lt;p&gt;
Of course, the DevOps team can do the same using standard kubectl
commands, yet working with Helm provides the ability to quickly
define, cleanly manage and easily deploy the applications.
&lt;/p&gt;


&lt;br&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org52eddc6" class="outline-2"&gt;
&lt;h2 id="org52eddc6"&gt;Helm&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org52eddc6"&gt;
&lt;p&gt;
General &lt;a href="https://helm.sh/docs/intro/quickstart/"&gt;Helm Guide&lt;/a&gt; with all of the necessary commands.
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-org20fd67a" class="outline-4"&gt;
&lt;h4 id="org20fd67a"&gt;Add a Charts Repository to your Helm Client&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org20fd67a"&gt;
&lt;p&gt;
Add IBM-Kubernetes charts to your local helm 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    helm repo add iks-charts https://icr.io/helm/iks-charts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Other useful charts are the stable released charts. There you can
find images for major databases, SDKs etc.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can moreover add the incubator charts for your local client
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Remind that there is an intrinsic difference between &lt;i&gt;stable&lt;/i&gt; and &lt;i&gt;incubator&lt;/i&gt; charts.
&lt;/p&gt;

&lt;p&gt;
Stable Charts meet the criteria in the &lt;a href="https://github.com/helm/charts/blob/master/CONTRIBUTING.md#technical-requirements"&gt;technical requirements&lt;/a&gt;, which
are a set of strict quality restrictions the Charts should comply with.
&lt;/p&gt;

&lt;p&gt;
Incubator Charts are those that do not meet these criteria. Having the
incubator folder allows charts to be shared and improved on until they
are ready to be moved into the stable folder. There are not simply
incubator and stable charts. Also iks-charts that are IBM specific for
instance.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org247b624" class="outline-4"&gt;
&lt;h4 id="org247b624"&gt;Install a Chart&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org247b624"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="c1"&gt;## helm install &amp;lt;yourchart&amp;gt;&lt;/span&gt;
 helm install iks-charts/ibmcloud-data-shield
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc841f98" class="outline-4"&gt;
&lt;h4 id="orgc841f98"&gt;Installing a Chart in Debug Mode might help&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc841f98"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; helm install &amp;lt;yourchart&amp;gt; --dry-run --debug
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This will print to stdout all the rendered templates in the chart (and won't install the chart)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1a5b320" class="outline-4"&gt;
&lt;h4 id="org1a5b320"&gt;Altering some specific entries in the .yaml configuration of the chart&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1a5b320"&gt;
&lt;p&gt;
This can be achieved through the &lt;code&gt;--set&lt;/code&gt; flag.
&lt;/p&gt;

&lt;p&gt;
For instance by running
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    helm install iks-charts/ibmcloud-data-shield
     --set global.OpenShiftEnabled&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
you specify that you want to run the chart on an Openshfit cluster.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb44d78c" class="outline-4"&gt;
&lt;h4 id="orgb44d78c"&gt;Don't forget to Update&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb44d78c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    helm repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb5dee2e" class="outline-4"&gt;
&lt;h4 id="orgb5dee2e"&gt;View Running Charts&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb5dee2e"&gt;
&lt;p&gt;
View installed charts on Helm
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  helm ls
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga2b533d" class="outline-4"&gt;
&lt;h4 id="orga2b533d"&gt;Information and Yaml for different Chart Repositories&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga2b533d"&gt;
&lt;p&gt;
The information is saved in the following folder on the local machine with your kubectl client.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; ls /Users/marcohassan/Library/Caches/helm/repository/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There you see moreover the installed charts.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5bdf9cc" class="outline-4"&gt;
&lt;h4 id="org5bdf9cc"&gt;Info on Deployed Charts&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5bdf9cc"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  helm status my-cert-manager
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgde3feb6" class="outline-4"&gt;
&lt;h4 id="orgde3feb6"&gt;Delete a Chart&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgde3feb6"&gt;
&lt;p&gt;
To delete one helm chart you can use the following command
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  helm delete my-wordpress
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This will clean all the pods associated with a given release.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8d0f9a7" class="outline-4"&gt;
&lt;h4 id="org8d0f9a7"&gt;Change Namespace&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8d0f9a7"&gt;
&lt;p&gt;
Look at this &lt;a href="https://itnext.io/drastically-improve-your-kubernetes-deployments-with-helm-5323e7f11ef8"&gt;medium article&lt;/a&gt; for a basic discussion on basic helm commands.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/helm/</guid><pubDate>Wed, 05 Feb 2020 12:13:30 GMT</pubDate></item><item><title>Cloud Storage</title><link>https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
In the cloud environment, when deploying an application through a
kubernetes cluster a question that naturally arise is how to save
data and general information. 
&lt;/p&gt;

&lt;p&gt;
What you actually want to achieve is to mount a file system on your
containers and read it as it was local.
&lt;/p&gt;

&lt;p&gt;
This posts tries to make the point for the general approached used to
tackle the issue.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><category>Storage</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/</guid><pubDate>Wed, 18 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Kubernetes</title><link>https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
A strong orchestrator tool that operates above the container level and
allows to manage a cluster to handle containers.
&lt;/p&gt;

&lt;p&gt;
It is essentially the tool set that lets you manage containers.
&lt;/p&gt;

&lt;p&gt;
Enterprises can use it to manage the life cycle of containerized apps
in a cluster of nodes, which is a collection of worker machines such
as virtual machines (VMs) or physical machines.
&lt;/p&gt;

&lt;p&gt;
In general kubernetes try to leverage clusters in order to avoid
having a single point of failure.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/</guid><pubDate>Fri, 06 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Microservices</title><link>https://marcohassan.github.io/bits-of-experience/posts/Microservices/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
Microservices refer to an application architectural style that divides
an application into components, where each component is a full, but
miniature, application that is focused on producing a single business
task.
&lt;/p&gt;

&lt;p&gt;
Each microservice has a well-defined interface and dependencies (to
other microservices and to external resources) so that it can run
fairly independently, and the team can develop it fairly
independently.
&lt;/p&gt;

&lt;p&gt;
Microservices enable developers to accomplish meaningful work working
in small teams. Small teams allow developers to be more productive
because they spend less time in meetings and decrease the need for
communication and coordination that is needed with a large team.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Microservices/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Microservices/</guid><pubDate>Fri, 06 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Docker</title><link>https://marcohassan.github.io/bits-of-experience/posts/Docker/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
&lt;i&gt;Disclaimer; very much of the material under this page is directly copied from various sources on the internet. Check at the Literature section below to get to the source of the post.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
The basic idea of Docker is to allow the possibility to save all of
the configuration of an application in one single image. This should
be considered as a safe environment that once properly set up can be
easily shared among different teams and once images are instantiated
all of the different teams can be sure to operate and leverage the
right configuration for running their application.
&lt;/p&gt;

&lt;p&gt;
A simple and straight forward overview about the advantage of Docker
might be found in this sense at &lt;a href="https://www.tutorialspoint.com/docker/docker_architecture.htm"&gt;docker architecture&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
To sum up before starting the basic idea is to create images and to
create containers based on that, which will run then the application
as defined in the docker image.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Docker/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Docker/</guid><pubDate>Mon, 02 Sep 2019 16:21:43 GMT</pubDate></item></channel></rss>