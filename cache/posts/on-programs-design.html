<p>
So I am continuing my journeys into proper and solid software
engineering.
</p>

<p>
Basically, I always used frameworks and in my first experience it was
out of question whether to use them. But the things were more short
term and now that the software that I am touching is very long lived
the situation is different.
</p>

<p>
In fact, the topic around framework and which exactly to use is a hot
topic in our team. Some prefer to avoid them as much as possible. Some
are heavy proponents of them.
</p>

<p>
As always it is ultimately a trade-off question. I am writing here
some points in order to make such trade-offs more explicit.
</p>

<p>
In fact the way you decide to set up your software - such as trhoguh
inversion of control as when using frameworks or via simple libraries
and toolkits -, as well the task that the software is required to
complete will ultimately define the way you should set up and
program.
</p>

<p>
This is the ultimate reason why there should be a thorough design
phase before touching any bit of code and immersing yourself into
it. What you do not design today will come to hunt you down tomorrow.
</p>

<p>
Depending on the choice of your software set up you should as well
make strategic decisions that go hand in hand with it. This is the aim
of this post; to make this explicit. 
</p>

<!-- TEASER_END -->

<p>
Note that the following general structure - the first taste of this
post - comes from the book <i>Design Patterns - Elements of Reusable
OO-Software</i>.
</p>

<p>
In the book the following broad distinction across the following 3
classes of software is made. Note that in our team we are mainly
concerned in developing <i>Application Programs</i>. Some <i>toolkits</i> are
also developed along the process, these are published and consumed as
artifacts.
</p>

<p>
There are some subsystem components that have a framework alike
experience with inversion of control. These won't be developed
anymore. Note that the major frameworks out there such as <i>Spring</i> and
<i>Hibernate</i> are used. It makes sense in this sense to stop a moment
and think about the characteristics of these frameworks such that you
develop software that is able to develop with them across time. This
is a general major pain point when working with frameworks.
</p>

<div id="outline-container-orgd6b311a" class="outline-2">
<h2 id="orgd6b311a">Application Programs</h2>
<div class="outline-text-2" id="text-orgd6b311a">
<p>
The major points that you have to be aware of and set your focus on
when developing internal application programs are the ones of:
</p>

<ol class="org-ol">
<li>maintainability</li>

<li>extension</li>
</ol>

<p>
In this sense you should set up your software in a way that it easy
to extend and customize in the future as the business requirements
for it will change.
</p>

<p>
On the other hand, you should keep maintainability in the back of
your mind. The software should be easy to maintain, meaning easy
enough to modify, refactor and get your hands into it. Both for you
and for your successors.
</p>

<p>
In general in this sense it is important to use design patterns for
your code that favours loose coupling across the system. I.e. that
increase the potential for one class to cooperate with several
others. I.e. you should try to implement software that is <i>as
transparent as possible</i>.
</p>

<p>
Note that the two goals are conflicting. You usually have to set a
layer of indirection in order to gain extensibility. This makes the
system more complex and adds burden to the maintainability.
</p>
</div>
</div>

<div id="outline-container-orgb0f4de1" class="outline-2">
<h2 id="orgb0f4de1">Toolkits</h2>
<div class="outline-text-2" id="text-orgb0f4de1">
<p>
So these are the libraries that are designed to provide useful,
general purpose functionalities. Think for instance at the Java
standard libraries etc.
</p>

<p>
Note that toolkits <b>don't impose a particular design</b> on your
application; they just provide functionality that can help your
application do its job. They let you as an implementer avoid
receding common functionality. Toolkits emphasize code reuse.
</p>

<p>
This is the main difference with Frameworks as we will see
next. There inversion of control actually happens.
</p>

<p>
When you develop toolkits it is important that you design them in a
way that does not hamper the application usage. In this sense,
important is to avoid assumptions and dependencies that can limit
the toolkit's flexibility and consequently its applicability and
effectiveness.
</p>
</div>
</div>

<div id="outline-container-orgd2c321d" class="outline-2">
<h2 id="orgd2c321d">Frameworks</h2>
<div class="outline-text-2" id="text-orgd2c321d">
<p>
Note that when you use a framework it works as follows:
</p>

<blockquote>
<p>
You customize a framework to a particular application by creating
application-specific subclasses of abstract classes from the
framework.
</p>
</blockquote>

<p>
This is actually what you are doing by tagging all of your classes
in the different frameworks with the relevant annotations.
</p>

<p>
Note that it is important to realize the inversion of control
characteristic of frameworks, meaning that:
</p>

<ul class="org-ul">
<li>the framework <b>dictates the architecture of the application</b>.</li>
</ul>

<p>
So that in general:
</p>

<blockquote>
<p>
The framework captures the design decisions that are common to its
application domain. 
</p>

<p>
Frameworks thus emphasize design reuse over code reuse, though a
framework will usually include concrete subclasses you can put to work
immediately.
</p>

<p>
(Inversion of Control!) When you use a framework, you reuse the main
body and write the code it calls. You'll have to write operations with
particular names and calling conventions, but that reduces the design
decisions you have to make.
</p>

<p>
[Finally note that] not only can you build applications faster as a
result, but the applications have similar structures. They are <b>easier
to maintain</b>, and they seem more consistent to their users. 
</p>
</blockquote>

<p>
However, you have to be careful when using frameworks. You should
check who is the maintainer and developer community behind it. You
are actually making your application tight to the architecture of
the framework. In this sense you must make sure that the framework
is mature, that the community behind it is strong and professional
such that they will not make too big architecture changes to the
frameworks that will not be reverse compatible and will cause a lot
of headache on your side in order to rework your solution.
</p>

<p>
So that is mostly it and this is the reason why you should be
careful in the decision you take when selecting a framework over
the other.
</p>

<p>
Note as well the following and why it is important to know the
relevant design patterns
</p>

<blockquote>
<p>
An added benefit comes when the framework is documented with the
design patterns it uses.
</p>

<p>
People who know the patterns gain insight into the framework faster.
</p>

<p>
While design patterns might not flatten the learning curve of
frameworks entirely, they can make it less steep by making key
elements of the framework's design more explicit.
</p>
</blockquote>
</div>
</div>
