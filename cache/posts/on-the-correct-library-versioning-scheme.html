<p>
So basically this is a very quick post on how to properly version your
libraries.
</p>

<p>
Essentially, you will use it in both of your python packages twine
uploads and in your gradle java libraries packages. 
</p>

<p>
Moreover, it is important as once you appreciate the proper way of
versioning libraries you will understand why Azure DevOps prevents you
from uploading two libraries with the same version - or let's say to
overwrite the thing. 
</p>

<p>
You will understand that this actually happens as a way to indicate
you that you should comply with standard versioning systems used
across the world.
</p>

<p>
In general there are two different schools of working with the general
versioning schema. You should decide which school you want to comply
with. I will explore the both in this post. 
</p>

<!-- TEASER_END -->

<div id="outline-container-orgc6883a5" class="outline-2">
<h2 id="orgc6883a5">On the conflict between (Maven) versioning model and CD mind-set</h2>
<div class="outline-text-2" id="text-orgc6883a5">
<p>
So basically there is an inherent tension between the prescribed
versioning schema in maven and the one you should leverage when
performing CD - continuous delivery.
</p>

<p>
Essentially the tension comes from the development process when
performing a library/app update.
</p>

<p>
In order to see this let's start with the Maven way of doing things
before switching to the CD way of doing things. Before a 20
sec. look into how to properly read the versioning numbers.
</p>
</div>


<div id="outline-container-org51dffd4" class="outline-3">
<h3 id="org51dffd4">Maven Dev Versioning Practices</h3>
<div class="outline-text-3" id="text-org51dffd4">
<p>
So essentially the idea of maven is to have a distinction between:
</p>

<ol class="org-ol">
<li>snapshots</li>

<li>release versions</li>
</ol>

<p>
The fundamental idea is that when developing you should not
increase the versioning for every build. You should rather use the
<code>snapshot</code> keyword. I.e a snapshot represents that an artifact is
still under development and shall not be used to production.
</p>

<p>
Note that under this development paradigm the following holds:
</p>

<blockquote>
<p>
Whenever the artifact is published to a binary repository, it’s
uploaded with the same version.
</p>

<p>
Any consumer of this artifact will only be able to retrieve the latest
version of that snapshot version.
</p>

<p>
At some point in development, it’s determined that the software is feature-complete.
Once it passes the QA process, it’s ready to be released to
production.
</p>

<p>
At that time, the -SNAPSHOT suffix is taken off the version and it’s
released to production.
</p>

<p>
Now you’re dealing with a release version of the artifact. Ultimately,
this means having to modify the version attribute in the POM file and
<b>checking it into VCS</b>.
</p>

<p>
A new development cycle starts by bumping up the <b>major and/or minor
version of your project</b>; the -SNAPSHOT suffix is added again. So you
see that the last - the build number stays always at 0.
</p>
</blockquote>

<p>
Note that this school is quite outdated and you should rather work
as next embedding everything in a strong DevOps process. 
</p>
</div>
</div>

<div id="outline-container-org36adad7" class="outline-3">
<h3 id="org36adad7">CD Versioning</h3>
<div class="outline-text-3" id="text-org36adad7">
<p>
In contrast to the maven school the idea of CD is to include your
development in VCS and work in a way that every commit can become
a release to production.
</p>

<p>
I.e. every commit should be deployed by your pipeline in the
different environments.  Meaning it should be deployed to Dev and
then potentially UAT and finally if passing the user acceptance
tests to production.
</p>

<p>
Obviously deployment just happens if the software passes all
phases defined by the build pipeline with the quality standards
agreed on by the team.
</p>

<p>
This is how versioning is and shall be used in the CD world.
</p>

<blockquote>
<p>
2.11.177
</p>

<p>
2 -&gt; major version update
</p>

<p>
11 -&gt; minor version update / features
</p>

<p>
177 -&gt; build number
</p>
</blockquote>

<p>
In this sense you see that it is necessary to increase the build
number after each build.
</p>

<p>
Check at your gradle scripts in order to see how to do it. 
</p>
</div>
</div>

<div id="outline-container-org85f7074" class="outline-3">
<h3 id="org85f7074">Overview of the two Schools</h3>
<div class="outline-text-3" id="text-org85f7074">
<p>
So you understand the two schools of thought above. In one the
build increase and every commit could be potentially the release
to production.
</p>

<p>
In the other not but you rather work with snapshots. 
</p>

<img src="../../images/Screenshot 2022-09-27 142038.png" class="center">
</div>
</div>

<div id="outline-container-org60b9729" class="outline-3">
<h3 id="org60b9729">On the CD school</h3>
<div class="outline-text-3" id="text-org60b9729">
<p>
I declare that I will be CD school scholar. 
</p>
</div>
</div>
</div>


<div id="outline-container-orgb04d952" class="outline-2">
<h2 id="orgb04d952">On the Implemenation of the Above in Java And Python</h2>
<div class="outline-text-2" id="text-orgb04d952">
<p>
So basically once you fixed the school, the question is how to work
in such away with your go to languages.
</p>

<p>
We will see it next. 
</p>
</div>

<div id="outline-container-org5da6111" class="outline-3">
<h3 id="org5da6111">Python</h3>
<div class="outline-text-3" id="text-org5da6111">
<p>
I start with Python. The system is more developed in this
sense. At least from what I could find online and with what comes
out of the box. I guess there are solutions in java if you dig
enough. In any case I created a tailored made one as you can read
in the next section.
</p>

<p>
See in this sense <a href="https://python-poetry.org/docs/cli/#version">poetry version concept</a> [<a href="https://py-pkgs.org/07-releasing-versioning">other link</a>]. You can
easily see there how you can deploy with different bump rules that
will automatically increase the build etc. 
</p>

<p>
Take some time in order to properly see poetry is quite
extensive. Understand how it fits into your python stack. I guess
it could replace the build tool I am using and should be triggered
after the relevant tox processes. 
</p>
</div>
</div>

<div id="outline-container-org7650e7e" class="outline-3">
<h3 id="org7650e7e">Java</h3>
<div class="outline-text-3" id="text-org7650e7e">
<p>
Here I created a relevant task in gradle in order to perform this
necessary step.
</p>

<p>
You can find the relevant commit <a href="https://github.com/MarcoHassan/mySpringPlayground/commit/dc74b3e904f343d3d9f7b9c51cb0dba00f932efa">here</a>. It borrows heavily from
<a href="https://stackoverflow.com/questions/39824574/version-increment-using-gradle-task">this</a>.
</p>

<p>
Note that what is missing is making the relevant build steps
dependent on this newly created task.
</p>

<p>
In such a way you can use the general command and do not have to
trigger complex logic for your build. Keep it simple, always.
</p>
</div>
</div>
</div>
