<br>
<br>

<p>
<i>Disclaimer; very much of the material under this page is directly copied from various sources on the internet. Check at the Literature section below to get to the source of the post.</i>
</p>

<p>
The basic idea of Docker is to allow the possibility to save all of
the configuration of an application in one single image. This should
be considered as a safe environment that once properly set up can be
easily shared among different teams and once images are instantiated
all of the different teams can be sure to operate and leverage the
right configuration for running their application.
</p>

<p>
A simple and straight forward overview about the advantage of Docker
might be found in this sense at <a href="https://www.tutorialspoint.com/docker/docker_architecture.htm">docker architecture</a>.
</p>

<p>
To sum up before starting the basic idea is to create images and to
create containers based on that, which will run then the application
as defined in the docker image.
</p>

<!-- TEASER_END -->

<div id="outline-container-org748c550" class="outline-3">
<h3 id="org748c550">General theory</h3>
<div class="outline-text-3" id="text-org748c550">
<p>
Lifecycle: build, ship, run. -&gt; build ur application. Wrap it up in a
container and ship it. Run it and scale it then. This allows portability. 
</p>

<p>
Parts of docker:
</p>
</div>

<div id="outline-container-orgd716d2c" class="outline-4">
<h4 id="orgd716d2c">Image</h4>
<div class="outline-text-4" id="text-orgd716d2c">
<p>
Read only. It is a snapshot of a container stored on a registry. U use
it as a template for creating containers.
</p>
</div>
</div>

<div id="outline-container-orgc907703" class="outline-4">
<h4 id="orgc907703">Container</h4>
<div class="outline-text-4" id="text-orgc907703">
<p>
This is the runtime instance of the image. A running copy of that.
</p>
</div>
</div>

<div id="outline-container-org7e41d58" class="outline-4">
<h4 id="org7e41d58">Registry</h4>
<div class="outline-text-4" id="text-org7e41d58">
<p>
This is essentially a repository where docker images are stored.
</p>
</div>
</div>

<div id="outline-container-orgbeb3818" class="outline-4">
<h4 id="orgbeb3818">Docker Engine</h4>
<div class="outline-text-4" id="text-orgbeb3818">
<p>
This effectively run the containers. 
</p>
</div>
</div>

<div id="outline-container-org67f8961" class="outline-4">
<h4 id="org67f8961">Difference with VM</h4>
<div class="outline-text-4" id="text-org67f8961">
<p>
With virtual machine you leverage hypervisors that runs virtual
machines. It is what virtualizes resources and makes them sharable.
Up on the virtualized resources you build then your different OS and
specify all of the middleware necessary to run your application.
</p>

<p>
In contrast to <i>virtual machines</i> that with docker, u have a single
host OS. Notice moreover that docker does not require the entire Linux
OS but rather simply its kernel. Important is moreover to notice that
all the containers share the linux kernel here.
</p>

<p>
Docker tries to share resources. This means that if a layer is already
running for an application a second application will leverage the
instance of this exact lower layer and will ultimately save resources.
</p>
</div>
</div>
</div>


<div id="outline-container-org32bd0ad" class="outline-3">
<h3 id="org32bd0ad">Create Images with Dockerfiles</h3>
<div class="outline-text-3" id="text-org32bd0ad">
</div>
<div id="outline-container-org676edf5" class="outline-4">
<h4 id="org676edf5">General Workflow</h4>
<div class="outline-text-4" id="text-org676edf5">
<p>
The first thing to do is to create your working directory. Don't use
the root directory as it will expose your container to security
vulnerabilities.
</p>

<p>
Within that directory create then the <code>Dockerfile</code> that will include
all of the set of instructions necessary to create your image.
Important is that in the Dockerfile each instruction is executed in
order. So consider that carefully when specifying the commands. 
</p>

<p>
You can comment dockerfiles with the comments by <code>#</code>.
</p>

<p>
Finally use the <code>docker build</code> command to create the image.
</p>
</div>
</div>


<div id="outline-container-orga2ff861" class="outline-4">
<h4 id="orga2ff861">Commands for Dockerfile image</h4>
<div class="outline-text-4" id="text-orga2ff861">
<p>
Writing a Dockerfile is the first step to containerizing an
application. You can think of these Dockerfile commands as a
step-by-step recipe on how to build up our image. This one takes the
following steps:
</p>

<pre class="example" id="org7c3e3dc">
## Example of a Dockerfile

FROM node:6.11.5    

WORKDIR /usr/src/app
COPY package.json .
RUN npm install    
COPY . .

CMD [ "npm", "start" ]  

</pre>

<p>
Notice;
</p>

<ul class="org-ul">
<li><code>FROM</code> start the pre-existing docker image <code>node:6.11.5</code>. This was
cloned from the git repo used in the tutorial. It gives a grasp on
the layered structure of docker, where you can start in the lower
layer with basic images and run on top of them new images leveraging
the basic ones.</li>

<li><code>WORKDIR</code> specifies that all the subsequent actions should be taken
from the directory <code>/usr/src/app/</code> in your <b>image filesystem</b>.</li>

<li><code>COPY</code> the file <code>package.json</code> from your docker host to the present
location <code>.</code> such that it is available in the image and the
deployment can leverage it. Notice that the files passed with the
<code>COPY</code> command will be used by the <code>$ docker build</code> command to
create an image. To increase the build’s performance, exclude files
and directories by adding a <code>.dockerignore</code>.</li>

<li><code>RUN</code> the command <code>npm install</code> inside your <b>image filesystem</b>. This
in general executes commands.</li>

<li><code>COPY</code> the rest of your app's source code from your host to your
image filesystem. I.e. it allows you to copy files from your host
filesystem to your image filesystem.</li>
</ul>

<p>
The final line with the <code>CMD</code> directive is the docker specific way of
specifying some metadata in our image that describes how to run a
container based off of the specified image.
</p>

<p>
In this case, it’s saying that the containerized process that this
image is meant to support is <code>npm start</code>.
</p>

<p>
Important that the <code>CMD</code> commands will run in relation to the image
entrypoint which is discussed here below. If you do not specify any
entrypoint the default is the <code>/bin/sh -c</code> and therefore you can run
standard bash commands as above.
</p>

<p>
Further instructions are:
</p>

<ul class="org-ul">
<li><code>LABEL</code> this is metadata. it is a key-value pair that can be used
later for filtering the containers.</li>

<li><code>MAINTAINER</code> also metadata where you can for instance enter the
e-mail of the maintainer.</li>

<li><code>EXPOSE</code> it specifies the port used for the process running on the
container.</li>

<li><code>ENV</code> it is specifying environment variables.</li>

<li><code>ADD</code> it adds files from remote places to your container.
an example for it might be <code>ADD http:/link/of/picture /tmp</code>. Notice
that add has the capability of <b>untar</b> files while the <code>COPY</code>
command does not offer that capability.</li>

<li><code>USER</code> it will allow you to specify the user through which the
commands specified in the <code>Dockefile</code> will be run. Recall commands
are sequential in docker.</li>

<li><code>ENTRYPOINT</code> specifies the entrypoint of the container. the default
is <code>/bin/sh -c</code></li>
</ul>

<p>
You can see that <i>these are much the same steps you might have taken to
set up and install your app on your host</i> - but capturing these as a
Dockerfile allows us to do the same thing inside a portable, isolated
Docker image.
</p>
</div>
</div>
</div>

<div id="outline-container-org396982f" class="outline-3">
<h3 id="org396982f">Image Layering</h3>
<div class="outline-text-3" id="text-org396982f">
<p>
Notice that each time you <code>RUN</code> a Dockerfile it will create a further
layer. If the image has too many layers the image will rapidly grow in
size and you would obtain a very big and heavy image which is not the
goal of Docker.
</p>

<p>
In order to reduce the layers of an image it makes therefore sense to
leverage the <code>&amp;&amp;</code> bash command to sequentially execute two bash
commands in one <code>RUN</code> instruction such that you will keep your image
lightweight. You can use the split line <code>\</code> to increase readability.
</p>
</div>
</div>

<div id="outline-container-orgdd52ab2" class="outline-3">
<h3 id="orgdd52ab2">Docker images Management</h3>
<div class="outline-text-3" id="text-orgdd52ab2">
<p>
Below a short list of commands. This is however just a way to write
them down one time and start to memorize it. A convenient approach
when looking forward to do smth is to leverage <code>docker --help</code> and
search for the keyword of interest. You can then further inspect with
<code>docker &lt;command&gt; --help</code>.
</p>

<div class="highlight"><pre><span></span><span class="c1"># To build an image from a Dockerfile and a context. The build s</span>
<span class="c1"># context is the set of files at a specified location PATH or URL (git</span>
<span class="c1"># repository location).</span>

<span class="c1"># if the dockerfile is not in the same repo as your context then.</span>
$ docker build -f &lt;dockerfile&gt; .
<span class="c1"># else; if you are in your context repo and there is where the dockerfile is specified</span>
$ docker build .

<span class="c1"># to build an image and associate it with a given tag you can leverage the -t flag</span>
<span class="c1"># the tag is how you name your images. you can then call them by tag.</span>
$ docker build -t bullet_inboard:1.0 &lt;directory where the dockerfile is&gt;
<span class="c1"># notice again that is common practice to name the images as</span>
<span class="c1"># &lt;hostname&gt;/&lt;repository&gt;:&lt;image tag&gt;; where hostname = hostname of</span>
<span class="c1"># registry where you will save your image</span>

<span class="c1"># To list all the avaialble images</span>
$ docker image ls

<span class="c1"># To run a container:</span>
$ docker run &lt;img name&gt;

<span class="c1"># Notice that there are multiple useful flags that further </span>
$ docker container run --publish <span class="m">8000</span>:8080 --detach --name bb bulletinboard:1.0
   <span class="c1">## --publich specifies the &lt;host port&gt;:&lt;docker port&gt; for</span>
    <span class="c1"># communication. This assures that you can communicate with your</span>
    <span class="c1"># docker container through port 8000 of your docker host. For</span>
    <span class="c1"># instance it is then possible to look at your application in a</span>
    <span class="c1"># browser of the host at localhost:8000.</span>
  <span class="c1">## --detach ask docker to run the container in the background</span>
  <span class="c1">## --name allows to specify a name (here bb) to access the container as this at a later stage.</span>


<span class="c1"># To list all of the containers running:</span>
$ docker ps

<span class="c1"># To list all of the containers on the system:</span>
$ docker ps -a

<span class="c1"># To see top processes within a running container:</span>
$ docker top &lt;Container ID&gt;

<span class="c1"># To stop a running container:</span>
$ docker stop &lt;Container ID&gt;

<span class="c1"># To remove container:</span>
$ docker rm &lt;Container ID&gt;

<span class="c1"># To see stats about disk usage, cpu etc of a running container:</span>
$ docker stats &lt;Container ID&gt;

<span class="c1"># To pause processes running on container:</span>
$ docker pause &lt;Container ID&gt;

<span class="c1"># To resume after the pause</span>
$ docker unpause &lt;Container ID&gt;

<span class="c1"># To kill procsses</span>
$ docker <span class="nb">kill</span> &lt;Container ID&gt;

<span class="c1"># To stop the docker deamon running in the background </span>
$ servce docker stop


<span class="c1"># If you want to use the image in another context and differentiate</span>
<span class="c1"># the image you can use the docker tag command</span>
$ docker tag my-app:v1 second-app:v1
<span class="c1"># then you will have a new image tag that refers to the same</span>
<span class="c1"># image. you should be able to see the both if running docker images ls</span>
<span class="c1"># notice that the image IDs will be the same.</span>

<span class="c1"># To push an image to a registry you can then simply use the command</span>
$ docker push my-app:v1
<span class="c1"># notice that here no registry hostname is specified so that by</span>
<span class="c1"># default you would push it to the defualt docker registry.</span>
<span class="c1"># I created a public registry on dockerhub. with the following &lt;hostname&gt;/&lt;registry&gt; combination</span>
<span class="c1"># marcohassan/publicrepomahass. Then after tagging an image marcohassan/publicrepomahass:&lt;name_chosen&gt;</span>
<span class="c1"># I was able to push it there with</span>
$  docker push marcohassan/publicrepomahass:coursera_workflow_01
</pre></div>
</div>
</div>


<div id="outline-container-org566bf03" class="outline-2">
<h2 id="org566bf03">Literature</h2>
<div class="outline-text-2" id="text-org566bf03">
<p>
<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>
</p>

<p>
<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>
</p>
</div>
</div>
