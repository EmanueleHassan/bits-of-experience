<style>
img {
display: block;
margin-left: auto;
margin-right: auto;
}
</style>


<p>
Here some python visualization dummy scripts are saved
</p>

<!-- TEASER_END -->

<br>
<br>

<div id="outline-container-org38cbe4f" class="outline-2">
<h2 id="org38cbe4f">Data</h2>
<div class="outline-text-2" id="text-org38cbe4f">
<div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
%matplotlib inline 
%config InlineBackend.figure_format = &#39;png&#39;
import numpy as np
</pre></div>

<div class="highlight"><pre><span></span>N = 30
x_1 = np.random.randn(N) * 3
x_2 = np.random.randn(N) * 3 + 2
x_3 = np.random.randn(N) * 3 + -2
</pre></div>
</div>
</div>

<div id="outline-container-orgbf3db5a" class="outline-2">
<h2 id="orgbf3db5a">Work with pandas</h2>
<div class="outline-text-2" id="text-orgbf3db5a">
<div class="highlight"><pre><span></span>import pandas as pd
</pre></div>

<ul class="org-ul">
<li>create data from numpy matrix</li>
</ul>

<div class="highlight"><pre><span></span>mydat = pd.DataFrame (np.matrix ([x_1,x_2,x_3]).transpose ())
</pre></div>

<ul class="org-ul">
<li>create data from two numpy arrays</li>
</ul>

<p>
here you need to flatten the arrays first
</p>

<div class="highlight"><pre><span></span>X = 2 * np.random.rand(100,1)
y = 4 +3 * X+np.random.randn(100,1)

mydat = pd.DataFrame ({&#39;x&#39;:X.flatten(), &#39;y&#39;: y.flatten()})
</pre></div>


<ul class="org-ul">
<li>on reshape -1</li>
</ul>

<p>
The criterion to satisfy for providing the new shape is that <b>The new
shape should be compatible with the original shape</b>
</p>

<p>
Numpy allow us to give one of new shape parameter as -1 (eg: (2,-1) or
(-1,3) but not (-1, -1)). It simply means that it is an unknown
dimension and we want numpy to figure it out. And numpy will figure
tchis by looking at the 'length of the array and remaining dimensions'
and making sure it satisfies the above mentioned criteria
</p>

<p>
Now see the example.
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
	 <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
	 <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="k">print</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="k">print</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">reshape</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="k">print</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">reshape</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

<pre class="example">
(3, 4)
(12,)
(6, 2)
</pre>


<ul class="org-ul">
<li>describe the data</li>
</ul>

<div class="highlight"><pre><span></span>mydat.describe ()
</pre></div>

<ul class="org-ul">
<li>sort multiple variables in pandas data frames.</li>
</ul>

<div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;Year&#39;</span><span class="p">,</span> <span class="s2">&quot;Happiness_Score&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>

<ul class="org-ul">
<li>Set the name of the columns</li>
</ul>

<div class="highlight"><pre><span></span>mydat.columns = [&quot;nomean&quot;, &quot;posmean&quot;, &quot;negmean&quot;]
</pre></div>

<div class="highlight"><pre><span></span>mydat.columns
</pre></div>

<div class="highlight"><pre><span></span>plt.plot(mydat.nomean, c = &quot;lightblue&quot;, ls = &#39;--&#39;, marker = &quot;o&quot;,
	 ms = 6, label =&quot;nomean&quot;)
plt.plot(mydat.posmean, c = &quot;darkorange&quot;, ls = &#39;--&#39;, marker = &quot;s&quot;,
	 ms = 6, label =&quot;posmean&quot;) # ms = marker size
plt.plot(mydat.negmean, c = &quot;lightgreen&quot;, ls = &#39;--&#39;, marker = &quot;^&quot;,
	 ms = 6, label =&quot;negmean&quot;)
plt.legend(loc = &#39;upper right&#39;,bbox_to_anchor = (1,1))
plt.xticks(list(range(20)), rotation = &#39;vertical&#39;) # sets the ticks on
						   # x-axis and puts
						   # them vertically.
</pre></div>


<ul class="org-ul">
<li>get the entry (x,y) in your relational table</li>
</ul>

<div class="highlight"><pre><span></span>mydat.head (5)
</pre></div>

<div class="highlight"><pre><span></span>mydat.iloc[2,1]
</pre></div>

<ul class="org-ul">
<li>slicing the data</li>
</ul>

<div class="highlight"><pre><span></span>mydat[0:4]
</pre></div>

<ul class="org-ul">
<li>get by column</li>
</ul>

<div class="highlight"><pre><span></span>mydat[[&#39;nomean&#39;, &#39;posmean&#39;]].head (3)
</pre></div>

<ul class="org-ul">
<li>get by row and column</li>
</ul>

<div class="highlight"><pre><span></span>mydat[[&#39;nomean&#39;, &#39;posmean&#39;]][::2]
</pre></div>

<div class="highlight"><pre><span></span>print(mydat[[&#39;nomean&#39;, &#39;posmean&#39;]].iloc [0,1])
</pre></div>

<ul class="org-ul">
<li>new column</li>
</ul>

<div class="highlight"><pre><span></span>mydat[&#39;sum&#39;] = mydat[&#39;nomean&#39;] + mydat[&#39;posmean&#39;] + mydat[&#39;negmean&#39;]
</pre></div>

<div class="highlight"><pre><span></span>mydat.columns
</pre></div>

<div class="highlight"><pre><span></span>mydat2 = mydat
mydat.head ()
</pre></div>

<ul class="org-ul">
<li>drop a column</li>
</ul>

<div class="highlight"><pre><span></span>mydat2.drop (&#39;sum&#39;, axis = 1).head ()
</pre></div>

<ul class="org-ul">
<li>filter through booleans</li>
</ul>

<div class="highlight"><pre><span></span>filt = mydat.nomean &lt; 0

print (mydat[[&#39;sum&#39;, &#39;negmean&#39;]][filt])
</pre></div>


<ul class="org-ul">
<li>remove duplicates</li>
</ul>

<div class="highlight"><pre><span></span>print (np.matrix ([[1,2,1],[3,3,3]]).transpose ())

pd.DataFrame (np.matrix ([[1,2,1],[3,3,3]]).transpose ()).iloc[:,1].unique ()
</pre></div>

<p>
another possibility that addresses data frame wide duplicates and not
simply column duplicates is by leveraging <code>.duplicated ()</code> method:
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">romeo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>

<span class="k">print</span><span class="p">(</span><span class="n">romeo</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">romeo</span><span class="o">.</span><span class="n">duplicated</span><span class="p">())</span>

<span class="n">romeo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="k">print</span><span class="p">(</span><span class="n">romeo</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">romeo</span><span class="o">.</span><span class="n">duplicated</span><span class="p">())</span>
</pre></div>

<ul class="org-ul">
<li>on the difference between <code>.iloc</code> and <code>.loc</code></li>
</ul>

<p>
notice by the way that this are outdated. by now you should use <code>.iat</code>
and <code>.at</code>.
</p>

<p>
The difference is the following.
</p>

<p>
<code>.iat</code> : uses the strict position in the matrix
</p>

<p>
<code>.at</code> : search by index and column names
</p>


<div class="highlight"><pre><span></span>print (mydat)
mydat.at[0, &#39;negmean&#39;]
</pre></div>

<div class="highlight"><pre><span></span>mydat.iat[0,2]
</pre></div>

<p>
To further understand the thing consider
</p>

<div class="highlight"><pre><span></span>mydat2 = mydat[::2]
mydat2
</pre></div>

<div class="highlight"><pre><span></span>print (mydat2.at[6, &#39;nomean&#39;]) ## this by real index independent of the axis
print (mydat2.iat[6, 0]) ## this sixth row in the matrix
</pre></div>

<ul class="org-ul">
<li>categorical variables</li>
</ul>

<p>
This is important for treating them as dummies in regression as well
for facet<sub>wraps</sub>. 
</p>

<div class="highlight"><pre><span></span>mydat.head ()
</pre></div>


<div class="highlight"><pre><span></span>mydat[&quot;category&quot;] = np.repeat (range (4), 5)
mydat.info ()
</pre></div>

<p>
To transform this into a category use
</p>

<div class="highlight"><pre><span></span>mydat.category = mydat.category.astype (&#39;category&#39;)
mydat.info ()
</pre></div>


<p>
To view the category types
</p>

<div class="highlight"><pre><span></span>mydat.category.cat.categories
</pre></div>

<p>
To check for missing values <code>NaN</code> 
</p>

<div class="highlight"><pre><span></span><span class="c1">## check if there are null values for stream_id column</span>
<span class="n">df_streams</span><span class="p">[[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

<span class="c1">## get the null values</span>
<span class="n">df_streams</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_streams</span><span class="p">[[</span><span class="s1">&#39;stream_id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">())]</span>
</pre></div>

<p>
In order to apply a function sequentially to each entry in a column
dataframe you can use the <code>apply</code> function on pandas dataframe.
</p>

<p>
For instance for the following dataframe
</p>

<div class="highlight"><pre><span></span><span class="n">cust_id</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

<p>
Then you could specify a function return the years since the date in
column dob
</p>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">datetime_object</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;%m/</span><span class="si">%d</span><span class="s1">/%y&#39;</span><span class="p">)</span>

    <span class="n">datetime_now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">datetime_now</span><span class="o">.</span><span class="n">year</span> <span class="o">-</span> <span class="n">datetime_object</span><span class="o">.</span><span class="n">year</span>
</pre></div>

<p>
Finally you can pass the <code>apply</code> function to each row of your
pandas dataframe column by
</p>

<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">cust_id</span><span class="p">[</span><span class="s1">&#39;dob&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">age</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>

<span class="n">cust_id</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cust_id</span><span class="p">[</span><span class="s1">&#39;dob&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">age</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>

<span class="n">cust_id</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

<pre class="example">
        dob  1            2        3               4  5              6  \
0  07/30/98  1         Todd    Kasen  South Carolina  m  united_states  
1  04/12/89  2        Garza   Ensley            None  f      singapore
2  09/12/97  3        Carey  Lillian         Alabama  f  united_states
3  01/28/99  4  Christensen     Beau        New York  m  united_states
4  03/23/98  5       Gibson  Ernesto            None  m      singapore 

age  
22  
31  
23  
21  
22  
</pre>

<ul class="org-ul">
<li>deleting missing data</li>
</ul>

<p>
In order to delete missing data you can simply rely on the 
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">nan</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;apple&#39;</span><span class="p">,</span><span class="s1">&#39;banana&#39;</span><span class="p">,</span><span class="s1">&#39;orange&#39;</span><span class="p">],</span>
		   <span class="s1">&#39;price&#39;</span><span class="p">:[</span><span class="mf">1.95</span><span class="p">,</span> <span class="mf">3.00</span><span class="p">,</span> <span class="n">nan</span><span class="p">],</span> <span class="s1">&#39;inventory&#39;</span><span class="p">:[</span><span class="n">nan</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">23</span><span class="p">]})</span>


<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="k">print</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After deleting missing values:&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span>
</pre></div>

<p>
In the above you eliminate the entire <b>row</b> where the missing value
occurred.
</p>

<p>
The above is particular important when missing observations occurs
randomly such that you might safely ignore individual observations
without increasing the bias of your analysis given your data.
</p>

<p>
A second possibility, when dealing with missing data consists in
deleting entire features (i.e. columns). You can do that by setting
the argument <code>'columns'</code> in your <code>.dropna ()</code> method
</p>

<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="k">print</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After deleting missing values:&quot;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;columns&#39;</span><span class="p">))</span>
</pre></div>

<ul class="org-ul">
<li>impute missing data</li>
</ul>

<p>
a different approach on handling missing data is to <b>impute</b> missing
data. This means that instead of removing the data observations you
try to replace them with some meaningful information.
</p>

<p>
This might be useful for instance when understanding that data are not
missing at random and you might use the dependency on other features -
i.e. a predictive model based on that - to impute missing variables. 
</p>

<p>
Other simpler methods might involve taking simple features means as a
data-filler or some simple analogous measure. An example in this sense
might be 
</p>

<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>

<span class="k">print</span> <span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;inventory&#39;</span><span class="p">]</span>
<span class="n">imp</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">()</span>

<span class="c1"># Use .values attribute bc sklearn works with arrays rather than DataFrames</span>
<span class="n">imp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">imp</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
</pre></div>

<p>
where notice that in the above the simple average was taken to replace
missing values. Notice moreover how the standard sklearn API applies -
i.e. the <code>.fit ()</code> and <code>.transform ()</code> methods.
</p>
</div>

<div id="outline-container-orgffd81a9" class="outline-3">
<h3 id="orgffd81a9">New dataset</h3>
<div class="outline-text-3" id="text-orgffd81a9">
<p>
For the next sections I will use the following new dataset
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
</pre></div>

<div class="highlight"><pre><span></span>df = pd.read_csv(&quot;~/Desktop/Learning/AI_workflow_Coursera/Visualization/world-happiness.csv&quot;,index_col=0)
print(&quot;df: {} x {}&quot;.format(df.shape[0],df.shape[1]))

## clean up the column names and remove some
df.columns = [re.sub(&quot;\s+&quot;,&quot;_&quot;,col) for col in df.columns.tolist()]
df.head(n=4)
</pre></div>

<pre class="example">
       Country                           Region  Happiness_Rank  ...  Generosity  Dystopia_Residual  Year
0  Afghanistan                    Southern Asia           153.0  ...     0.36510            1.95210  2015
1      Albania       Central and Eastern Europe            95.0  ...     0.14272            1.89894  2015
2      Algeria  Middle East and Northern Africa            68.0  ...     0.07822            2.43209  2015
3       Angola               Sub-Saharan Africa           137.0  ...     0.12344            1.94939  2015

[4 rows x 12 columns]
</pre>



<ul class="org-ul">
<li>view a review of all of the null values</li>
</ul>

<div class="highlight"><pre><span></span> <span class="c1">## missing values summary</span>
 <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Missing Value Summary</span><span class="se">\n</span><span class="s2">{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">35</span><span class="p">))</span>
 <span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>

<pre class="example">
Missing Value Summary
-----------------------------------
Country                           0
Region                            0
Happiness_Rank                   25
Happiness_Score                  25
Economy_(GDP_per_Capita)         25
Family                           25
Health_(Life_Expectancy)         25
Freedom                          25
Trust_(Government_Corruption)    25
Generosity                       25
Dystopia_Residual                25
Year                              0
dtype: int64
</pre>


<ul class="org-ul">
<li><p>
pivot data frame and create aggregate measures for them (similar to
mutate in <code>dplyr</code>)
</p>

<div class="highlight"><pre><span></span>  <span class="n">columns_to_show</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Happiness_Score&quot;</span><span class="p">,</span><span class="s2">&quot;Health_(Life_Expectancy)&quot;</span><span class="p">]</span>
  <span class="n">pd</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span> <span class="s1">&#39;Year&#39;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="n">columns_to_show</span><span class="p">,</span><span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div></li>
</ul>


<ul class="org-ul">
<li>groupby</li>
</ul>

<p>
analogously to the previous version one can compute aggregated
measures using the groupby command
</p>

<div class="highlight"><pre><span></span>   <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;Year&#39;</span><span class="p">])[</span><span class="n">columns_to_show</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>
Aggregating by multiple columns is straightforward.
</p>

<div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Region&#39;</span><span class="p">,</span> <span class="s1">&#39;Year&#39;</span><span class="p">],</span> <span class="n">values</span><span class="o">=</span><span class="n">columns_to_show</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1">## or</span>
<span class="c1"># df.groupby([&#39;Region&#39;, &#39;Year&#39;])[columns_to_show].mean().round(3)</span>
</pre></div>

<p>
Finally you can pass a column entry instead of displaying the results
as above. This is more user friendly in case you might have to merge
the results into other data frames.
</p>

<div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;Region&#39;</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;Year&#39;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="s2">&quot;Happiness_Score&quot;</span><span class="p">)</span>
</pre></div>



<ul class="org-ul">
<li>create factor variables out of continuous variables through the
<code>cut</code> method.</li>
</ul>

<div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">cut</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Happiness_Rank&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

<ul class="org-ul">
<li>append a column to a dataframe</li>
</ul>

<div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Happiness_Rank&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)],</span> 
	  <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org47b1e44" class="outline-2">
<h2 id="org47b1e44">Sparse Matrices</h2>
<div class="outline-text-2" id="text-org47b1e44">
<p>
It is essential for data engineers and data scientists to know how to
work with sparse matrices. This are matrices with many <code>0</code> entries and
just a few non-zero entries. 
</p>

<p>
Instead of representing these kind of matrices in their <code>dense
representation</code> i.e. with a bunch of <code>0</code> entries you might save the
information in a more compressed way. This will allow to save on
memory on your machines and to effectively work with huge matrices.
</p>

<p>
Sparse matrices are moreover important for the development of ML
jobs. The idea is that once you found a well performing ML model you
might create data pipelines that extract transform and load data to
your ML model in the desired shape.
</p>

<p>
At the beginning, when you are exploring the data and trying to come
up with a meaningful model it does not make sense to create such data
pipelines as the job of coming up with them might be time-consuming
and you might end up with no business value added from your ML
application. 
</p>

<p>
It is therefore important to postpone the creation of such time
consuming tasks at the end. when you have a production ready ML
model. 
</p>

<p>
Before of that it is advisable to leverage dumps of data and to
explore your system through them. In this sense sparse matrices are
especially beneficial when data can be efficiently represented through
them. These allow you to store a huge amount of data due to their
efficient memory management - i.e. by saving just the relevant portion
of your data -.
</p>

<p>
In python you can work with sparse matrices via:
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
</pre></div>

<p>
Notice that a matrix, is said to be sparse if more than 50% of its
entries are 0.
</p>

<p>
For instance the following matrix is sparse
</p>

<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">sparcity</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sparcity</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

<pre class="example">
0.4974
</pre>


<p>
There are essentially four types of sparse matrices used for
computation.
</p>

<p>
CSC (Compressed Sparse Column) and CSR (Compressed Sparse Row) are
more compact and efficient, but difficult to construct "from
scratch". 
</p>

<p>
Coo (Coordinate) and DOK (Dictionary of Keys) are easier to construct,
and can then be converted to CSC or CSR via matrix.tocsc() or
matrix.tocsr().
</p>

<p>
CSC is more efficient at accessing <b>column-vectors or column
operations</b>, generally, as it is stored as arrays of columns and their
value at each row.
</p>

<p>
CSR matrices are the opposite; stored as arrays of rows and their
values at each column, and are <b>more efficient at accessing row-vectors
or row operations</b>.
</p>

<p>
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html#scipy.sparse.coo_matrix">coo matrix</a>
</p>

<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">),</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

<pre class="example">
A &lt;class 'numpy.ndarray'&gt; (10, 100) 
B &lt;class 'scipy.sparse.coo.coo_matrix'&gt; (10, 100) 
C &lt;class 'numpy.matrix'&gt; (10, 100)
</pre>


<p>
You see that you can transform back and forth from dense matrices to
sparse matrices.
</p>

<p>
Coo sparse matrix built from the COOrdinates and values of the
non-zero entries.
</p>

<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>

<pre class="example">
(0, 1)	2
  (0, 2)	1
  (0, 6)	1
  (0, 8)	1
  (0, 9)	1
  (0, 10)	1
  (0, 13)	1
  (0, 18)	1
  (0, 19)	2
  (0, 21)	1
  (0, 23)	1
  (0, 24)	2
  (0, 29)	1
  (0, 31)	1
  (0, 34)	1
  (0, 42)	1
  (0, 50)	1
  (0, 51)	1
  (0, 62)	3
  (0, 69)	1
  (0, 70)	1
  (0, 71)	2
  (0, 72)	1
  (0, 78)	1
  (0, 80)	1
  :	:
  (9, 8)	1
  (9, 9)	2
  (9, 11)	1
  (9, 24)	2
  (9, 26)	2
  (9, 27)	1
  (9, 37)	1
  (9, 38)	1
  (9, 44)	1
  (9, 45)	1
  (9, 49)	1
  (9, 50)	1
  (9, 51)	1
  (9, 55)	1
  (9, 57)	1
  (9, 58)	1
  (9, 59)	1
  (9, 62)	1
  (9, 66)	1
  (9, 74)	1
  (9, 79)	3
  (9, 80)	1
  (9, 82)	1
  (9, 92)	1
  (9, 96)	1
</pre>


<p>
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.html#scipy.sparse.csc_matrix">csc<sub>matrix</sub></a>
</p>

<div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>

<pre class="example">
(6, 0)	2
  (0, 1)	2
  (3, 1)	1
  (0, 2)	1
  (8, 2)	1
  (5, 3)	1
  (1, 4)	1
  (9, 4)	1
  (5, 5)	1
  (6, 5)	1
  (0, 6)	1
  (1, 6)	1
  (6, 6)	1
  (9, 6)	1
  (3, 7)	1
  (5, 7)	1
  (7, 7)	1
  (8, 7)	1
  (9, 7)	1
  (0, 8)	1
  (6, 8)	1
  (9, 8)	1
  (0, 9)	1
  (1, 9)	1
  (3, 9)	2
  :	:
  (3, 90)	2
  (6, 90)	1
  (7, 90)	1
  (8, 90)	1
  (0, 91)	1
  (2, 91)	1
  (4, 91)	1
  (5, 91)	1
  (6, 92)	1
  (7, 92)	1
  (9, 92)	1
  (8, 93)	1
  (0, 94)	1
  (1, 94)	1
  (4, 94)	1
  (0, 95)	1
  (1, 95)	1
  (3, 95)	1
  (5, 95)	1
  (5, 96)	1
  (9, 96)	1
  (1, 97)	1
  (4, 98)	1
  (1, 99)	1
  (3, 99)	1
</pre>

<p>
See that the above respects the column array storage. I.e. the
non-zero coordinates are returned column by column.
</p>

<p>
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix">csr<sub>matrix</sub></a>
</p>

<p>
Like the CSC format there is a CSR format to account for data that
repeat along the rows
</p>

<div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>

<pre class="example">
(0, 1)	2
  (0, 2)	1
  (0, 6)	1
  (0, 8)	1
  (0, 9)	1
  (0, 10)	1
  (0, 13)	1
  (0, 18)	1
  (0, 19)	2
  (0, 21)	1
  (0, 23)	1
  (0, 24)	2
  (0, 29)	1
  (0, 31)	1
  (0, 34)	1
  (0, 42)	1
  (0, 50)	1
  (0, 51)	1
  (0, 62)	3
  (0, 69)	1
  (0, 70)	1
  (0, 71)	2
  (0, 72)	1
  (0, 78)	1
  (0, 80)	1
  :	:
  (9, 8)	1
  (9, 9)	2
  (9, 11)	1
  (9, 24)	2
  (9, 26)	2
  (9, 27)	1
  (9, 37)	1
  (9, 38)	1
  (9, 44)	1
  (9, 45)	1
  (9, 49)	1
  (9, 50)	1
  (9, 51)	1
  (9, 55)	1
  (9, 57)	1
  (9, 58)	1
  (9, 59)	1
  (9, 62)	1
  (9, 66)	1
  (9, 74)	1
  (9, 79)	3
  (9, 80)	1
  (9, 82)	1
  (9, 92)	1
  (9, 96)	1
</pre>

<p>
See that the above respects the row array storage. I.e. the
non-zero coordinates are returned row by row.
</p>

<p>
<b>Notice:</b> that many np.&lt;methods&gt; used for performing matrix operations
do not work on sparse matrices. You might refer to <a href="https://docs.scipy.org/doc/scipy/reference/sparse.html">this link</a> for
checking on how to deal with that. A solution proposed is to
transform the sparse matrix in an array.
</p>

<p>
Finally, it is easy to populate a sparse matrix by
</p>

<div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="c1">## coodinates</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">tocsr</span><span class="p">())</span>
</pre></div>

<pre class="example">
[[0 1 0 0 0 0 0 0 0]
 [2 0 0 0 0 0 0 0 0]
 [0 0 0 0 1 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 4]]

  (0, 1)	1
  (1, 0)	2
  (2, 4)	1
  (8, 8)	4
</pre>

<p>
you can finally stack two sparse matrices, be it horizontally or
vertically together.
</p>

<div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;adding horizontally/by row&quot;</span><span class="p">)</span> 
<span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;adding vertically/by column&quot;</span><span class="p">)</span> 
<span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
</pre></div>

<pre class="example">
(9, 9) (1, 9)
adding horizontally
[[0 1 0 0 0 0 0 0 0]
 [2 0 0 0 0 0 0 0 0]
 [0 0 0 0 1 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 4]
 [0 1 0 0 2 0 0 0 1]]
adding vertically
[[0 1 0 0 0 0 0 0 0 0]
 [2 0 0 0 0 0 0 0 0 1]
 [0 0 0 0 1 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 2]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 4 1]]
</pre>
</div>
</div>


<div id="outline-container-org304ce28" class="outline-2">
<h2 id="org304ce28">MatplotLib</h2>
<div class="outline-text-2" id="text-org304ce28">
<div class="highlight"><pre><span></span>plt.plot(x_1, c = &quot;lightblue&quot;, ls = &#39;--&#39;, marker = &quot;o&quot;,
	 ms = 6, label =&quot;nomean&quot;)
plt.plot(x_2, c = &quot;darkorange&quot;, ls = &#39;--&#39;, marker = &quot;s&quot;,
	 ms = 6, label =&quot;posmean&quot;) # ms = marker size
plt.plot(x_3, c = &quot;lightgreen&quot;, ls = &#39;--&#39;, marker = &quot;^&quot;,
	 ms = 6, label =&quot;negmean&quot;)
plt.legend(loc = &#39;upper right&#39;,bbox_to_anchor = (1,1))
plt.xticks(list(range(20)), rotation = &#39;vertical&#39;) # sets the ticks on
						   # x-axis and puts
						   # them vertically.
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-e4d60f65359faf963dc9edc65a3851e0.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>stacked histograms via matplotlib</li>
</ul>

<div class="highlight"><pre><span></span>plt.hist([mydat[mydat.bitwise == True].nomean,
	  mydat[mydat.bitwise == False].posmean])
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-4e5223a40dc5aad0bb91fba3fb97f4c6.png" class="center">

<br>
<br>

<div class="highlight"><pre><span></span>plt.hist([mydat[mydat.bitwise == True].nomean,
	  mydat[mydat.bitwise == False].posmean],
	 stacked = True)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-a029aa36eeb77d6b33e123c2a7023261.png" class="center">

<br>
<br>
</div>
</div>

<div id="outline-container-org3a32314" class="outline-2">
<h2 id="org3a32314">Seaborn</h2>
<div class="outline-text-2" id="text-org3a32314">
<div class="highlight"><pre><span></span>sns.distplot (mydat[&#39;nomean&#39;])
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-6b9e2671be86b00c00b82558a0c879f3.png" class="center">

<br>
<br>

<div class="highlight"><pre><span></span>mydat.head ()
</pre></div>

<div class="highlight"><pre><span></span>g = sns.lmplot(x=&quot;posmean&quot;, y=&quot;sum&quot;, data = mydat)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-fdb6afb1310d32cd9d7ab3e7504bdc14.png" class="center">

<br>
<br>

<div class="highlight"><pre><span></span>import statsmodels
g = sns.lmplot(x=&quot;posmean&quot;, y=&quot;sum&quot;, col=&quot;bitwise&quot;, hue=&quot;bitwise&quot;, data=mydat,
	       y_jitter=.02,  truncate=False)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-bd913d592aa2ad7d32dda045f217c4b5.png" class="center">

<br>
<br>

<p>
To further inspect different visualization techniques check at the
<a href="https://seaborn.pydata.org/examples/index.html">seaborn page</a>.
</p>


<div class="highlight"><pre><span></span>g = sns.lmplot(x=&quot;posmean&quot;, y=&quot;sum&quot;, data = mydat, 
	       hue = &#39;bitwise&#39;, fit_reg = False)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-ffa4f4a083eb7753d04349001d0af209.png" class="center">

<br>
<br>


<ul class="org-ul">
<li>joinplot for inspecting the density of two functions</li>
</ul>


<div class="highlight"><pre><span></span>g = sns.jointplot (data = mydat, x = &#39;posmean&#39;, y = &#39;negmean&#39;)
</pre></div>

<div class="highlight"><pre><span></span>g = sns.jointplot (data = mydat, x = &#39;posmean&#39;, y = &#39;negmean&#39;, kind = &#39;hex&#39;)
</pre></div>

<div class="highlight"><pre><span></span>sns.jointplot (data = mydat, x = &#39;posmean&#39;, y = &#39;negmean&#39;). \
    plot_joint(sns.kdeplot, zorder=3, n_levels=6) ## add isolines
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-9fcf615aed09e4928c87ae2b4b547b4e.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>kdeplot without data</li>
</ul>

<div class="highlight"><pre><span></span>sns.kdeplot (mydat.posmean, mydat.nomean)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-c31fe9f7c879bc265853bd1dc9039845.png" class="center">

<br>
<br>

<p>
To draw the isolines via colour scale use the shade bool
</p>

<div class="highlight"><pre><span></span>sns.kdeplot (mydat.posmean, mydat.nomean,
	     shade = True)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-2b28d7b239bb2b2c97d91ddec01caab4.png" class="center">

<br>
<br>

<p>
To still see the grids
</p>

<div class="highlight"><pre><span></span>sns.kdeplot (mydat.posmean, mydat.nomean,
	     shade = True, shade_lowest = False)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-9a36b78d9df73e73b323e41e10582027.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>change the background style</li>
</ul>

<div class="highlight"><pre><span></span>sns.set(style=&quot;darkgrid&quot;)
sns.kdeplot (mydat.posmean, mydat.nomean)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-7ff3fea35de715f49145204980aeb263.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>create subplots</li>
</ul>

<div class="highlight"><pre><span></span>## specify your R par(mfrow=c(x,y))
f, axes = plt.subplots(1,2, figsize = (12, 6))
k1 = sns.kdeplot(mydat.posmean, mydat.nomean, ax = axes[0], cmap = &#39;Greens&#39;)
k2 = sns.kdeplot(mydat.posmean, mydat.negmean, ax = axes[1], cmap = &#39;Greens&#39;)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-76f47b1626f35945ac24a2fdb16cd94b.png" class="center">

<br>
<br>

<p>
with more columns the axis index becomes more complex.
</p>

<div class="highlight"><pre><span></span>## specify your R par(mfrow=c(x,y))
f, axes = plt.subplots(2,2, figsize = (12, 6))
k1 = sns.kdeplot(mydat.posmean, mydat.nomean, ax = axes[0,1], cmap = &#39;Greens&#39;)
k2 = sns.kdeplot(mydat.posmean, mydat.negmean, ax = axes[1,0], cmap = &#39;Greens&#39;)
</pre></div>

<img width="60%" height="100%" src="../../images/ob-ein-67a82e7e06d0dbde403da30e12915fb0.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>violinplot</li>
</ul>

<p>
same information as boxplot. on top of it you have the width that
tells you how many datapoints falls into each level for each category
</p>

<div class="highlight"><pre><span></span>k1 = sns.violinplot(data = mydat, x = &#39;bitwise&#39;, y = &#39;nomean&#39;)
</pre></div>

<img width="60%" height="100%" src="../../images/ob-ein-76e27ae206053454189960ae1872c755.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>facet grids</li>
</ul>

<p>
this is useful when plotting many variables and inspecting their
properties for different categories.
</p>

<p>
you might do that as follows
</p>

<div class="highlight"><pre><span></span>## create some more categories
rand = np.random.randn(200)
category = [&#39;2008&#39; if x &gt; 0 else &#39;2009&#39; for x in rand]
mydat[&#39;year&#39;] = pd.Series(category).astype(&#39;category&#39;)
category = [&#39;posExtreme&#39; if x &gt; 2 else &#39;normal&#39; if x &lt; 2 else &#39;negExtreme&#39; for x in rand]
mydat[&#39;extreme&#39;] = pd.Series(category).astype(&#39;category&#39;)

mydat.info()
</pre></div>


<div class="highlight"><pre><span></span>set([&#39;posExtreme&#39; if x &gt; 2 else &#39;normal&#39; if x &lt; -2 else &#39;negExtreme&#39; for x in rand])
</pre></div>


<div class="highlight"><pre><span></span>g =  sns.FacetGrid(data = mydat, row = &#39;year&#39;, col = &#39;extreme&#39;, hue = &#39;year&#39;)
g.map(plt.scatter, x = &#39;nomean&#39;, y = &#39;posmean&#39;)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-0b867ca8bdca2f2900ea9cfed8557013.png" class="center">

<br>
<br>


<ul class="org-ul">
<li>pairs plot</li>
</ul>

<div class="highlight"><pre><span></span>sns.set(style=&quot;ticks&quot;, color_codes=True)

## make a pair plot
columns = [&#39;Happiness_Score&#39;,&#39;Economy_(GDP_per_Capita)&#39;, &#39;Family&#39;, &#39;Health_(Life_Expectancy)&#39;,
	   &#39;Freedom&#39;, &#39;Trust_(Government_Corruption)&#39;]

axes = sns.pairplot(df,vars=columns,hue=&quot;Year&quot;,palette=&quot;husl&quot;)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-3a2a26107ad61803388d9c611a423e28.png" class="center">

<br>
<br>

<ul class="org-ul">
<li>correlation matrix plot</li>
</ul>

<div class="highlight"><pre><span></span># Compute the correlation matrix
corr = df.corr()

# Generate a mask for the upper triangle
mask = np.triu(np.ones_like(corr, dtype=np.bool))

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(220, 10, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,
	    square=True, linewidths=.5, cbar_kws={&quot;shrink&quot;: .5})
</pre></div>


<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-bd9b1dfc192e85b5422d813cc082a59d.png" class="center">

<br>
<br>


<ul class="org-ul">
<li>On PairGrid</li>
</ul>

<p>
This is a very interesting option to compute different visualization
according to pair plots
</p>

<div class="highlight"><pre><span></span>df = pd.read_csv(&quot;~/Desktop/Learning/AI_workflow_Coursera/Visualization/Visualization_2.csv&quot;)

df.columns

df = df.dropna(axis= 0)
</pre></div>


<div class="highlight"><pre><span></span>g = sns.PairGrid(df[[&#39;age&#39;, &#39;num_streams&#39;, &#39;is_subscriber&#39;]], hue = &#39;is_subscriber&#39;)
g = g.map_upper(sns.scatterplot)
g = g.map_lower(sns.kdeplot, colors=&quot;C0&quot;)
g = g.map_diag(sns.kdeplot, lw=2).add_legend()
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-6d0a3dbe8709898e545dbecff8afb91b.png" class="center">

<br>
<br>

<p>
You can then specify pretty much everything that you want on the upper
and lower diagonal matrix entries. Check at this link to <a href="https://seaborn.pydata.org/generated/seaborn.PairGrid.html">get inspiration</a>.
</p>

<p>
You might even combine pyplot and seaborn elements
</p>

<div class="highlight"><pre><span></span>g = sns.PairGrid(df[[&#39;age&#39;, &#39;num_streams&#39;, &#39;is_subscriber&#39;]], hue = &#39;is_subscriber&#39;)
g = g.map_upper(sns.scatterplot, alpha = 0.3)
g = g.map_lower(sns.kdeplot)
g = g.map_diag(plt.hist, lw=2, alpha = 0.2)
</pre></div>

<br>
<br>

<img width="60%" height="100%" src="../../images/ob-ein-6d61b403db2296406af36083af76f80a.png" class="center">

<br>
<br>
</div>
</div>
