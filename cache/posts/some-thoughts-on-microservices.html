<p>
So this post is about the gist of an idea; an important idea.
</p>

<p>
So basically at IBM you got all of that theoretical education about
how to properly structure application, code, distribute etc.
</p>

<p>
The issue there was that by just working in the new way of doing
things you were sometimes missing and not realizing the benefit of
doing things as they were prescribed. And a bit of dark side, is
necessary to put things into context and imporve your style. There,
when working in your projects you mostly had a green field and you
directly started implementing things in cloud-native way. Programming
via microservices and exposing all of the logic via rest-APIs.
</p>

<p>
Now working on a big code base with quite some legacy code you can
even better appreciate the new paradigm shift in IT.
</p>

<p>
I argue in this post, that the benefit of working through
microservices is not simply at the level of deployment, scalability,
availability and all of these dimensions. In contrast, I argue that
one of the biggest benefit an individual has to price in is the
benefit the modular structure of the approach imposes on the
developer.
</p>

<p>
That said it is all about trade-offs and such a migration costs
time. For a team acting under pressure like ours that is not that
trivial. The overhead of system-management will be there as well
outlined in <a href="https://luminousmen.com/post/thoughts-on-microservices">such a post</a>. Maybe step by step&#x2026;, when you write a new
application for some complete new business logic start to decouple it.
</p>

<!-- TEASER_END -->

<div id="outline-container-org7336b46" class="outline-2">
<h2 id="org7336b46">On Modularity as the Key to Success</h2>
<div class="outline-text-2" id="text-org7336b46">
<p>
So my first task was to augment some internal application with some
additional components in order to handle some new necessary business
logic.
</p>

<p>
And there I was exposed to the world of huge Java monoliths.
</p>

<p>
After around 3 weeks working on such monoliths the picture is still
not that clear yet. It is normal given, that these applications were
developed over a span of around two decades. I am managing to code
and embedding the business case into the application. You
know&#x2026; you debug, trial and error and then you eventually reach
your goal.
</p>

<p>
The issue is that for such huge monoliths the general overview of
the application is missing. Documentation is also slim here, which
is surely not helping.
</p>

<p>
The general idea is the following: all of the various applications
we have share some basic libraries that allow the basic
functionalities that you need for structuring your projects. For
instance you will have a set of packages for handling the SQL
connections, data upload, data parsing etc.
</p>

<p>
You refer to them across your projects. The problem is that in such
a way dependencies are not that clear anymore, or at least not easy
to get from the start. The application becomes that big and the
number of dependencies becomes so large that at some point if you
want to find a single functionality and understand how it relates to
the project becomes a nasty task, taking up more time than strictly
necessary. 
</p>

<p>
In contrast to this, consider the case of working with
microservices. There you are forced to think in terms of separate,
individual modules. You are forced to think in terms of
communication across the components of your application. You are
forced, or at least you are suggested to write good documentation,
in the sense of swagger and Co. on how to interact with an API of
yours.
</p>

<p>
Once you are forced to work in such a way you impose a clear logic
on your application and you impose a clear separation of duties
across your application.
</p>

<p>
In such a way you will just have to understand some basic interfaces
instead of having to interact with the low-level functioning of 100k
components of the application.
</p>

<p>
You can make then all of your deployment and infra reasonings and
decide then how you want to go about the management of the
microservices, but you see that simply at the conceptual level of
developing an application that helps as you will have a set of
smaller, more approachable modules, in comparison to a big giant
that might be difficult to steer and demotivating at the start. 
</p>

<p>
Moreover, this is especially important for new-joiners as me. The
level of the team is good. The code base developed large. The
business needs fast-paced, and the risk is that in order to meet
them you will be continously developing in the
debug-trial-debug-error-debug way, expanding the big giant at
infinity to the point that everything will become quite messy to
manage. 
</p>
</div>
</div>
