<style>

img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>


<p>
So basically the idea of object relational mapping is the one of
mapping relational tables to objects.
</p>

<p>
The idea is that a lot of times the application logic is in objects
while the persistency layer is in the relational schema.
</p>

<p>
That translation is annoying and time consuming. Plus it requires a
mind switch to think at the two different levels.
</p>

<p>
The idea of this technology was essentially to develop a framework to
map the relational persistency layer to the ORM paradigm. In such a
way it is possible for the developer to wire his mind into a single
setting - the one of the objects and to properly develop in a pure
object oriented mind.
</p>

<p>
In this sense this is a lot what is happening in the NoSQL space,
especially with the document store and the json communication format
for API.. the underlying driver must is the same&#x2026;. avoid all of that
annoying conversions from one paradigm to the other.
</p>

<p>
So you see; always think in terms of drivers&#x2026; you will anticipate
the future once you focus on the underlying driver and force instead
of on the concept itself.
</p>

<p>
In general much of these notes refer to the <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjbwuWh_eH4AhVDwQIHHW0vC9sQFnoECA8QAQ&amp;url=https://hoclaptrinhdanang.com/downloads/pdf/spring/Java%20Persistence%20with%20Hibernate.pdf&amp;usg=AOvVaw0524Xl7sPIrS85z5EARMyP">following book</a>.
</p>

<p>
Note as well that as always you can debate about everything and you
shuold think when ORM and Hibernate - in the specific case - is a good
candidate and when not. See <a href="https://www.eversql.com/i-followed-hibernate-orm-to-hell-and-came-back-alive-to-tell-about-it/">this dude</a> post in general - also check the
last section. There is interesting referenced material.
</p>

<!-- TEASER_END -->


<div id="outline-container-org38aaf39" class="outline-2">
<h2 id="org38aaf39">Important Concepts leading to ORM</h2>
<div class="outline-text-2" id="text-org38aaf39">
<p>
So this is very important.
</p>

<p>
It must sit in a very important way in your brain.
</p>

<p>
Cause this topic is very hot in the team and it is at least good
that you have an understanding of going into one direction or the
other.
</p>

<p>
So interesting to see is that much of the topics discussed that
follow come from thinking in terms of objects and the respective
shortcoming when going 
</p>
</div>


<div id="outline-container-org2a2acd0" class="outline-3">
<h3 id="org2a2acd0">Problem of Granularity</h3>
<div class="outline-text-3" id="text-org2a2acd0">
<p>
The idea is that in the OOP world you have lots of level of
granularity through which you can create and shape your objects.
</p>

<p>
These are very important as through them you can create very
sophisticated business logic.
</p>

<p>
Now when working with SQL the point is essentially that such
<i>level of granularity is lost</i>.
</p>

<p>
It is generally not a big practice to work with <code>user-defined data
    types</code> in SQL relational DBs. You generally work at two level of
granularity - tables and columns with the SQL standard data
types. 
</p>

<p>
The key now is essentially the following:
</p>

<blockquote>
<p>
Many simple persistence mechanisms fail to recognize this mismatch and
so end up forcing the less flexible representation of SQL products on
the object-oriented model, effectively flattening it.
</p>
</blockquote>
</div>

<div id="outline-container-org552086d" class="outline-4">
<h4 id="org552086d"><span class="todo TODO">TODO</span> the book claims for a solution to the above problem - find it and integrate it here then.</h4>
</div>
</div>


<div id="outline-container-org2fef0a4" class="outline-3">
<h3 id="org2fef0a4">The problem of Subtypes</h3>
<div class="outline-text-3" id="text-org2fef0a4">
<p>
Essentially this is the problem of inheritance and polymorphism
and the fact that there is no way to really express this into a
relational database.
</p>

<p>
This makes everything quite tricky.
</p>

<p>
Essentially it is the following:
</p>


<img src="../../images/Screenshot 2022-07-05 180342.png" class="center">
</div>
</div>


<div id="outline-container-orgbfb94cb" class="outline-3">
<h3 id="orgbfb94cb">The problem of Identity</h3>
<div class="outline-text-3" id="text-orgbfb94cb">
<p>
That is also quite an interesting one.
</p>

<p>
The idea is of a radical difference among the identity principles
in Java and the application side and on the relational DBs.
</p>

<p>
The concept is that in Java you have two different concepts of
identity:
</p>

<ul class="org-ul">
<li>== -&gt; checking by reference</li>

<li>.equals () -&gt; checking by value</li>
</ul>

<p>
While on the DB side you have the idea of checking by primary
key for checking the uniqueness of a record.
</p>

<p>
In this sense, understand as well the following concept that is
related to the concept of identity:
</p>

<img src="../../images/Screenshot 2022-07-06 090604.png" class="center">

<p>
Note that this is very likely related to the idea of not setting
any <code>setters</code> for the primary key columns in Hibernate. This is
the same underlying idea.
</p>

<p>
This is also why you also have an ID for the different tables and
use ultimately that one. It is the way to implement that concept
of <i>surrogate key</i> and this is why Sergio was so focused on it in
his introduction. I did not really get it properly to that stage. 
</p>
</div>
</div>


<div id="outline-container-org6f0140a" class="outline-3">
<h3 id="org6f0140a">The problem of association</h3>
<div class="outline-text-3" id="text-org6f0140a">
<p>
Object-oriented languages represent associations using object
references; but in the relational world, a <i>foreign key</i> –constrained
column represents an association, with copies of key values.
</p>

<p>
The constraint is a rule that guarantees integrity of the
association.  There are <i>substantial differences</i> between the two
mechanisms.
</p>

<p>
Object references are <i>directional</i>. Navigation in a particular
direction has no meaning for a relational data model because you
can create arbitrary data associations with join and projection
operators.
</p>

<p>
The important thing is <b>the following</b> then:
</p>

<blockquote>
<p>
The challenge is to map a completely open data model, which is
independent of the application that works with the data, to an
application-dependent navigational model.
</p>
</blockquote>
</div>
</div>


<div id="outline-container-orgf2bdf7f" class="outline-3">
<h3 id="orgf2bdf7f">The problem of data navigation</h3>
<div class="outline-text-3" id="text-orgf2bdf7f">
<p>
So basically when working with ORM it is important to keep the
thing under control by not overloading the system with very
expensive queries fetching all of the possible data relations
across the object network in the mapped DB world.
</p>

<p>
The idea is the one of leveraging <i>lazy loading</i> as a solution as
discussed a couple of times:
</p>

<blockquote>
<p>
Any object persistence solution worth its salt provides
functionality for fetching the data of associated instances only
when the association is first accessed in Java code.  This is
known as lazy loading: retrieving data on demand only.
</p>
</blockquote>

<p>
Note that this is not a trivial problem. Cause on the other side
you have the following problem:
</p>

<blockquote>
<p>
This piecemeal style of data access is fundamentally inefficient [the
one of lazy loading] in the context of an SQL database, because it
requires executing one statement for each node or collection of the
object network that is accessed. This is the dreaded n+1 selects
problem - i.e. you actually perform too many queries killing the DB.
</p>
</blockquote>

<p>
So essentially you have the difficult problem:
</p>

<ul class="org-ul">
<li>avoid the <b>cartesian product</b> vs.  avoid <b>n+1 select</b> problem.</li>
</ul>

<p>
Not trivial to solve and decide at development time. 
</p>
</div>
</div>
</div>


<div id="outline-container-orgb234b56" class="outline-2">
<h2 id="orgb234b56">On Mapping Strategies</h2>
<div class="outline-text-2" id="text-orgb234b56">
</div>
<div id="outline-container-orgab9da43" class="outline-3">
<h3 id="orgab9da43">On Entity and Value Types</h3>
<div class="outline-text-3" id="text-orgab9da43">
<p>
So one of the most important factors, is the difference between
<b>entities and value types</b>. You have to understand when to map
objects in the first and second way. This is of paramount
importance. 
</p>
</div>

<div id="outline-container-org37b46eb" class="outline-4">
<h4 id="org37b46eb">On Entity Types</h4>
<div class="outline-text-4" id="text-org37b46eb">
<p>
You have to make this difference explicit when you work in the ORM
fashion. The main idea is the following:
</p>

<p>
In the <code>entity type</code> all of the objects of interest reference a
third <b>common</b> object: the <code>entity type</code>, i.e. an object that is
equal in <code>==</code> java terms.
</p>

<img src="../../images/Screenshot 2022-08-09 152726.png" class="center">

<p>
So here the key element that is important to understand is that the
relation in the case of the <code>entity type</code>, i.e. a pointer in the
JVM, is persisted as a reference in the DB, meaning a foreign
key-constrained value.
</p>

<p>
In this sense when the object is of <code>entity type</code> it is not
deleted when one of the object pointing to it is. This is because
of the idea that different object might use it and the idea that
in DB schema behind there are two tables and there is a foreign
key constraint. 
</p>
</div>
</div>


<div id="outline-container-org939ca03" class="outline-4">
<h4 id="org939ca03">On Value Types</h4>
<div class="outline-text-4" id="text-org939ca03">
<p>
Here the idea is that, there are object that do not have to be
persisted as entity instance types as <a href="#org37b46eb">On Entity Types</a>, but rather
<b>belong</b> to an entity type. 
</p>

<p>
In this sense a <code>value type</code> has no persistent identifier
property it is rather bounded to the entity type object it
belongs to. When this is gone, the <code>value type</code> object is deleted
as well.
</p>

<img src="../../images/Screenshot 2022-08-09 160450.png" class="center">
</div>
</div>
</div>


<div id="outline-container-orgcf843b7" class="outline-3">
<h3 id="orgcf843b7">Mapping entities with identities</h3>
<div class="outline-text-3" id="text-orgcf843b7">
<p>
We start now with modeling the <code>entities</code>, in later chapters we go
then to the <code>value types</code>.
</p>

<p>
The idea is that as soon as you have an <code>entity type</code> object you
need an identifier for it.
</p>

<p>
This because such entity types objects will actually form the
basis for the tables to be persisted and they will need to contain
the relevant primary keys.
</p>

<p>
Hibernate as a framework also forces you behind the hood to work
with surrogate keys as discussed. These should stay as such and
should not turn into <i>natural keys</i>. This is important as
experience showed that natural keys cause problems in the long run.
</p>

<p>
In this sense when you create an <code>entity type</code>, you usually
specify an <code>Id</code> property with a corresponding rule for setting
it, say increase it etc. etc.
</p>

<p>
Then once this is set you will never update it, so there will be
<b>no setter</b>, rather just <b>getter</b> on it in order to get the
desired value. 
</p>

<p>
An example for it is the following:
</p>

<img src="../../images/Screenshot 2022-08-10 094104.png" class="center">

<p>
Note now that the following general rules:
</p>

<blockquote>
<p>
if @Id is on a field, the JPA provider will access fields of the class
directly and consider all fields part of the persistent state by
default.
</p>
</blockquote>

<blockquote>
<p>
Hibernate <b>doesn’t support updating primary key</b> values with an API; if
you try to work around this requirement, you’ll run into problems with
Hibernate’s caching and dirty-checking engine. If your database schema
relies on updatable primary keys (and maybe uses ON UPDATE CASCADE
foreign key constraints), you must change the schema before it will
work with Hibernate.
</p>
</blockquote>

<p>
Finally recall that it is important to get this right, as the
general rule is:
</p>

<blockquote>
<p>
Expect your database schema to survive decades, even if your
application won’t.
</p>
</blockquote>
</div>

<div id="outline-container-org857bc72" class="outline-4">
<h4 id="org857bc72">How to generate surrogate keys effectively</h4>
<div class="outline-text-4" id="text-org857bc72">
<p>
The starting point is the following:
</p>

<blockquote>
<p>
The @Id annotation is required to mark the identifier property of an
entity class. Without the @GeneratedValue next to it, the JPA
provider assumes that you’ll take care of creating and assigning an
identifier value before you save an instance.
</p>

<p>
JPA standardizes several value-generation strategies with the
javax.persistence.GenerationType enum, which you select with
@GeneratedValue(strategy = &#x2026;):
</p>
</blockquote>

<p>
Among the options are:
</p>

<ul class="org-ul">
<li><p>
<code>GenerationType.AUTO</code>:
</p>

<p>
Hibernate picks an appropriate strategy, asking the SQL dialect
of your configured database what is best.
</p></li>

<li><p>
<code>GenerationType.SEQUENCE</code>:
</p>

<p>
Sequential numeric values.
</p>

<p>
Note the difference with the next one. I think the difference
lies in the <i>sequence</i>. A sequence can be quite general and
does not have to be the +1 sequence. In fact there are lower
level stuff happening depending on the SQL dialect you are
working with. 
</p></li>

<li><p>
<code>GenerationType.IDENTITY</code>:
</p>

<p>
special auto-incremented primary key column that automatically
generates a numeric value on INSERT.
</p></li>

<li><p>
<code>GenerationType.TABLE</code>:
</p>

<p>
Here you will have an extra table in your DB schema that holds
the numeric primary key value, one row for each entity
class. This table will be read and updated accordingly, before
INSERTs. The default table name is HIBERNATE<sub>SEQUENCES</sub> with
columns SEQUENCE<sub>NAME</sub> and SEQUENCE<sub>NEXT</sub><sub>HI</sub><sub>VALUE</sub>. 
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgcac0724" class="outline-4">
<h4 id="orgcac0724">How to name your tables</h4>
<div class="outline-text-4" id="text-orgcac0724">
<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span><span class="w"> </span>
<span class="w">     </span><span class="nd">@Table</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERS&quot;</span><span class="p">)</span><span class="w"> </span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
Note that by default if you do not specify a name the name is
specified according to the Object the Entity annotation is
bounded to.
</p>

<p>
Note now that the above is a good example, as the User entity
would map to the USER table; this is a reserved keyword in most
SQL DBMSs. You can’t have a table with that name, so you instead
map it to USERS.
</p>

<p>
There are then tricks in order to generally deal with reserved
keywords. Skip it for now. There are as well ways to enforce
naming convetions across your tables names. 
</p>
</div>
</div>


<div id="outline-container-org17e3204" class="outline-4">
<h4 id="org17e3204">Naming Entities for Querying</h4>
<div class="outline-text-4" id="text-org17e3204">
<p>
The idea is that:
</p>

<blockquote>
<p>
all entity names are automatically imported into the namespace of the
query engine.
</p>

<p>
In other words, you can use short class names <b>without a package prefix</b>
in JPA query strings.
</p>
</blockquote>

<p>
Note now that if you have two entity classes named in the <b>same
way</b> in <b>two different packages</b> then you need to rename one of
them for JPA - through the name property as above - if you want
to continue using the short form queries, such as:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="n">List</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>
<span class="w">     </span><span class="c1">// where Item is the shortname and is an Entity in Hibernate</span>
</pre></div>
</div>
</div>


<div id="outline-container-org0a4ec61" class="outline-4">
<h4 id="org0a4ec61">Dynamic SQL generation</h4>
<div class="outline-text-4" id="text-org0a4ec61">
<p>
Here the idea is
</p>

<blockquote>
<p>
By default, Hibernate creates SQL statements for each persistent
class when the persistence unit is created, on startup. These
statements are simple create, read, update, and delete (CRUD)
operations for reading a single row, deleting a row, and so on.
</p>
</blockquote>

<p>
So the idea is that such statements are stored in memory instead
of being generated on the fly. This is computationally cheaper.
</p>

<p>
The tricky bit comes with the <code>UPDATE</code> statements.
</p>

<blockquote>
<p>
After all, the columns to be updated aren’t known at this time. The
answer is that the generated SQL statement updates all columns, and if
the value of a particular column isn’t modified, the statement sets it
to its old value.  In some situations, such as a legacy table with
hundreds of columns where the SQL statements will be large for even
the simplest operations (say, only one column needs updating), you
should disable this startup SQL generation and switch to dynamic
statements generated at runtime.
</p>

<p>
An <b>extremely large number of entities</b> can also impact startup
time, because Hibernate has to generate all SQL statements for
CRUD up front.  Memory consumption for this query statement cache
will also be high if a dozen statements must be cached for
thousands of entities. This can be an issue in virtual
environments with memory limitations, or on low-power devices.
</p>
</blockquote>

<p>
So keep these points in the back of the mind when creating your
Hibernate instances.
</p>

<p>
In order to disable such default behaviour you can use the
following:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span><span class="w"> </span>
<span class="w">     </span><span class="nd">@org.hibernate.annotations.DynamicInsert</span>
<span class="w">     </span><span class="nd">@org.hibernate.annotations.DynamicUpdate</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ... </span>
<span class="w">     </span><span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org704ca19" class="outline-4">
<h4 id="org704ca19">Immutable types</h4>
<div class="outline-text-4" id="text-org704ca19">
<p>
There might be objects which logic is <b>immutable</b>.
</p>

<p>
Think for instance a Bid in an auction. Once it is there, it is
there, you cannot modify it.
</p>

<p>
You can specify this immutable property as follows:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@org.hibernate.annotations.Immutable</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Bid</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
Then you will never be able to execute <code>UPDATE</code> statements on
such table.
</p>
</div>
</div>
</div>


<div id="outline-container-org7a4c404" class="outline-3">
<h3 id="org7a4c404">Mapping Value Types Objects</h3>
<div class="outline-text-3" id="text-org7a4c404">
<p>
Let's start again with the key point; this is fundamental as if
you fail here, you will fail in your DB design.
</p>

<p>
This is the following:
</p>

<blockquote>
<ul class="org-ul">
<li>Entities are the coarser-grained classes of your system. Their
instances have an independent life cycle and their own identity, and
many other instances can reference them.</li>

<li>Value types, on the other hand, are dependent on a particular entity
class. A value type instance is bound to its owning entity instance,
and only one entity instance can reference it; it has no individual
identity</li>
</ul>
</blockquote>

<p>
So that is the big difference that you have to make when working
with objects. Objects that are a property of an entity type,
belong to <code>value types</code>.
</p>

<p>
So, far when talking about <code>value types</code> we made the explicit
connection to embedded objects as discussed above.
</p>

<p>
Note that it is not important if the Object is programmer-defined
or coming from some standard library. Everything embedded within
an Entity Object is a <code>value type</code> Object.
</p>

<p>
So basically, the book starts with the <i>Numeric Objects</i> in the
Java language and other very common data Objects through which you
implement the basics of any program. It shows how these are
converted to SQL data types. You can read this online when needed.
</p>

<p>
More interesting are the following concepts:
</p>
</div>

<div id="outline-container-org2db297d" class="outline-4">
<h4 id="org2db297d"><code>transient</code> keyword</h4>
<div class="outline-text-4" id="text-org2db297d">
<p>
this is used to mark properties of the Object of interest that
should be discarded; meaning not persisted.
</p>

<p>
This will allow you to implement some cool application logic.
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="kd">class</span> <span class="nc">Ob</span><span class="w"> </span><span class="p">{</span>
<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">	 </span><span class="nd">@javax.persistence.Transient</span>
<span class="w">	     </span><span class="n">Integer</span><span class="w"> </span><span class="n">myTransientInteger</span><span class="p">;</span>

<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org223a9f4" class="outline-4">
<h4 id="org223a9f4">non-optional</h4>
<div class="outline-text-4" id="text-org223a9f4">
<p>
When you mark a property with this tag it will be marked as <code>NOT
     NULL</code> in the DB schema.
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="kd">class</span> <span class="nc">Ob</span><span class="w"> </span><span class="p">{</span>
<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">     </span><span class="nd">@Basic</span><span class="p">(</span><span class="n">optional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">     </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">initialPrice</span><span class="p">;</span>

<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
Another option in this sense is to include this in the <code>@Column</code>
property.
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="kd">class</span> <span class="nc">Ob</span><span class="w"> </span><span class="p">{</span>
<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">	 </span><span class="nd">@Column</span><span class="p">(</span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BlaBla&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// so you see. You can as well name the column.</span>
<span class="w">	 </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">initialPrice</span><span class="p">;</span>

<span class="w">	 </span><span class="c1">// Note that Column has as well parameters for controlling the schema and catalog properties.</span>

<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
Finally there is the way of working with <code>@NotNull</code>, this will
make the thing not-nullable through Bean Validation. I.e. at
runtime you will get errors.
</p>

<p>
You will not have the not-null property in your DB schema. So it
depends what you want to do. However, in general it is not
recommended to do any of this.
</p>
</div>
</div>

<div id="outline-container-orga9c4294" class="outline-4">
<h4 id="orga9c4294">On @Embedded classes</h4>
<div class="outline-text-4" id="text-orga9c4294">
<p>
Basically recall that depending on where you set the <code>@Id</code>
property:
</p>

<ul class="org-ul">
<li>either on a field</li>

<li>or on a getter</li>
</ul>

<p>
then this will be the strategy for reading and writing from the
DB.
</p>

<p>
Now <code>@Embedded</code> classes are the actual <code>value types</code> objects you
write.
</p>

<p>
That said, they will inherit the mapping strategy for reading and
writing of the <code>entity types</code> objects they are bounded to.
</p>

<p>
In case you want to override such a strategy you can use the
<code>@Access</code> annotation. This can be both at class level or at
property level within the embedded class.
</p>

<p>
Note that when you embedd a class you are actually augmenting the
relevant table with all of the relevant fields.
</p>

<p>
Note that you might want to override the <code>equals</code> and <code>hashCode</code>
cause you have to start comparing by values and not by reference.
</p>

<p>
An important thing to remember when working in such a way is the
one of overriding embedded attributes. This is important as you
might have for instance two addresses and if you do not override
the respective names you would have conflicts and you could not
work in the same table. 
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="nd">@Table</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERS&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="nd">@Embedded</span>
<span class="w">	  </span><span class="nd">@AttributeOverrides</span><span class="p">({</span>
<span class="w">		  </span><span class="nd">@AttributeOverride</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;street&quot;</span><span class="p">,</span>
<span class="w">				     </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@Column</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BILLING_STREET&quot;</span><span class="p">)),</span>
<span class="w">		      </span><span class="nd">@AttributeOverride</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;zipcode&quot;</span><span class="p">,</span>
<span class="w">					 </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@Column</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BILLING_ZIPCODE&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">)),</span>
<span class="w">		      </span><span class="nd">@AttributeOverride</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;city&quot;</span><span class="p">,</span>
<span class="w">					 </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@Column</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BILLING_CITY&quot;</span><span class="p">))</span>
<span class="w">		      </span><span class="p">})</span>

<span class="w">		      </span><span class="kd">protected</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="n">billingAddress</span><span class="p">;</span><span class="w"> </span>

<span class="w">     </span><span class="c1">// ...</span>

<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
You can then check at the book. You can as well have nested relations.
</p>
</div>
</div>

<div id="outline-container-org54fe997" class="outline-4">
<h4 id="org54fe997">Derived properties</h4>
<div class="outline-text-4" id="text-org54fe997">
<p>
So basically in this way you can apply transformations <b>when
fetching</b> the object from the database.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@org.hibernate.annotations.Formula</span><span class="p">(</span>
<span class="w">       </span><span class="s">&quot;substr(DESCRIPTION, 1, 12) || &#39;...&#39;&quot;</span>
<span class="w">      </span><span class="p">)</span>
<span class="w">      </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">shortDescription</span><span class="p">;</span>
<span class="w">      </span><span class="nd">@org.hibernate.annotations.Formula</span><span class="p">(</span>
<span class="w">       </span><span class="s">&quot;(select avg(b.AMOUNT) from BID b where b.ITEM_ID = ID)&quot;</span>
<span class="w">      </span><span class="p">)</span>
<span class="w">      </span><span class="kd">protected</span><span class="w"> </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">averageBidAmount</span><span class="p">;</span>
</pre></div>

<p>
Note that this is just for reading. <code>ColumnTransformer</code>
described in the next section is both for reading and writing. 
</p>
</div>
</div>

<div id="outline-container-orgf18617b" class="outline-4">
<h4 id="orgf18617b">Transforming column values</h4>
<div class="outline-text-4" id="text-orgf18617b">
<p>
You can apply transformations for reading and writing from/in
the database as follows:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Column</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;IMPERIALWEIGHT&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="nd">@org.hibernate.annotations.ColumnTransformer</span><span class="p">(</span>
<span class="w">       </span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;IMPERIALWEIGHT / 2.20462&quot;</span><span class="p">,</span>
<span class="w">       </span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;? * 2.20462&quot;</span>
<span class="w">      </span><span class="p">)</span>
<span class="w">      </span><span class="kd">protected</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">metricWeight</span><span class="p">;</span>
</pre></div>

<p>
Note that such transformations are as well applied in DB
queries restrictions.
</p>

<p>
Think for instance at the following:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span>
<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i where i.metricWeight = :w&quot;</span><span class="p">)</span>
<span class="w">       </span><span class="p">.</span><span class="na">setParameter</span><span class="p">(</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span>
<span class="w">       </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">      </span><span class="c1">// The actual SQL executed by Hibernate for this query contains the</span>
<span class="w">      </span><span class="c1">// following restriction in the WHERE clause: ...</span>
<span class="w">      </span><span class="n">where</span>
<span class="w">       </span><span class="n">i</span><span class="p">.</span><span class="na">IMPERIALWEIGHT</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.20462</span><span class="o">=?</span>
</pre></div>

<p>
Note that you will not be able to use <b>indices</b> on such queries
restrictions. This because all of the values will have to be
calculated. This will cause in fact a <i>full table scan</i>, because
the values have to be calculated for all rows before evaluating
the restriction.
</p>

<p>
So you see you have pro and cons when working with
Hibernate. There are things you should consider as well. 
</p>
</div>


<ul class="org-ul">
<li><a id="org20f1e73"></a><span class="todo TODO">TODO</span> understand if you can implement this as well with a setter and reader<br />
<div class="outline-text-5" id="text-org20f1e73">
<p>
theoretically you can as well make the transformation there.
</p>

<p>
double check but I think that it is possible and like this you
will decrease the amount of tools that you are actually using. 
</p>
</div>
</li>
</ul>
</div>



<div id="outline-container-orgae81247" class="outline-4">
<h4 id="orgae81247">Generating Values</h4>
<div class="outline-text-4" id="text-orgae81247">
<p>
With this tag you can Hibernate can automatically generate the
values for the fields when interacting with the Database.
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Temporal</span><span class="p">(</span><span class="n">TemporalType</span><span class="p">.</span><span class="na">TIMESTAMP</span><span class="p">)</span>
<span class="w">     </span><span class="nd">@Column</span><span class="p">(</span><span class="n">insertable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">updatable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// note both false, meaning just the DB can generate them. User cannot.</span>
<span class="w">     </span><span class="nd">@org.hibernate.annotations.Generated</span><span class="p">(</span>
<span class="w">					  </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">annotations</span><span class="p">.</span><span class="na">GenerationTime</span><span class="p">.</span><span class="na">ALWAYS</span>
<span class="w">					  </span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">Date</span><span class="w"> </span><span class="n">lastModified</span><span class="p">;</span>
<span class="w">     </span><span class="nd">@Column</span><span class="p">(</span><span class="n">insertable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">     </span><span class="nd">@org.hibernate.annotations.ColumnDefault</span><span class="p">(</span><span class="s">&quot;1.00&quot;</span><span class="p">)</span>
<span class="w">	 </span><span class="nd">@org.hibernate.annotations.Generated</span><span class="p">(</span>
<span class="w">					      </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">annotations</span><span class="p">.</span><span class="na">GenerationTime</span><span class="p">.</span><span class="na">INSERT</span>
<span class="w">					      </span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">initialPrice</span><span class="p">;</span>
</pre></div>

<p>
This is convenient for instance for generating timestamps for the
insertion into the DB.
</p>

<p>
Note the following:
</p>

<blockquote>
<p>
With ALWAYS, Hibernate refreshes the entity instance after every
SQL UPDATE or INSERT
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org2086b5c" class="outline-4">
<h4 id="org2086b5c">Enumerator</h4>
<div class="outline-text-4" id="text-org2086b5c">
<p>
Note that this is important when working with Enumerators
Objects.
</p>

<p>
If you wod not work with this property then you will save the
ordinal position of the value of within the enumerator.
</p>

<p>
In order to perform transactions with the enumerator label you
should use the <code>EnumType.STRING</code> option.
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@NotNull</span>
<span class="w">     </span><span class="nd">@Enumerated</span><span class="p">(</span><span class="n">EnumType</span><span class="p">.</span><span class="na">STRING</span><span class="p">)</span>
<span class="w">     </span><span class="kd">protected</span><span class="w"> </span><span class="n">AuctionType</span><span class="w"> </span><span class="n">auctionType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AuctionType</span><span class="p">.</span><span class="na">HIGHEST_BID</span><span class="p">;</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgac3d053" class="outline-4">
<h4 id="orgac3d053">String</h4>
<div class="outline-text-4" id="text-orgac3d053">
<p>
Note that Strings are mapped ot VARCHAR(255) by default. If you
do not want this default but rather a different value you have to
set it in the <code>length</code> paramter.
</p>
</div>
</div>
</div>


<div id="outline-container-org64ba3cd" class="outline-3">
<h3 id="org64ba3cd">Excurs Directionality in ORM</h3>
<div class="outline-text-3" id="text-org64ba3cd">
<p>
This is an important point when designing your DBs.
</p>

<p>
In order to understand well this concept an excurs in terms of
<code>unidirectionality</code> and <code>bidirectionality</code> is needed.
</p>

<p>
This is of paramount importance to think when designing and
mapping your databse.
</p>

<ul class="org-ul">
<li><p>
<code>unidirectionality</code>:
</p>

<p>
A unidirectional relationship has only an owning side.
</p>

<p>
The <b>owning side</b> of a relationship <b>determines how the
Persistence runtime makes updates</b> to the relationship in the
database.
</p>

<p>
In this sense it is important to understand that:
</p>

<blockquote>
<p>
In a unidirectional relationship, <b>only one entity</b> has a
relationship field or property that <b>refers to the other</b>.
</p>
</blockquote>

<p>
We encountered such a case multiple times already before - get
it well into your head:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="nd">@Table</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERS&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">LAZY</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="n">defaultBilling</span><span class="p">;</span>
<span class="w">	  </span><span class="c1">// ...</span>

<span class="w">      </span><span class="p">}</span>
</pre></div>

<p>
Here many users can have a single billing. The User Entity has
then the <code>DEFAULTBILLING_ID</code> attribute representing the
relationship. So you see Users is aware of the relationship -
it <b>ownes it</b>.
</p>

<p>
This means for instance that if you withdraw the user you would
automatically withdraw as well the the CreditCard.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">User</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">USER_ID</span><span class="p">);</span>

<span class="w">      </span><span class="n">user</span><span class="p">.</span><span class="na">getDefaultBilling</span><span class="p">().</span><span class="na">pay</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</pre></div>

<p>
Note that the directionality is important as it also gives the
order of the Objects that must be saved. I.e. for instance in
the example above billingdetails must exist in order to create a
User - if for instance that property is not-null, i.e. the
parent is mandatory.
</p></li>
</ul>


<ul class="org-ul">
<li><p>
<code>bidirectionality</code>:
</p>

<p>
In the bidirectional case, <b>each entity has a relationship field</b>
or property that <b>refers to the other entity</b>.
</p>

<p>
In this sense you see that there is a kind of circular
relation. The one and the other are highly dependent. You
cannot treat them as two splitted concepts anymore.
</p>

<p>
Understand the following though - there is still an <b>owning
side</b>.
</p>

<ul class="org-ul">
<li><p>
The inverse side of a bidirectional relationship <b>must refer
to its owning side</b> by using the mappedBy element of the
@OneToOne, @OneToMany, or @ManyToMany annotation.
</p>

<p>
The mappedBy element designates the property or field in the
entity that is the owner of the relationship.
</p></li>

<li>The <b>many side</b> of many-to-one bidirectional relationships <b>must
not define the mappedBy element</b>. The <b>many side is always the
owning side</b> of the relationship.</li>

<li>For one-to-one bidirectional relationships, the <b>owning side</b>
corresponds <b>to the side that contains the corresponding
foreign key</b>.</li>

<li>For <b>many-to-many</b> bidirectional relationships, <b>either side may
be the owning side</b>.</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org374f9ff" class="outline-3">
<h3 id="org374f9ff">Mapping Inheritance</h3>
<div class="outline-text-3" id="text-org374f9ff">
<p>
This is an important concept as here is where things get
tricky.
</p>

<p>
The tricky business is always the same, you start to have OOP
concepts such as polymorphism and the way you map such OOP
characterstics into your relational tables is a non-trivial task
that requires a bit of thinking.
</p>

<p>
Essentially you have 4 possibilties, depending on the structure of
your application logic you might want to go for the one or the
other.
</p>

<p>
We will explore them further next, before let's quickly dive in
the concepts of <code>polymorphic associations</code> and <code>polymorphic
    queries</code>. These are essential cause you have to think what you get
from working in one way or the other.
</p>
</div>

<div id="outline-container-org7149962" class="outline-4">
<h4 id="org7149962">Polymorphic Associations</h4>
<div class="outline-text-4" id="text-org7149962">
<p>
So here the idea is the following:
</p>

<blockquote>
<p>
A polymorphic association consists on two (or more) associations
happening with the same foreign key.
</p>
</blockquote>

<p>
Such that if <code>polymorphic_association = true</code> you essentially
have repsected the superclass-subclass relations in your DB.
</p>

<p>
You would essentially have a table mapping to the superclass and
then it is clear that if you have different tables for your
subclasses that will reference the superclass via the foreign key
you would have a polymorphic association and with the key of the
superclass you will be able to fetch all of the relevant
associations in the subclasses.
</p>

<p>
You will see that depending on the mapping strategy this is not
always achieved and you should consider if it is fine to you or
not. 
</p>
</div>
</div>


<div id="outline-container-org1db0c50" class="outline-4">
<h4 id="org1db0c50">Polymorphic Queries</h4>
<div class="outline-text-4" id="text-org1db0c50">
<p>
Think again in terms of OOP.
</p>

<p>
The idea when working with ORM is the concept of working always
with Objects when working in the relational space.
</p>

<p>
In JPA you have as well ways to query your data and fetch the
relevant information through APIs built around Objects mapped to
the relational space.
</p>

<p>
The idea of polymorphic queries is the following then:
</p>

<blockquote>
<p>
The <b>from</b> clause of a query includes not only instances of the
specific entity class to which it refers, but all subclasses of that
class as well. The instances returned by a query include instances of
the subclasses that satisfy the query conditions.
</p>
</blockquote>
</div>
</div>


<div id="outline-container-orgce65e71" class="outline-4">
<h4 id="orgce65e71">General set up for the following exercise</h4>
<div class="outline-text-4" id="text-orgce65e71">
<p>
Note that in the following we will discuss mapping strategies for
the BillingDetails and its subclasses.
</p>

<p>
The general set up for it is the following:
</p>

<img src="../../images/Screenshot 2022-08-17 113654.png" class="center">
</div>
</div>


<div id="outline-container-orgf93def6" class="outline-4">
<h4 id="orgf93def6">One table per concrete class with implicit polymorphism</h4>
<div class="outline-text-4" id="text-orgf93def6">
<p>
So this is the first possibility.
</p>

<p>
Note that the name given in the book is not that intuitive for
the concept behind it.
</p>

<p>
What you are actually doing here according to my opinion is
ultimately <i>breaking the polymorphism</i>. You actually see it by
the fact that in this mapping strategy you actually do not have
<i>polymorphic associations</i> and the possibility of performing
<i>polymorphic queries</i>.
</p>

<p>
The conceptual idea in this kind of mapping is the following:
</p>

<img src="../../images/Screenshot 2022-08-17 112758.png" class="center">

<p>
So you see that there is no table for the superclass but rather
its properties are persisted within the respective two tables
mapping to the subclasses.
</p>

<p>
You actually implement the above in the following way:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@MappedSuperclass</span><span class="w"> </span><span class="c1">// IMPORTANT; include this in the superclass</span>
<span class="w">		       </span><span class="c1">// otherwise the properties of the superclass will</span>
<span class="w">		       </span><span class="c1">// not be PERSISTED to the subclasses-entity models</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BillingDetails</span><span class="w"> </span><span class="p">{</span>
<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="c1">// Subclass table, extending superclass and being mapped through the</span>
<span class="w">     </span><span class="c1">// Entity tag.</span>
<span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@AttributeOverride</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;owner&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// need to change name otherwise</span>
<span class="w">					 </span><span class="c1">// possible conflicts when</span>
<span class="w">					 </span><span class="c1">// evolving your schema</span>
<span class="w">			</span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@Column</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CC_OWNER&quot;</span><span class="p">,</span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CreditCard</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="p">{</span>
<span class="w">	 </span><span class="nd">@Id</span>
<span class="w">	 </span><span class="nd">@GeneratedValue</span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Constants</span><span class="p">.</span><span class="na">ID_GENERATOR</span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">cardNumber</span><span class="p">;</span>
<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expMonth</span><span class="p">;</span>
<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expYear</span><span class="p">;</span>
<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>


<p>
Let's reason now around:
</p>

<ul class="org-ul">
<li><p>
polymorphic associations:
</p>

<p>
So it is clear that here there is no polymorphic
association. All subclasses are mapped to different tables such
that there might not be an association to their superclass that
can be represented by a single foreign key relation.
</p></li>

<li><p>
polymorphic queries:
</p>

<p>
note that this is also not possible.
</p>

<p>
If you want to query upon the field of the superclass, here the
owner property you should make <b>multiple</b> queries - one for
each concrete subclass.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org2a8d017" class="outline-4">
<h4 id="org2a8d017">One table per concrete class with unions</h4>
<div class="outline-text-4" id="text-org2a8d017">
<p>
So here the essential idea is to have at the relational level the
same schema as above.
</p>

<p>
The difference lies in the fact that in order to apply your
polymorphic operations at the superclass level you do not have to
make separate queries, fetch the results and merge them at
runtime in your java application as in the previous case.
</p>

<p>
You can rather apply directly <b>ploymorphic queries</b> and let your
database optimizer actually find the best execution plan.
</p>

<p>
In order to work in such a way you can use the following:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="c1">// Note here the entity tag and the inheritancetype TABLE_PER_CLASS.</span>
<span class="w">     </span><span class="c1">// Note as well that actually no table for the superclass is</span>
<span class="w">     </span><span class="c1">// created. As mentioned the schema is the same as in the previous</span>
<span class="w">     </span><span class="c1">// section.</span>
<span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@Inheritance</span><span class="p">(</span><span class="n">strategy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InheritanceType</span><span class="p">.</span><span class="na">TABLE_PER_CLASS</span><span class="p">)</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="nd">@Id</span>
<span class="w">	 </span><span class="nd">@GeneratedValue</span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Constants</span><span class="p">.</span><span class="na">ID_GENERATOR</span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">	 </span><span class="nd">@NotNull</span>

<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">     </span><span class="p">}</span>
</pre></div>


<p>
The subclasses would then look as usual. Simply extending the
superclass above.
</p>

<p>
As mentioned this would allow polymorphic queries; such that
writing queries as:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="k">select</span><span class="w"> </span><span class="n">bd</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="n">bd</span>

<span class="w">     </span><span class="c1">---- would be translated by the Hibernate engine behind the scenes into:</span>

<span class="w">     </span><span class="k">select</span>
<span class="w">     </span><span class="n">ID</span><span class="p">,</span><span class="w"> </span><span class="k">OWNER</span><span class="p">,</span><span class="w"> </span><span class="n">EXPMONTH</span><span class="p">,</span><span class="w"> </span><span class="n">EXPYEAR</span><span class="p">,</span><span class="w"> </span><span class="n">CARDNUMBER</span><span class="p">,</span>
<span class="w">     </span><span class="n">ACCOUNT</span><span class="p">,</span><span class="w"> </span><span class="n">BANKNAME</span><span class="p">,</span><span class="w"> </span><span class="n">SWIFT</span><span class="p">,</span><span class="w"> </span><span class="n">CLAZZ_</span>
<span class="w">     </span><span class="k">from</span>
<span class="w">     </span><span class="p">(</span><span class="w"> </span><span class="k">select</span>
<span class="w">     </span><span class="n">ID</span><span class="p">,</span><span class="w"> </span><span class="k">OWNER</span><span class="p">,</span><span class="w"> </span><span class="n">EXPMONTH</span><span class="p">,</span><span class="w"> </span><span class="n">EXPYEAR</span><span class="p">,</span><span class="w"> </span><span class="n">CARDNUMBER</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">ACCOUNT</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">BANKNAME</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">SWIFT</span><span class="p">,</span>
<span class="w">     </span><span class="mi">1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">CLAZZ_</span><span class="w">           </span><span class="c1">-- note this that classifies which table the results come from</span>
<span class="w">     </span><span class="k">from</span>
<span class="w">     </span><span class="n">CREDITCARD</span>
<span class="w">     </span><span class="k">union</span><span class="w"> </span><span class="k">all</span>
<span class="w">     </span><span class="k">select</span>
<span class="w">     </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">OWNER</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">EXPMONTH</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">EXPYEAR</span><span class="p">,</span>
<span class="w">     </span><span class="k">null</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">CARDNUMBER</span><span class="p">,</span>
<span class="w">     </span><span class="n">ACCOUNT</span><span class="p">,</span><span class="w"> </span><span class="n">BANKNAME</span><span class="p">,</span><span class="w"> </span><span class="n">SWIFT</span><span class="p">,</span>
<span class="w">     </span><span class="mi">2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">CLAZZ_</span><span class="w">           </span><span class="c1">-- note this that classifies which table the results come from</span>
<span class="w">     </span><span class="k">from</span>
<span class="w">     </span><span class="n">BANKACCOUNT</span>
<span class="w">     </span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">BILLINGDETAILS</span>
</pre></div>
</div>
</div>


<div id="outline-container-org4ee69db" class="outline-4">
<h4 id="org4ee69db">One table per class hierarchy</h4>
<div class="outline-text-4" id="text-org4ee69db">
<p>
Here the mapping strategy would result in the following:
</p>

<img src="../../images/Screenshot 2022-08-17 143159.png" class="center">

<p>
So essentially here the idea is the following:
</p>

<blockquote>
<p>
You can map an entire class hierarchy <i>to a single table</i>. This table
includes columns for all properties of all classes in the
hierarchy.
</p>

<p>
The value of an extra type <b>discriminator column</b> or formula identifies
the concrete subclass represented.
</p>
</blockquote>

<p>
Understand now the merits and drawbacks:
</p>

<ul class="org-ul">
<li><p>
On the good side.
</p>

<blockquote>
<p>
This mapping strategy is a winner in terms of both performance and
simplicity.
</p>

<p>
It’s the best-performing way to represent polymorphism—both
polymorphic and non-polymorphic queries perform well—and it’s even
easy to write queries by hand.
</p>

<p>
Ad hoc reporting is possible without complex joins or unions. Schema
evolution is straightforward.
</p>
</blockquote>

<p>
Note that polymorphic queries are straightforward as in the
specific case the <code>owner</code> is just a field. It is
straightforward to apply <code>selection</code> and get all of the desired
results of, among the others, the subclasses.
</p></li>

<li><p>
Issues:
</p>

<blockquote>
<p>
There is <b>first major issue</b>: data integrity.
</p>

<p>
You must declare columns for properties declared by subclasses
to be nullable. If your subclasses each define several
non-nullable properties, the loss of NOT NULL constraints may
be a serious problem from the point of view of data
correctness.
</p>

<p>
Imagine that an expiration date for credit cards is required,
but your database schema can’t enforce this rule because all
columns of the table can be NULL. A simple application
programming error can lead to invalid data.
</p>

<p>
There is <b>second major issue</b>: normalization.
</p>

<p>
You’ve created <b>functional dependencies</b> between non-key
columns, <b>violating the third normal form</b>.
</p>

<p>
As always, denormalization for performance reasons can be
misleading, because it sacrifices <b>long-term stability</b>,
<b>maintainability</b>, and the <b>integrity of data</b>.
</p>

<p>
This is important as well. Before starting to design your DB
you should properly think about what normal form you want to
reach such that you will make sure that in the long run
maintainability will not be a major concern.
</p>
</blockquote>

<p>
Should you want to go for this mapping strategy you can
implement it in Hibernate as follows:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="nd">@Inheritance</span><span class="p">(</span><span class="n">strategy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InheritanceType</span><span class="p">.</span><span class="na">SINGLE_TABLE</span><span class="p">)</span><span class="w"> </span><span class="c1">// on the root class.</span>
<span class="w">       </span><span class="nd">@DiscriminatorColumn</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BD_TYPE&quot;</span><span class="p">)</span><span class="w">                </span><span class="c1">// this is a</span>
<span class="w">       </span><span class="c1">// discriminator</span>
<span class="w">       </span><span class="c1">// column</span>
<span class="w">       </span><span class="c1">// distinguishing</span>
<span class="w">       </span><span class="c1">// among the</span>
<span class="w">       </span><span class="c1">// subclasses</span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	   </span><span class="nd">@Id</span>
<span class="w">	   </span><span class="nd">@GeneratedValue</span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Constants</span><span class="p">.</span><span class="na">ID_GENERATOR</span><span class="p">)</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>

<span class="w">	   </span><span class="nd">@NotNull</span>
<span class="w">	   </span><span class="nd">@Column</span><span class="p">(</span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">}</span>

<span class="w">       </span><span class="c1">// Example of subclass - see the discriminator value that you set</span>
<span class="w">       </span><span class="c1">// here.</span>
<span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="nd">@DiscriminatorValue</span><span class="p">(</span><span class="s">&quot;CC&quot;</span><span class="p">)</span><span class="w"> </span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CreditCard</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	   </span><span class="nd">@NotNull</span><span class="w">                        </span><span class="c1">// Hibernate ignores the @NotNull</span>
<span class="w">					   </span><span class="c1">// for schema DDL generation, but</span>
<span class="w">					   </span><span class="c1">// it observes it at runtime</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">cardNumber</span><span class="p">;</span>

<span class="w">	   </span><span class="nd">@NotNull</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expMonth</span><span class="p">;</span>

<span class="w">	   </span><span class="nd">@NotNull</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expYear</span><span class="p">;</span>

<span class="w">	   </span><span class="c1">// ...</span>

<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
A final point that is worth to mention is the following:
</p>

<blockquote>
<p>
Sometimes, especially in legacy schemas, you don’t have the freedom to
include an extra discriminator column in your entity tables. In this
case, you can apply an expression <b>to calculate</b> a discriminator value
for each row.
</p>
</blockquote>

<p>
You can do that in the following way:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="c1">// on the superclass</span>
<span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="nd">@Inheritance</span><span class="p">(</span><span class="n">strategy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InheritanceType</span><span class="p">.</span><span class="na">SINGLE_TABLE</span><span class="p">)</span>
<span class="w">       </span><span class="nd">@org.hibernate.annotations.DiscriminatorFormula</span><span class="p">(</span>
<span class="w">						       </span><span class="s">&quot;case when CARDNUMBER is not null then &#39;CC&#39; else &#39;BA&#39; end&quot;</span>
<span class="w">						       </span><span class="p">)</span>

<span class="w">	   </span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	       </span><span class="c1">// ...</span>

<span class="w">	   </span><span class="p">}</span>
</pre></div></li>
</ul>
</div>
</div>


<div id="outline-container-org4dae607" class="outline-4">
<h4 id="org4dae607">One table per subclass</h4>
<div class="outline-text-4" id="text-org4dae607">
<p>
This is actually the most straightforward way.
</p>

<p>
The concept is that you keep all the OOP hierarchy as is and you
leverage foreign keys constraints in your relational schema that
would ultimately enforce the OOP hierachy logic.
</p>

<img src="../../images/Screenshot 2022-08-17 160331.png" class="center">

<p>
If you persist on a subclass object, Hibernate inserts two
rows. The values of properties declared by the superclass are
stored in a new row of the <i>BILLINGDETAILS</i> table. Only the
values of properties declared by the subclass are stored in a new
row of the <i>CREDITCARD</i> table.
</p>

<p>
The primary advantage of this strategy is that it <b>normalizes</b> the
SQL schema.  Schema evolution and integrity-constraint
definition are straightforward.
</p>

<p>
Note that performace can become slow with this relational schema
design. This due to the multiple join across many tables. 
</p>

<p>
This is good as with it you can reach the normal form you desire
and this should guarantee the needed consistency in the long
run. 
</p>

<p>
In order to implement this mapping strategy in Hibernate you
should work as follows:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@Inheritance</span><span class="p">(</span><span class="n">strategy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InheritanceType</span><span class="p">.</span><span class="na">JOINED</span><span class="p">)</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="nd">@Id</span>
<span class="w">	 </span><span class="nd">@GeneratedValue</span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Constants</span><span class="p">.</span><span class="na">ID_GENERATOR</span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>

<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>

<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="c1">// Subclass</span>
<span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@PrimaryKeyJoinColumn</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD_ID&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// specify PFK to join</span>
<span class="w">						   </span><span class="c1">// on. If you do not</span>
<span class="w">						   </span><span class="c1">// specify anything it</span>
<span class="w">						   </span><span class="c1">// will be called ID.</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CreditCard</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">cardNumber</span><span class="p">;</span>

<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expMonth</span><span class="p">;</span>

<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expYear</span><span class="p">;</span>

<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
A <b>polymorphic query</b> would then be implemented via an outer
join.
</p>

<p>
If you see the joins - think about the situation in the
applications you are working on, then you see that this mapping
strategy is more difficult to implement by hand — even ad hoc
reporting is more complex. This is an important consideration if
you plan to mix Hibernate code with <i>handwritten SQL</i> - which
will for sure be the case in the case of legacy applications as
ours.
</p>
</div>
</div>


<div id="outline-container-org2be3963" class="outline-4">
<h4 id="org2be3963">On mixing mapping strategies</h4>
<div class="outline-text-4" id="text-org2be3963">
<p>
It is possible to mix among the mapping strategies discussed
above.
</p>

<p>
This for instance to get around some downsides of a mapping
strategy; say for instance go from a table per subclass - with
union - to a normalized table-per-subclass strategy. 
</p>

<p>
Or for instance, you could have a single table with a particular
subclass in a separate table with a foreign key relation - such
that the <i>not null</i> restriction of the single table does not have
to be. For instance:
</p>

<img src="../../images/Screenshot 2022-08-18 085954.png" class="center">

<p>
You can achieve the above by:
</p>

<ul class="org-ul">
<li>using the <code>InheritanceType.SINGLE_TABLE</code> in the superclass</li>

<li>use the following annotation in the relevant subclass that you
do not want to include in the single table</li>
</ul>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="nd">@DiscriminatorValue</span><span class="p">(</span><span class="s">&quot;CC&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// as in single table strategy</span>
<span class="w">     </span><span class="nd">@SecondaryTable</span><span class="p">(</span><span class="w">           </span><span class="c1">// here you specify a secondary table where</span>
<span class="w">				</span><span class="c1">// this object should be persisted</span>
<span class="w">		     </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD&quot;</span><span class="p">,</span>
<span class="w">		     </span><span class="n">pkJoinColumns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@PrimaryKeyJoinColumn</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD_ID&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// PFK</span>
<span class="w">		     </span><span class="p">)</span>

<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CreditCard</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BillingDetails</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="nd">@NotNull</span>
<span class="w">	 </span><span class="nd">@Column</span><span class="p">(</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// here you</span>
<span class="w">							 </span><span class="c1">// specify the</span>
<span class="w">							 </span><span class="c1">// table where to</span>
<span class="w">							 </span><span class="c1">// persiste the</span>
<span class="w">							 </span><span class="c1">// property</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">cardNumber</span><span class="p">;</span>

<span class="w">	 </span><span class="nd">@Column</span><span class="p">(</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expMonth</span><span class="p">;</span>

<span class="w">	 </span><span class="nd">@Column</span><span class="p">(</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;CREDITCARD&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">expYear</span><span class="p">;</span>
<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org02c90c5" class="outline-4">
<h4 id="org02c90c5">Choosing a Mapping strategy</h4>
<div class="outline-text-4" id="text-org02c90c5">
<p>
Here are some general guidelines from the book - quite intuitive
if you know the couple of principles behind it:
</p>

<ul class="org-ul">
<li><p>
If you don’t require polymorphic associations or queries, lean
toward table-per-concrete class.
</p>

<p>
Here always go with the explicit UNION-based mapping with
<code>InheritanceType.TABLE_PER_CLASS</code> should be preferred, because
(optimized) polymorphic queries and associations will then be
possible later.
</p>

<p>
Probably this will never be the case, otherwise you will not
use such OOP structure in the first place.
</p></li>

<li><p>
If you do require polymorphic associations or queries, and
subclasses declare relatively few properties lean toward
<code>InheritanceType.SINGLE_TABLE</code>.
</p>

<p>
This especially so if the main difference among subclasses is
their behaviour rather than their fields.
</p>

<p>
Here the main point is to convince yourself that <b>denormalized
schema</b> will not create any issues in the long run.
</p></li>

<li>If you do require polymorphic associations or queries, and
subclasses declare many <b>(non-optional)</b> properties lean toward
<code>InheritanceType.JOINED</code>.</li>
</ul>
</div>
</div>


<div id="outline-container-org4949133" class="outline-4">
<h4 id="org4949133">On the order in which to think the ORM</h4>
<div class="outline-text-4" id="text-org4949133">
<p>
Another open point that I am noting while writing is the
following: so far it is not clear if you should first think your
application in terms of Objects and then decide how to map it
into the DB or vice versa.
</p>

<p>
You will see this with the experice. It looks to me as if the
whole point of using such framework is as well a little bit to
think first in terms of objects, then decide for a proper mapping
strategy but then once this is done, you can as well forget the
DB and work again at application layer.
</p>
</div>
</div>


<div id="outline-container-org4bf7225" class="outline-4">
<h4 id="org4bf7225">On Polymorphic Associations</h4>
<div class="outline-text-4" id="text-org4bf7225">
<p>
In order to properly understand how to deal with polymorphic
associations think about the following:
</p>

<img src="../../images/Screenshot 2022-11-10 161703.png" class="center">

<p>
Note that the above is polymorphic by subtype. Note as well the
<code>defaultBillingDetails</code> association.
</p>
</div>


<ul class="org-ul">
<li><a id="orgcd5add6"></a>Many To One - As described in the picture above<br />
<div class="outline-text-5" id="text-orgcd5add6">
<p>
In order to implement this into Hibernate you would use the
following mapping:
</p>

<img src="../../images/Screenshot 2022-11-10 165006.png" class="center">

<p>
You can then work with it as follows:
</p>

<img src="../../images/Screenshot 2022-11-10 165547.png" class="center">

<img src="../../images/Screenshot 2022-11-10 165727.png" class="center">
</div>
</li>

<li><a id="org461a5e3"></a>One to Many - Opposite of the Above<br />
<div class="outline-text-5" id="text-org461a5e3">
<img src="../../images/Screenshot 2022-11-10 165936.png" class="center">
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgb6c9180" class="outline-3">
<h3 id="orgb6c9180"><span class="todo TODO">TODO</span> Mapping Collections</h3>
<div class="outline-text-3" id="text-orgb6c9180">
<p>
I skip it for the moment.
</p>

<p>
The idea is that when you read the relevant chapter you will find
that there are multiple ways in order to map collections to
relational tables.
</p>

<p>
Once you work in such a way you can operate on different Objects
implementing the Serializable interface in a very quick and speedy
way.
</p>

<p>
In the meantime you can work simply through the usage of various
plain queries. 
</p>
</div>
</div>


<div id="outline-container-org60eccb0" class="outline-3">
<h3 id="org60eccb0">@OneToMany, @ManyToMany</h3>
<div class="outline-text-3" id="text-org60eccb0">
<p>
This continues the discussions of before.
</p>

<p>
It finishes the types of relations you may encounter in your DB.
</p>

<p>
Once you understand all of these options, the exercise will simply
be the one of putting the pieces together and take it from there.
</p>

<p>
This section continues the discussions on the different
polymorphic associations we encountered before. It also leverages
on the understanding mentioned in <a href="#org64ba3cd">Excurs Directionality in ORM</a>.
</p>
</div>


<div id="outline-container-org8d9b853" class="outline-4">
<h4 id="org8d9b853">@OneToMany</h4>
<div class="outline-text-4" id="text-org8d9b853">
<p>
This is used in order to impose the relevant parent-child
relations to your DBs.
</p>

<blockquote>
<p>
The term <b>parent/child</b> implies some kind of <b>life cycle
dependency</b>, so a collection of strings or embeddable components
is appropriate.
</p>

<p>
The children are <i>fully dependent on the parent</i>; they will be
saved, updated, and removed always with the parent, never alone.
</p>
</blockquote>

<p>
So understand now the following:
</p>

<blockquote>
<p>
@ManyToOne maps <b>associations</b> among entities. With it there is
not the full parent-child relation in action.
</p>
</blockquote>

<p>
I.e. with this you just have implemented a unidirectional link -
from the side owning the <code>@ManyToOne</code> attribute to the other.
</p>

<p>
In order to create a full parent child relation you should
express a <b>bidirectional link</b>.
</p>

<p>
An example would be the following:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Bid</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="c1">// NOTE from the previous discussion, this is the owner of the</span>
<span class="w">	 </span><span class="c1">// relation. Has the many side.</span>
<span class="w">	 </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">LAZY</span><span class="p">)</span>
<span class="w">	 </span><span class="nd">@JoinColumn</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ITEM_ID&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nullable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">	 </span><span class="kd">protected</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">	 </span><span class="c1">// ...</span>
<span class="w">     </span><span class="p">}</span><span class="w">     </span>

<span class="w">     </span><span class="nd">@Entity</span>
<span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>

<span class="w">	 </span><span class="c1">// The inverse side of the relation with mappedBy      </span>
<span class="w">	 </span><span class="nd">@OneToMany</span><span class="p">(</span><span class="n">mappedBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;item&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// object with the ManyToOne</span>
<span class="w">				       </span><span class="c1">// annoation above</span>
<span class="w">		    </span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">LAZY</span><span class="p">)</span>
<span class="w">		    </span><span class="kd">protected</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	 </span><span class="c1">// ...</span>

<span class="w">     </span><span class="p">}</span>
</pre></div>

<p>
I.e. with it you can navigate all of the bids from the item
table. You can as well cascade all of the changes from the item
to the bids with such link in place. So you see that the primary
benefit of a one-to-many mapping is <b>navigational access to
data</b>.
</p>

<p>
Note as well the following:
</p>

<p>
Ask yourself if any table in the schema will have a BID<sub>ID</sub>
foreign key column. If not, map the Bid class as @Embeddable,
not @Entity. Meaning you can work in that way highly decreasing
the overload of having to mantain the general bidirectional link
with all of the corresponding joins.
</p>

<p>
Finally note that with this bidirectional association you would
get the following:
</p>

<img src="../../images/Screenshot 2022-12-07 094758.png" class="center">
</div>
</div>


<div id="outline-container-org77b01c9" class="outline-4">
<h4 id="org77b01c9"><span class="todo TODO">TODO</span> @OneToOne</h4>
</div>

<div id="outline-container-orgd9c09d3" class="outline-4">
<h4 id="orgd9c09d3">IN-PROGRESS @ManyToMany</h4>
<div class="outline-text-4" id="text-orgd9c09d3">
<p>
This is the concept of a <b>link table</b>. It is the M:N relationships
you often encounter when talking about DBs.
</p>

<img src="../../images/Screenshot 2022-12-07 095341.png" class="center">

<p>
So you see that in the link table the primary key is composed of
both of the entries.
</p>

<p>
You can read further in the book how to map this situation via JPA.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org4d930e9" class="outline-2">
<h2 id="org4d930e9">Transactionality</h2>
<div class="outline-text-2" id="text-org4d930e9">
<p>
This is as well an important concept when setting up your ORM
system.
</p>

<p>
Without properly understanding this component you would just make
mess.
</p>

<p>
This is important cause it will highly affect the performance and
correctness of your ORM.
</p>
</div>

<div id="outline-container-org6fe0a61" class="outline-3">
<h3 id="org6fe0a61">Managing Data</h3>
<div class="outline-text-3" id="text-org6fe0a61">
<p>
The first thing to understand in this dimension is the
<code>EntityManager</code> API.
</p>

<p>
With it you manage the lifecycle of your ORM object. I.e. the
focus in on <code>runtime data management</code>.
</p>
</div>

<div id="outline-container-orgc4cb517" class="outline-4">
<h4 id="orgc4cb517">On the life cycle</h4>
<div class="outline-text-4" id="text-orgc4cb517">
<p>
The first point to note in this sense is that JPA as an ORM
implementation is <b>transparent</b>. This essentially means that
classes are <i>unaware of their own persistence capability</i>.
</p>

<p>
In general understand the following terminology as this is the
most important:
</p>

<ul class="org-ul">
<li><p>
persistence life cycle:
</p>

<p>
the <i>states an entity instance goes through</i> during its life.
</p></li>

<li><p>
unit of work:
</p>

<p>
<i>state-changing</i> operations.
</p></li>

<li><p>
persistence context:
</p>

<p>
service that remembers all of the modifications and state
changes you made to data <b>in a particular unit of
work</b>.
</p></li>
</ul>

<p>
Understand now that you essentially have 4 different states in
JPA:
</p>

<img src="../../images/Screenshot 2022-11-14 163909.png " class="center">

<p>
Note that all of this life-cycle is managed through the
Entitymanager. You can see there as well the API for it in order
to manage the life-cycle. You can read the next section in order
to understand more out of it.
</p>

<p>
We dig next in the 4 major states. It is important to understand
these. Just by understanding these and where your Entities are
in the persistence context will you be able to properly work
with JPA in an error-free way.
</p>

<ol class="org-ol">
<li><p>
Transient State:
</p>

<p>
Note that if an instance is in this space, its state is <b>lost
and garbage-collected</b> as soon as they are <b>no longer
referenced</b>.
</p>

<p>
Nothing will persisted as long as the instance is in transient
state.
</p></li>

<li><p>
Persistent State:
</p>

<p>
Here the instance has a representation in the DB. It is
<b>stored in there or will be stored</b> when then the unit of work
completes.
</p>

<p>
Note that instances in the persistent state are <b>always
associated with a persistence context</b>.
</p></li>

<li><p>
Removed State:
</p>

<p>
When an instance is in the removed state, the provider will
delete it <b>at the end of a unit of work</b>.
</p></li>

<li><p>
Detached State:
</p>

<p>
This usually happens when you close the persistence unit of
work by one of the API persisting your data.
</p>

<p>
Then the state moves from persistent to <i>detached</i>. In
detached state the entities are essentially similar to the
<i>transient</i> state.
</p>

<p>
I.e. further changes you applied over there are not persisted
to the DB. Furthermore, as soon as you discard the reference
the instance will be removed and garbage collection will
eventually reclaim the memory.
</p>

<p>
Another option is to leverage the <code>merge()</code> API, as in the
transient state, and move the instance back to the persistent
state.
</p></li>
</ol>
</div>
</div>


<div id="outline-container-org09a2911" class="outline-4">
<h4 id="org09a2911">The Persistence Context</h4>
<div class="outline-text-4" id="text-org09a2911">
<p>
So above is the general lifecycle of ORM instances. 
</p>

<p>
What you have to understand now is that such a lifecycle is
manged through the <code>EntityManager</code> APIs.
</p>

<p>
These are the ones mentioned above.
</p>

<p>
However, <b>very important</b> is as well to perceive that through the
<b>EntityManger</b> you also <b>define the unit of work through the
persistent context</b>. I.e. a unit of work is not bounded to a
particular state. It can encompass multiple states and ensures
transactionality for the entire unit.
</p>

<p>
Note that what you usually do to manage the persistent context is
create a persistent context
<code>EntityManagerFactory#createEntityManager()</code> and close it then
with <code>EntityManager#close()</code>.
</p>

<p>
Note the following now:
</p>

<blockquote>
<p>
In JPA terminology, this is an <b>application-managed persistence
context</b>; your application defines the scope of the persistence
context, <b>demarcating the unit of work</b>.
</p>
</blockquote>

<p>
So understand that it is up to you to properly define the unit of
work in your application.
</p>

<p>
Note now that once you defined your persistence context and your
unit of work, there will be <i>automatic dirty checking</i> by the
engine. This means that the <b>engine will detect which entity
instances the application modified</b>.
</p>

<p>
An update with the DB will then happen either <i>automatically</i> or
<i>on demand</i>.
</p>

<p>
Understand as well the concept of <b>first-level cache</b>. This means
that the persistence context remembers all entity instances you
have handled in a particular unit of work.  If you query for an
instance was already retrieved in the unit of work and is
registered in the persistence context you <b>will not hit the
DB</b>. Hibernate will immediately return you the given
records by <b>creating a reference to the existing instance</b>.
</p>

<p>
Important is to note the following drawback:
</p>

<blockquote>
<p>
Only if an instance with the same identifier value can’t be found in
the current persistence context does Hibernate read the rest of the
data from the result-set row.
</p>

<p>
Hibernate <b>ignores any potentially newer data in the result set, due to
read-committed transaction isolation at the database level</b>, if the
entity instance is already present in the persistence context.
</p>
</blockquote>

<p>
You must handle this drawback at the application level by
explicitely refreshing the data in memory. See the following
section: <a href="#org2517cb6">Refereshing the data in memory</a>.
</p>

<p>
Finally note the following benefit of having a first-cache in
place, these generally offset the drawback discussed above. You
will have to put mechanism in place in order to counterbalance
it.
</p>

<ol class="org-ol">
<li>The persistence layer isn't vulnerable to stack overflows in
the case of circular references. You just have a reference
more.</li>

<li>There can never be conflicting representations of the same
database row at the end of a unit of work.</li>

<li>Likewise, changes made in a particular persistence context are
always immediately visible to all other code executed inside
that unit of work and its persistence context.</li>
</ol>

<p>
So essentially the persistence context provides a <i>guaranteed
scope of object identity</i>. Meaning that both comparison by <code>==</code>
and by <code>equals</code> will yield true if both objects have the same
<b>identifier value</b>. This ultimately solves the problem of
identity in the ORM space - see <a href="#orgbfb94cb">above</a>.
</p>
</div>


<ul class="org-ul">
<li><a id="orgc49bfde"></a>On the context management<br />
<div class="outline-text-5" id="text-orgc49bfde">
<p>
In order to manage the context check at the following:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">  </span><span class="c1">// Creates the EntityManager</span>

<span class="w">      </span><span class="n">UserTransaction</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TM</span><span class="p">.</span><span class="na">getUserTransaction</span><span class="p">();</span>

<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// Opens a Unit of Work</span>
<span class="w">	  </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>
<span class="w">	  </span><span class="c1">// ...</span>
<span class="w">	  </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span><span class="w"> </span><span class="c1">// Flushes</span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="c1">// TODO Transaction rollback, exception handling</span>
<span class="w">	  </span><span class="c1">// ...</span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">	  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">em</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">isOpen</span><span class="p">())</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span><span class="w"> </span><span class="c1">// Closes the Unit of Work</span>
<span class="w">      </span><span class="p">}</span>
</pre></div>

<p>
<b>Note:</b> everything between <code>tx.begin()</code> and <code>tx.commit()</code> occurs
in one transaction. This is a <b>unit of work</b>. This means that
either all of the operations in the unit of work suceed or fail.
</p>

<p>
<b>Note:</b> Hibernate <i>won’t access the database until necessary</i>;
the EntityManager doesn’t obtain a JDBC Connection from the pool
until SQL statements have to be executed. You can create and
close an EntityManager without hitting the database. Hibernate
executes SQL statements when you look up or query data and when
it flushes changes.
</p>

<p>
When Hibernate is notified (by the JTA engine) of the commit, it
performs dirty checking of the persistence context and
synchronizes with the database. You can also force dirty
checking synchronization manually by calling
EntityManager#flush() at any time during a transaction.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org7535357" class="outline-4">
<h4 id="org7535357">On the usage of the Life Cycle API</h4>
<div class="outline-text-4" id="text-org7535357">
<p>
Here I refer to the book for the basic ones, experience will also
teach you.
</p>

<p>
Important points are the following:
</p>
</div>


<ul class="org-ul">
<li><a id="org178486a"></a>Persistence API<br />
<div class="outline-text-5" id="text-org178486a">
<img src="../../images/Screenshot 2022-11-16 122012.png" class="center">

<p>
Important to understand here is as well the following:
</p>

<blockquote>
<p>
When you call persist(), only the identifier value of the Item is
assigned. [The actual insert just happens when you flush/commit the
unit of work].
</p>

<p>
Alternatively, if your identifier generator isn’t
pre-insert, the INSERT statement will be executed immediately when
persist() is called.
</p>
</blockquote>

<p>
<b>Very important</b> is as well the following:
</p>

<blockquote>
<p>
If one of the INSERT or UPDATE statements made when flushing fails,
Hibernate causes a rollback of changes made to persistent instances in
this transaction at the database level. But <b>Hibernate doesn’t roll
back in-memory changes</b> to persistent instances.
</p>
</blockquote>
</div>
</li>


<li><a id="org030e789"></a>Difference between find() and getReference()<br />
<div class="outline-text-5" id="text-org030e789">
<p>
The first one instantiates an instance fully, i.e. it hits the
DB. 
</p>

<p>
The second just creates a proxy if there is no instantiated
instance for the primary key, or assignes to the first level
cached instance present in the DB. 
</p>
</div>
</li>


<li><a id="org2517cb6"></a>Refereshing the data in memory<br />
<div class="outline-text-5" id="text-org2517cb6">
<p>
There is a very simple API that makes this possible.
</p>

<p>
This is very important as with it you will deal with the first
level caching issue that might make your in-memory data out of
date.
</p>

<p>
This is the very issue that you have to keep in mind if you work
in-memory in a <i>hibernating</i> state. You might not be aware about
how the world outside developed.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">      </span><span class="n">item</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;Some Name&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Someone updates this row in the database</span>

<span class="w">      </span><span class="n">String</span><span class="w"> </span><span class="n">oldName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="na">getName</span><span class="p">();</span><span class="w"> </span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">refresh</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

<span class="w">      </span><span class="n">assertNotEquals</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="n">oldName</span><span class="p">);</span>
</pre></div>

<p>
Then it is clear that:
</p>

<blockquote>
<p>
Calling refresh() causes Hibernate to execute a SELECT to read and
marshal a whole result set, overwriting changes you already made to
the persistent instance in application memory.
</p>
</blockquote>

<p>
Note as well:
</p>

<blockquote>
<p>
Most applications don’t have to manually refresh in-memory state;
<b>concurrent modifications</b> are typically resolved at transaction commit
time.
</p>
</blockquote>

<p>
So this boils down to the following:
</p>

<ul class="org-ul">
<li><p>
if you modify the records multiple times in the same unit of
work do not worry. The thing is tricky if you are working with
some other application accessing and modifying the same
records of the DB.
</p>

<p>
So especially in a microservices set up this might be
particularly dangerous. 
</p></li>
</ul>

<p>
Another interesting use-case for refreshing is the following:
</p>

<blockquote>
<p>
Refreshing can be useful to undo changes made in memory during a
conversation, if the user cancels the dialogue.
</p>
</blockquote>
</div>
</li>


<li><a id="org7d8b712"></a>Replicating Data<br />
<div class="outline-text-5" id="text-org7d8b712">
<p>
This is used when you have to retrieve data from one database
and store it in another.
</p>

<p>
Note that you work with <i>two persistent contexts</i>:
</p>

<blockquote>
<p>
Replication takes detached instances loaded in one persistence
context and makes them persistent in another persistence context.
</p>
</blockquote>

<p>
An example for working with the API is the following:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">emA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getDatabaseA</span><span class="p">().</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">emA</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">emB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getDatabaseB</span><span class="p">().</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">emB</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="w">	  </span><span class="p">.</span><span class="na">replicate</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">ReplicationMode</span><span class="p">.</span><span class="na">LATEST_VERSION</span><span class="p">);</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>

<span class="w">      </span><span class="n">emA</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
<span class="w">      </span><span class="n">emB</span><span class="p">.</span><span class="na">close</span><span class="p">()</span>
</pre></div>

<p>
Note now that ReplicationMode defines the replication procedure
in the following sense:
</p>

<ul class="org-ul">
<li>IGNORE — Ignores the instance when there is an existing database
row with the same identifier in the database.</li>

<li>OVERWRITE — Overwrites any existing database row with the same
identifier in the database.</li>

<li>EXCEPTION — Throws an exception if there is an existing database
row with the same identifier in the target database.</li>

<li>LATEST<sub>VERSION</sub> — Overwrites the row in the database if its
version is older than the version of the given entity
instance, or ignores the instance otherwise. Requires enabled
optimistic concurrency control with entity versioning.</li>
</ul>
</div>
</li>


<li><a id="orgb64e238"></a>Caching - clear and detach<br />
<div class="outline-text-5" id="text-orgb64e238">
<p>
The situation is the following one:
</p>

<blockquote>
<p>
Many Hibernate users who ignore this simple fact run into an
OutOfMemoryException. This is typically the case when you load
thousands of entity instances in a unit of work but never intend
to modify them.
</p>

<p>
Hibernate still has to create a snapshot of each instance in the
persistence context cache, which can lead to memory exhaustion.
</p>

<p>
Note now that the persistence context <b>cache never shrinks
automatically</b>.
</p>

<p>
Often, many persistent instances in your context are there by
accident—for example, because you needed only a few items but
queried for many.
</p>

<p>
Extremely large graphs can have a <b>serious performance impact</b> and
require significant memory for state snapshots.
</p>
</blockquote>

<p>
In order to clean the caching of your persistence context you
should work with one of the following two APIs:
</p>

<ul class="org-ul">
<li><code>detach</code>: evict a specific persistent instance manually from the
persistence context.</li>

<li><code>clear</code>: detach all persistent entity instances from the cache.</li>
</ul>

<p>
There is as well the option to retrieve the data in <code>read-only
      mode</code>. This disables the state snapshots and dirty checking such
that Hibernate won't write modifications to the database.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">setDefaultReadOnly</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">      </span><span class="n">item</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;New Name&quot;</span><span class="p">);</span><span class="w"> </span>

<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">flush</span><span class="p">();</span><span class="w">  </span><span class="c1">// Hibernate will not update on the DB despite the</span>
<span class="w">      </span><span class="c1">// setName method above.</span>


<span class="w">      </span><span class="c1">// You can even set it at the individual record level</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>

<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">setReadOnly</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// single item</span>
<span class="w">      </span><span class="n">item</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;New Name&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">flush</span><span class="p">();</span><span class="w">  </span><span class="c1">// no update for the specific item</span>

<span class="w">      </span><span class="c1">// Can set the read only property for all of the records fetched by a query</span>
<span class="w">      </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">Query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="w">	  </span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="n">query</span><span class="p">.</span><span class="na">setReadOnly</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="na">list</span><span class="p">();</span>

<span class="w">      </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">query</span><span class="p">.</span><span class="na">list</span><span class="p">();</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">	  </span><span class="n">item</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;New Name&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">flush</span><span class="p">();</span>
</pre></div>
</div>
</li>


<li><a id="orgd2fedf1"></a>On the DB synchronization<br />
<div class="outline-text-5" id="text-orgd2fedf1">
<p>
Note that the Hibernate synchronizes with the DB in the
following circumstances:
</p>

<ol class="org-ol">
<li>When a joined JTA system transaction is <code>committed</code> - see the
<code>commit()</code> API.</li>

<li>Before a query is executed — we don’t mean lookup with find()
but a <code>query with javax.persistence.Query</code> or the similar
Hibernate API.</li>

<li>When the application calls <code>flush()</code> explicitly.</li>
</ol>

<p>
You can even tune this behaviour by setting the particular
FlushModeType in the correct way:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">      </span><span class="n">item</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;New Name&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">setFlushMode</span><span class="p">(</span><span class="n">FlushModeType</span><span class="p">.</span><span class="na">COMMIT</span><span class="p">);</span><span class="w"> </span><span class="c1">// Disables Flushing before queries</span>

<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span>
<span class="w">		   </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i.name from Item i where i.id = :id&quot;</span><span class="p">)</span>
<span class="w">		   </span><span class="p">.</span><span class="na">setParameter</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">).</span><span class="na">getSingleResult</span><span class="p">(),</span>
<span class="w">		   </span><span class="s">&quot;Original Name&quot;</span>
<span class="w">		   </span><span class="p">);</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span><span class="w"> </span><span class="c1">// Just here you Flush</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</pre></div>
</div>
</li>


<li><a id="org79e034d"></a>On the Detached State<br />
<div class="outline-text-5" id="text-org79e034d">
<p>
You can detach an instance through the <code>detach()</code> API.
</p>

<p>
This is tricky as, when a persistence context is closed, it no
longer provides an identity-mapping service. This is important
as it has important consequences for the comparison of your
instances within a Hibernate application.
</p>

<p>
You can understand this at best by checking at an example:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="c1">// Persistence Context 1 //</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>

<span class="w">      </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">           </span><span class="c1">// True</span>
<span class="w">      </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">b</span><span class="p">));</span><span class="w">      </span><span class="c1">// True</span>
<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">getId</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">  </span><span class="c1">// True</span>

<span class="w">      </span><span class="c1">// You see from the above that within a single Persistence Context you</span>
<span class="w">      </span><span class="c1">// actually solved the identity problem in ORM</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>

<span class="w">      </span><span class="c1">// Persistence Context 2 //</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>
<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span><span class="w">   </span><span class="c1">// when you retrieve from a</span>
<span class="w">					       </span><span class="c1">// difference persistence</span>
<span class="w">					       </span><span class="c1">// context it is a different</span>
<span class="w">					       </span><span class="c1">// instance on the heap</span>

<span class="w">      </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">                  </span><span class="c1">// False</span>
<span class="w">      </span><span class="n">assertFalse</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">c</span><span class="p">));</span><span class="w">            </span><span class="c1">// False </span>
<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">getId</span><span class="p">(),</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">  </span><span class="c1">// True</span>

<span class="w">      </span><span class="c1">// So you see that when an instance enters in detached state they loos</span>
<span class="w">      </span><span class="c1">// scope of object identity. You cannot make the usual comparisons.</span>
<span class="w">      </span><span class="c1">// Just the identity property remains intact. </span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</pre></div>

<p>
This has also consequences when performing operations as:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="c1">// Both persistent context of above closed</span>

<span class="w">      </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allItems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>

<span class="w">      </span><span class="n">allItems</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">      </span><span class="n">allItems</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">      </span><span class="n">allItems</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">allItems</span><span class="p">.</span><span class="na">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// TRUE</span>

<span class="w">      </span><span class="c1">// The reason is that there is a Set operations embedded in the method</span>
<span class="w">      </span><span class="c1">// that leverages the =equals()= API. As per the reasonings above you</span>
<span class="w">      </span><span class="c1">// might not get the expected results.</span>
</pre></div>

<p>
In order to solve this, when working with multiple persistence
contexts and the instances in detached state you have to define
and override your own implementation of the <code>equals()</code> and
<code>hashCode()</code> methods for your mapped entity class.
</p>
</div>


<ul class="org-ul">
<li><a id="org5c7de41"></a>Implementing the Equals() and HashCode() Methods<br />
<div class="outline-text-6" id="text-org5c7de41">
<p>
You can check in the book, essentially the idea is to work with
<b>business keys</b> rather than <b>surrogate keys</b>. This because
surrogate keys are just assigned when persisting instances and
if you make <i>Set</i> operations as the one mentioned above with
<i>transient</i> instances, you might for instance get issues.
</p>

<p>
So one example to do that would be the following - you can
take this a blueprint for the rest of the projects:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="nd">@Table</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERS&quot;</span><span class="p">,</span>
<span class="w">	      </span><span class="n">uniqueConstraints</span><span class="w"> </span><span class="o">=</span>
<span class="w">	      </span><span class="nd">@UniqueConstraint</span><span class="p">(</span><span class="n">columnNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERNAME&quot;</span><span class="p">))</span>

<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="nd">@Override</span>
<span class="w">	   </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">	       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">	       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">User</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">	       </span><span class="n">User</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="w">	       </span><span class="k">return</span>
<span class="w">		   </span><span class="k">this</span><span class="p">.</span><span class="na">getUsername</span><span class="p">().</span><span class="na">equals</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="na">getUsername</span><span class="p">());</span>
<span class="w">	   </span><span class="p">}</span>
<span class="w">	   </span><span class="nd">@Override</span>
<span class="w">	   </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hashCode</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	       </span><span class="k">return</span><span class="w"> </span><span class="n">getUsername</span><span class="p">().</span><span class="na">hashCode</span><span class="p">();</span>
<span class="w">	   </span><span class="p">}</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
In such a way you get equality by <code>equals()</code>. However, it is
important to note that you would not get equality by reference
<code>==</code>.
</p>
</div>
</li>
</ul>
</li>


<li><a id="org6b4a956"></a>Merging State<br />
<div class="outline-text-5" id="text-org6b4a956">
<p>
You can move instances from <code>transient</code> and <code>detached</code> state to
the persistent state via the <code>merge()</code> API.
</p>

<p>
Important is to note that with such an API you <b>return a new
instance</b>, the old one stay in its state and you would
ultimately work with this new instance.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">detachedUser</span><span class="p">.</span><span class="na">setUsername</span><span class="p">(</span><span class="s">&quot;johndoe&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">User</span><span class="w"> </span><span class="n">mergedUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">merge</span><span class="p">(</span><span class="n">detachedUser</span><span class="p">);</span><span class="w"> </span><span class="c1">// NOTE: new instance</span>

<span class="w">      </span><span class="n">mergedUser</span><span class="p">.</span><span class="na">setUsername</span><span class="p">(</span><span class="s">&quot;doejohn&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</pre></div>

<p>
Note that when you call merge() the following happens:
</p>

<blockquote>
<p>
Hibernate checks whether a persistent instance in the persistence
context has the same database identifier as the detached instance
you’re merging.
</p>

<p>
If it is empty Hibernate loads an instance with this identifier
from the database. Then, merge() copies the detached entity
instance onto this loaded persistent instance.
</p>

<p>
If it is present it assigns it by reference to the existing instance.
</p>
</blockquote>

<p>
Graphically the following happens:
</p>

<img src="../../images/Screenshot 2022-11-18 113100.png" class="center">
</div>
</li>
</ul>
</div>


<div id="outline-container-org1c44479" class="outline-4">
<h4 id="org1c44479">On Hibernate Exceptions</h4>
<div class="outline-text-4" id="text-org1c44479">
<blockquote>
<p>
All JPA operations, including flushing the persistence context, can
throw a <b>RuntimeException</b>. This is an unchecked exception, meaning
that you do not have to catch it at compile time.
</p>

<p>
But if you run into it, it will obviously have repercussion on your
system and application.
</p>

<p>
But the methods UserTransaction#begin(), commit(), and even rollback()
throw a checked Exception. I.e. you must <i>catch it at compile time</i>.
</p>

<p>
The <b>exception for rollback requires special treatment: you want to
catch this exception and log it</b>; otherwise, the original exception
that led to the rollback is lost. Continue throwing the original
exception after rollback.
</p>

<p>
Typically, you have another layer of interceptors in your system that
will finally deal with the exception, for example by rendering an
error screen or contacting the operations team.
</p>
</blockquote>
</div>
</div>
</div>


<div id="outline-container-org0b92e3a" class="outline-3">
<h3 id="org0b92e3a">Concurrency</h3>
<div class="outline-text-3" id="text-org0b92e3a">
<p>
This section deals with the case of concurrent access to the
database by multiple persistent contexts and how to deal with it.
</p>

<p>
The idea is that the hibernating way of working with data
in-memory may create issues as discussed before.     
</p>

<p>
We will see how to preserve isolation and control concurrent
access with pessimistic and optimistic strategies.
</p>
</div>

<div id="outline-container-orgb908e57" class="outline-4">
<h4 id="orgb908e57">On the ACID property</h4>
<div class="outline-text-4" id="text-orgb908e57">
<p>
Recall the ACID acronym and recall that usually in relational
databases this is a desired and achieved property.
</p>

<p>
ACID: <i>atomicity, consistency, isolation, durability</i>.
</p>

<p>
When working within a persistent context as a single user this
comes out of the box in a pretty straightforward way.
</p>

<p>
The thing becomes more tricky when multiple applications and
users start to touch the data.
</p>

<p>
In this case you can achieve the above properties with
<i>locks</i>. There are trade-offs in any case which we will be
explore in this section.
</p>

<blockquote>
<p>
Database transactions have to be short, because open transactions
consume database resources and potentially prevent concurrent
access due to exclusive locks on data.
</p>
</blockquote>
</div>
</div>


<div id="outline-container-org8ea191a" class="outline-4">
<h4 id="org8ea191a">On system transactions</h4>
<div class="outline-text-4" id="text-org8ea191a">
<blockquote>
<p>
In an application that manipulates data in several systems, a
particular <b>unit of work</b> involves access to more than one
transactional resource.
</p>

<p>
In this case, you can’t achieve atomicity with JDBC alone. You need a
transaction manager that can handle several resources in one system
transaction.
</p>
</blockquote>

<p>
This is <b>JTA</b>.
</p>

<blockquote>
<p>
JTA standardizes system transaction management and distributed
transactions so you won’t have to worry much about the lower-level
details.
</p>

<p>
[Or in more simple words]:
</p>

<p>
JTA provides a nice abstraction of the underlying resource’s
transaction system, with the added bonus of distributed system
transactions.
</p>
</blockquote>

<p>
Note that we are here dealing with access to multiple resources
on the same application. Not about a microservices setting.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
In order to see this and how ACID is guaranteed - especially the
<i>atomicity</i> part - by JTA in a system transaction, understand the
following:
</p>

<blockquote>
<p>
When you create an EntityManager, it looks for an ongoing JTA system
transaction <b>within the current thread</b> of execution.
</p>

<p>
If the EntityManager finds an ongoing transaction, it <b>joins the
transaction by listening to transaction events</b>. 
</p>

<p>
This means you should always call UserTransaction#begin() and
EntityManagerFactory#createEntityManager() on the same thread if you
want them to be joined.
</p>
</blockquote>

<p>
Through this <b>joining of transaction</b> you would ultimately ensure
the ACID properties in a system transaction.
</p>

<p>
Side note: you can work in a multithreaded way, but you have to
make sure that the transaction is being created on the main
thread.
</p>

<p>
Note the following now:
</p>

<blockquote>
<p>
If the EntityManager can’t find a started transaction in the same
thread when it’s created, it’s in a special <b>unsynchronized
mode</b>. In this mode, JPA won’t automatically flush the
persistence context.
</p>
</blockquote>

<p>
Finally, keep in mind when designing your ORM system that you
should keep keep database transactions <i>as short as possible</i> in
a busy OLTP system. This in order not to block resources for too
long with the various locks etc.
</p>
</div>
</div>


<div id="outline-container-orgb95796d" class="outline-4">
<h4 id="orgb95796d">On concurrent access</h4>
<div class="outline-text-4" id="text-orgb95796d">
<blockquote>
<p>
Databases (and other transactional systems) attempt to ensure
transaction <b>isolation</b>, meaning that, from the point of view of each
concurrent transaction, it appears that no other transactions are in
progress.
</p>

<p>
Traditionally, database systems have implemented <b>isolation with
locking</b>.
</p>
</blockquote>

<p>
We will deal in this section about this topic and will see the
trade off at hand.
</p>

<p>
In order to understand it, understand first the issues that might
occur in multi-user access to the DB.
</p>


<ol class="org-ol">
<li><code>lost update</code>:</li>
</ol>

<img src="../../images/Screenshot 2022-11-24 104403.png" class="center">

<p>
This occurs when transactions are not isolated. Say the first
update, the second tries to update, fails, aborts and rollback to
the original status. The event of the first transaction would be
lost due to the non-isolation of the thing.
</p>


<ol class="org-ol">
<li><code>dirty read</code>:</li>
</ol>

<img src="../../images/Screenshot 2022-11-24 104431.png" class="center">

<p>
Understand first that it is a <i>read</i> issue. You should be
careful when reading <b>uncommited data</b>.
</p>

<p>
The danger comes out of the following: the changes made by the
other transaction may later be rolled back, and invalid data may
be written by the first transaction, such that you might
ultimately perform work with faulty data.
</p>


<ol class="org-ol">
<li><code>unrepeatable read</code>:</li>
</ol>

<img src="../../images/Screenshot 2022-11-24 104458.png" class="center">

<p>
This occurs if a transaction reads a data item twice and reads
different state each time. Recall these names as you will see
then that when choosing the isolation level for your
application you will have to choose among the many
opportunities. Obviously this a broken unrepeatable read is
not that bad. 
</p>

<ol class="org-ol">
<li><code>last commit wins</code>:</li>
</ol>

<img src="../../images/Screenshot 2022-11-24 104534.png" class="center">

<p>
See the issue with this race condition:
</p>

<blockquote>
<p>
User A’s changes are overwritten without warning, and B has
potentially made a decision based on outdated information.
</p>
</blockquote>


<ol class="org-ol">
<li><code>phantom read</code>:</li>
</ol>

<img src="../../images/Screenshot 2022-11-24 104619.png" class="center">

<blockquote>
<p>
This occurs when you read data twice and the second result
includes data that wasn’t visible in the first result or less
data because something was deleted.
</p>
</blockquote>

<p>
Note the difference with repeatable reads. There the <b>same data</b>
was updated. Now you are talking about an update to a different
set of data that affects the last read. 
</p>
</div>

<ul class="org-ul">
<li><a id="org3275878"></a>ANSI ISOLATION LEVELS<br />
<div class="outline-text-5" id="text-org3275878">
<p>
Given, the issue understand now the different possibilities of
transactional isolation guarantees.
</p>

<p>
Note that these guarantees, are usually implemented <b>on the DB
side</b>. Hibernate leverages all of the years of studies in the
field and the advances in the field without implementing
isolation on the application layer.
</p>

<p>
Note that once you define your desired isolation level you can
specify it in JPA and <i>JTA</i> will take care of implementing it.
</p>

<p>
The different isolation levels are summarized in the
following:
</p>

<ol class="org-ol">
<li><p>
<code>Read uncommitted isolation</code>:
</p>

<p>
Here you have: <i>permits dirty reads</i> but <i>not lost updates</i>
operates in read uncommitted isolation.
</p>

<p>
Lost update is in fact one of the most dangerous occurrences
and you should be careful always to avoid it.
</p></li>
</ol>


<ol class="org-ol">
<li><p>
<code>Read committed isolation</code>:
</p>

<p>
<i>Permits unrepeatable reads</i> but <i>not dirty reads</i> implements
read committed isolation.
</p></li>
</ol>


<ol class="org-ol">
<li><p>
<code>Repeatable read isolation</code>:
</p>

<p>
A system operating in repeatable read isolation mode permits
<i>neither unrepeatable reads nor dirty reads</i>. <i>Phantom reads
may occur</i>.
</p></li>

<li><p>
<code>Serializable isolation</code>:
</p>

<p>
the strictest isolation, serializable, emulates serial
execution, as if transactions were executed one after
another, rather than concurrently.
</p></li>
</ol>


<p>
Note that various types of locks are implemented at the DB level
in order to achieve this. Details are skipped here but simply
understand the core idea, the more locks the poorer the
scalability in the number of users and the poorer the
performance.
</p>

<p>
So there is a trade-off between full isolation where you have a
very strong guarantee of what is going on and
scalability. Depending on the business case one solution might
be better than the other.
</p>

<p>
In general understand the following:
</p>

<blockquote>
<p>
Too high an isolation level harms the scalability of a highly
concurrent application.
</p>

<p>
Insufficient isolation may cause subtle, <b>difficult to reproduce</b> bugs
in an application that you won’t discover until the system is working
under heavy load.
</p>
</blockquote>

<p>
Finally, note that Hibernate by default <b>assumes read committed
is the default isolation level</b>.
</p>

<p>
This means you have to <i>deal with unrepeatable reads, phantom
reads, and the last commit wins problem</i>.
</p>

<p>
Note that depending on your ORM there are APIs for setting the
desired isolation level. You can check it online.
</p>
</div>
</li>


<li><a id="org1d739b9"></a>On working with DB versioning<br />
<div class="outline-text-5" id="text-org1d739b9">
<p>
Create reference<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.
</p>

<p>
Important, note the following now:
</p>

<blockquote>
<p>
The combination of the (mandatory) persistence context cache
and versioning already gives you most of the nice features of
<b>repeatable read isolation</b>.
</p>
</blockquote>

<p>
Note as well that versioning switches from last commit wins to
first commit wins.
</p>

<p>
You can better see it in the next section. 
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgc19c2a1" class="outline-4">
<h4 id="orgc19c2a1">On Currency Control Via Locking</h4>
<div class="outline-text-4" id="text-orgc19c2a1">
<p>
In general understand that, given your default isolation level
for your applications, it might happen at times that you might
need to deviate from the norm and implement:
</p>

<blockquote>
<p>
From time to time, a particular unit of work in your application may
require a different, usually stricter isolation level.
</p>

<p>
Instead of changing the isolation level of the entire transaction, you
should use the Java Persistence API to obtain additional locks on the
relevant data.
</p>

<p>
This fine-grained locking is more scalable in a highly concurrent
application. JPA offers optimistic version checking and database level
pessimistic locking.
</p>
</blockquote>

<p>
We will check at the two next.
</p>
</div>


<ul class="org-ul">
<li><a id="org0bd9eba"></a>Optimistic Locking<br />
<div class="outline-text-5" id="text-org0bd9eba">
<p>
Optimistic locking is based on the versioning scheme previously
mentioned.
</p>

<p>
The idea is that with such a versioning scheme you can easily
spot conflicts if multiple users try to write conflicting
records in the DB.
</p>

<p>
You can implement versioning via the <code>@Version</code> notation.
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="nd">@Version</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="w">	  </span><span class="c1">// ...</span>

<span class="w">      </span><span class="p">}</span>
</pre></div>

<p>
Note that this is the recommended way. There is another
possibilities that checks at all of the values in the table. You
can implement this via the
<code>@org.hibernate.annotations.OptimisticLocking( type =
      org.hibernate.annotations.OptimisticLockType.ALL)</code> annotation.
</p>

<p>
This is not recommended. You can google it, should you be more
interesting in it.
</p>

<p>
Turning back to the versioning usage, it basically works as
follows.
</p>

<blockquote>
<p>
The JPA specification leaves open how exactly each LockModeType is
implemented; for OPTIMISTIC, Hibernate <i>performs version
checking</i>. There are no actual locks involved.
</p>

<p>
You’ll have to enable versioning on the entity class you are
interested in.
</p>
</blockquote>

<p>
Then the thing continues as follows:
</p>

<blockquote>
<p>
After incrementing the version number of a detected dirty entity class
during flushing, Hibernate <b>compares versions</b> when executing the UPDATE
and DELETE SQL statements.
</p>
</blockquote>

<p>
Say that you work from inception - meaning from first update
where version is 0 -, it would work as follows then:
</p>

<blockquote>
<p>
[When you work update or delete data, Hibernate will automatically
update the version for the records with version 0. The following
occurs then.]
</p>

<p>
JDBC returns the number of updated rows to Hibernate; if that result
is zero, it means the ITEM row is either gone or doesn’t have the
version 0 anymore. So something must have happened in between - there
was a conflict. 
</p>

<p>
Hibernate detects this conflict during flushing, and a
javax.persistence.OptimisticLockException is thrown.
</p>
</blockquote>

<p>
The above is the trivial case as you just have a single entity.
</p>

<p>
Consider now implementing a more involving case, the one of
retrieving a @ManyToOne relation.
</p>

<blockquote>
<p>
Let’s say you want to sum up all item prices in several
categories. This requires a query for all items in each category, to
add up the prices.
</p>

<p>
The problem is, what happens if someone moves an Item from one
Category to another Category while you’re still querying and iterating
through all the categories and items? With read-committed isolation,
the same Item might show up twice while your procedure runs!
</p>
</blockquote>

<p>
In order to deal with this you can set an optimistic lock at
query time. This will inform you if something has changed in
between.
</p>

<p>
See the following example:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>
<span class="w">      </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">totalPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BigDecimal</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Long</span><span class="w"> </span><span class="n">categoryId</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">CATEGORIES</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i where i.category.id = :catId&quot;</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">setLockMode</span><span class="p">(</span><span class="n">LockModeType</span><span class="p">.</span><span class="na">OPTIMISTIC</span><span class="p">)</span><span class="w"> </span><span class="c1">// set lock ensuring</span>
<span class="w">						    </span><span class="c1">// that you will not get</span>
<span class="w">						    </span><span class="c1">// the unwanted</span>
<span class="w">						    </span><span class="c1">// behaviour mentioned</span>
<span class="w">						    </span><span class="c1">// above.</span>
<span class="w">	      </span><span class="p">.</span><span class="na">setParameter</span><span class="p">(</span><span class="s">&quot;catId&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">categoryId</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">	  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">	      </span><span class="n">totalPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">totalPrice</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getBuyNowPrice</span><span class="p">());</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>

<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">totalPrice</span><span class="p">.</span><span class="na">toString</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;108.00&quot;</span><span class="p">)</span>
</pre></div>

<p>
Note that the following occurs behind the scenes:
</p>

<blockquote>
<p>
Hibernate executes a SELECT during flushing. It checks whether the
database version of each ITEM row is still the same as when it was
loaded.
</p>

<p>
If any ITEM row has a different version or the row no longer exists,
an OptimisticLockException is thrown.
</p>
</blockquote>

<p>
Important is as well to understand the consequences of this:
</p>

<blockquote>
<p>
Hibernate doesn’t batch or otherwise optimize the SELECT statements
for manual version checking: If you sum up 100 items, you get 100
additional queries at flush time.
</p>

<p>
A <b>pessimistic approach</b>, as we show later in this chapter, <b>may be a
better solution</b> for this particular case.
</p>
</blockquote>

<p>
Before <i>addressing pessimistic locking</i> consider a last
important case in optimistic locking.
</p>

<p>
This is increasing version not simply when <i>updating</i> or
<i>deleting</i> but <i>as well for quering</i> the data.
</p>

<p>
Check at the following example:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>

<span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span>
<span class="w">			  </span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span>
<span class="w">			  </span><span class="n">ITEM_ID</span><span class="p">,</span>
<span class="w">			  </span><span class="n">LockModeType</span><span class="p">.</span><span class="na">OPTIMISTIC_FORCE_INCREMENT</span><span class="w"> </span><span class="c1">// force increment when quering</span>
<span class="w">			  </span><span class="p">);</span>

<span class="w">      </span><span class="n">Bid</span><span class="w"> </span><span class="n">highestBid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queryHighestBid</span><span class="p">(</span><span class="n">em</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>

<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="n">Bid</span><span class="w"> </span><span class="n">newBid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Bid</span><span class="p">(</span>
<span class="w">			       </span><span class="k">new</span><span class="w"> </span><span class="n">BigDecimal</span><span class="p">(</span><span class="s">&quot;44.44&quot;</span><span class="p">),</span>
<span class="w">			       </span><span class="n">item</span><span class="p">,</span>
<span class="w">			       </span><span class="n">highestBid</span>
<span class="w">			       </span><span class="p">);</span>

<span class="w">	  </span><span class="n">em</span><span class="p">.</span><span class="na">persist</span><span class="p">(</span><span class="n">newBid</span><span class="p">);</span><span class="w"> </span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InvalidBidException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</pre></div>

<p>
The idea is the following now:
</p>

<blockquote>
<p>
The OPTIMISTIC<sub>FORCE</sub><sub>INCREMENT</sub> mode tells Hibernate that the <i>version</i>
of the retrieved Item <i>should be incremented after loading</i>, even if
it’s never modified in the unit of work.
</p>

<p>
When flushing the persistence context, Hibernate executes an INSERT
for the new Bid and forces an UPDATE of the Item with a version
check. If someone <b>modified the Item</b> concurrently <b>or placed a Bid</b>
concurrently with this procedure, Hibernate <b>throws an exception</b>.
</p>
</blockquote>

<p>
Note that such manual intervention is necessary for the
following reasons:
</p>

<blockquote>
<p>
There is the potential for a race condition in between these two
steps. If, in between reading the highest Bid and placing the new Bid,
another Bid is made, you won’t see it.
</p>

<p>
This conflict isn’t visible; even enabling versioning of the Item
doesn’t help. The Item is never modified during the procedure.
</p>

<p>
[However, note that if you do the manual procedure above it is. Just
do the math and the thought experiment and note that, due to the
ManyToOne relation increasing the Bid version will also increase the
Item]
</p>
</blockquote>
</div>
</li>


<li><a id="org0458627"></a>Pessimistic Locking<br />
<div class="outline-text-5" id="text-org0458627">
<p>
This is the more standard locking procedure you already know.
</p>

<p>
In the sense this lock is the typical lord of the flies example.
</p>

<p>
<b>Just who has the lock can operate</b>.
</p>

<p>
The optimistic lock is more like, anyone can talk, but it there
are contradictions there are gates and checks in order to detect
it and deal with it.
</p>

<p>
Example for implementation of pessimistic lock:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">begin</span><span class="p">();</span>

<span class="w">      </span><span class="n">EntityManager</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JPA</span><span class="p">.</span><span class="na">createEntityManager</span><span class="p">();</span>
<span class="w">      </span><span class="n">BigDecimal</span><span class="w"> </span><span class="n">totalPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BigDecimal</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Long</span><span class="w"> </span><span class="n">categoryId</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">CATEGORIES</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i where i.category.id = :catId&quot;</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">setLockMode</span><span class="p">(</span><span class="n">LockModeType</span><span class="p">.</span><span class="na">PESSIMISTIC_READ</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">setHint</span><span class="p">(</span><span class="s">&quot;javax.persistence.lock.timeout&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5000</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">setParameter</span><span class="p">(</span><span class="s">&quot;catId&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">categoryId</span><span class="p">)</span>
<span class="w">	      </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">	  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">	      </span><span class="n">totalPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">totalPrice</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getBuyNowPrice</span><span class="p">());</span>

<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">tx</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">      </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>

<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">totalPrice</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">BigDecimal</span><span class="p">(</span><span class="s">&quot;108&quot;</span><span class="p">)),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>

<p>
Understand the following two points:
</p>

<blockquote>
<p>
Hibernate locks the rows in the database with the SQL query. If
possible, <i>wait 5 seconds</i> if another transaction holds a conflicting
lock. If the lock can’t be obtained, the query throws an exception.
</p>

<p>
If the query returns successfully, you know that you hold an exclusive
lock on the data and no other transaction can access it with an
exclusive lock or modify it until this transaction commits.
</p>
</blockquote>

<p>
Finally note that in case of pessimistic lock in write mode you
have the following:
</p>

<blockquote>
<p>
JPA also standardizes the PESSIMISTIC<sub>WRITE</sub> mode, with
additional guarantees: in addition to repeatable reads, the JPA
provider must serialize data access, and no phantom reads can
occur.
</p>
</blockquote>

<p>
Hibernate <b>appends a “for update”</b> clause to the SQL query when
loading data. This places a lock on the rows at the database
level. - This is possibly interesting if you want to do
everything directly at the DB level.
</p>

<p>
Note that if you have a joined inheritance mapping strategy,
Hibernate <b>will recognize this and lock the appropriate rows</b> in
super- and sub-tables.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org6cffca1" class="outline-4">
<h4 id="org6cffca1">On Nontransactional DB Operations</h4>
<div class="outline-text-4" id="text-org6cffca1">
<p>
Note, that so far we addressed the case where we wrapped every
operation in transactions.
</p>

<p>
In such a case you had all of the above specified guarantees.
</p>

<p>
If you do not wrap you are automatically in <i>auto-commit mode</i>.
</p>

<p>
You’re working effectively in nontransactional mode, because
there are <b>no atomicity or isolation guarantees</b>.
</p>

<p>
You can read then the session, but basically the idea is that you
can queue all of your operations and just add them then at the
end by joining a transaction and commiting it.
</p>

<p>
In general use it when:
</p>

<blockquote>
<p>
You don’t have a plan or a sequence of statements that you
consider a unit of work.
</p>
</blockquote>
</div>
</div>
</div>


<div id="outline-container-org0db0948" class="outline-3">
<h3 id="org0db0948">On @Autowired vs. @PersistenceContext - for EntityManger injection</h3>
<div class="outline-text-3" id="text-org0db0948">
<p>
Note that it is important to get the difference among the two when
setting up your application.
</p>

<p>
Cause you might quite much mess things up otherwise.
</p>

<p>
The idea is that as mentioned when injecting the <b>same</b> EntityManager
in multiple Services across the applicaiton with <code>@Autowired</code> you
ultimately create multiple such managers. As each holds a cache
and manages a persistencecontext you might start to have very
inconsistent behaviour across your application.
</p>

<p>
This in contrast with <code>@PersistenceContext</code>. When you work with
this annotation what you ultimately get is the usage of the same
EntityManager across the entire applicaiton - even across threads.
</p>
</div>
</div>


<div id="outline-container-orgf700a7a" class="outline-3">
<h3 id="orgf700a7a">On a programmatic approach vs. an annotation based approach</h3>
<div class="outline-text-3" id="text-orgf700a7a">
<p>
Note that all of the examples above are from the book <i>Java
Persistence with Hibernate - Second Edition</i>.
</p>

<p>
In the book everything is done programatically - i.e. at the
lowest possible level.
</p>

<p>
This gives you the highest degree of customizability. Meaning that
you can decide exactly where a transaction starts and commits - to
the database.
</p>

<p>
You can decide that pieces of the story are transactional or
not. You can perform explicitely the rollback strategy etc.
</p>

<p>
The other option is marking classes / or methods - if you want to
have finer grained control - as <code>@Transactional</code>.
</p>

<p>
You can see for instance the following method - using a qualified
TransactionManager.
</p>

<p>
When annotationg with transactional a method it basically means
that the transaction begins at the beginning of the method and
commits at the end of it. You can see that much of the code above
is abstracted away.
</p>

<div class="highlight"><pre><span></span><span class="w">    </span><span class="nd">@Transactional</span><span class="p">(</span><span class="s">&quot;secondaryTransactionManager&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">secondaryConnectionTest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">	</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Persons</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tutorials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

<span class="w">	</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;In the endpoint&quot;</span><span class="p">);</span>

<span class="w">	</span><span class="n">tutorials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">repositoryPersons</span><span class="p">.</span><span class="na">findAllPeopleNative</span><span class="p">();</span>

<span class="w">	</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Successfully queried&quot;</span><span class="p">);</span>

<span class="w">	</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;People found:&quot;</span><span class="p">);</span>
<span class="w">	</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;-------------------------------&quot;</span><span class="p">);</span>

<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Persons</span><span class="w"> </span><span class="n">customer</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">tutorials</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">customer</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Check Console&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="p">};</span>
</pre></div>

<p>
<b>Important Point:</b> note that when working with the JPA-APIs for
quering your database - by inferred queries [other technical
name] - you have syntax check when booting the spring application.
</p>

<p>
The same thing does happen when you work with JPQL queries. It
does not happen when working with native SQL queries. The question
is then how to work in this dimension.
</p>
</div>
</div>
</div>


<div id="outline-container-orgcef12f5" class="outline-2">
<h2 id="orgcef12f5">Fetch Plan, Strategies and Profiles</h2>
<div class="outline-text-2" id="text-orgcef12f5">
<p>
This section tackles the key concepts of: <b>cartesian product</b> and <b>n+1
fetching issue</b>.
</p>

<p>
This was one of the key problems mentioned in the introductory
section when dealing with ORM.
</p>
</div>

<div id="outline-container-orgef2a505" class="outline-3">
<h3 id="orgef2a505">Eager vs Lazy Loading</h3>
<div class="outline-text-3" id="text-orgef2a505">
<p>
In your domain-model mapping, you define the <b>global default</b>
fetch plan, with the <code>FetchType.LAZY</code> and <code>FetchType.EAGER</code>
options on associations and collections.
</p>

<p>
Our recommended strategy is a <b>lazy default</b> fetch plan for all
entities and collections. If you map all of your associations
and collections with FetchType.LAZY, Hibernate will only load
the data you’re accessing at this time.
</p>

<p>
This will speed up your application and make sure you do not
withdraw all of the relevant information.
</p>

<blockquote>
<p>
To implement lazy loading, Hibernate relies on runtime-generated
entity placeholders called <b>proxies</b> and on <b>smart wrappers</b> for
<i>collections</i>.
</p>
</blockquote>
</div>

<div id="outline-container-org6d433e4" class="outline-4">
<h4 id="org6d433e4">On Lazy Loading</h4>
<div class="outline-text-4" id="text-org6d433e4">
</div>
<ul class="org-ul">
<li><a id="orgded0fd3"></a>Proxies<br />
<div class="outline-text-5" id="text-orgded0fd3">
<p>
A proxy is defined as follows:
</p>

<blockquote>
<p>
The proxy is an instance of a runtime-generated subclass of Item,
carrying the identifier value of the entity instance it represents.
</p>

<p>
This is why Hibernate (in line with JPA) requires that entity classes
have <b>at least a public or protected no-argument constructor</b>.
</p>
</blockquote>

<p>
If you call any method on the proxy that isn’t the “identifier
getter,” you trigger initialization of the proxy and hit the
database.
</p>

<p>
Do not compare classes with Proxies. Proxies have special names
in the runtime.
</p>

<p>
Remember that the JPA default for <code>@ManyToOne</code> is FetchType.EAGER!
You usually want to override this to get a lazy default fetch
plan:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	  </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">LAZY</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">public</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="nf">getSeller</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	      </span><span class="k">return</span><span class="w"> </span><span class="n">seller</span><span class="p">;</span>
<span class="w">	  </span><span class="p">}</span>
<span class="w">	  </span><span class="c1">// ...</span>
<span class="w">      </span><span class="p">}</span>
</pre></div>
</div>
</li>


<li><a id="org9dd81a6"></a>Lazy persistent collections - smart wrappers<br />
<div class="outline-text-5" id="text-org9dd81a6">
<p>
You map persistent collections with either @ElementCollection
for a collection of elements of basic or embeddable type or
with @OneToMany and @ManyToMany for many valued entity
associations. These collections are, unlike @ManyToOne,
lazy-loaded by default.
</p>

<blockquote>
<p>
Hibernate implements lazy loading (and dirty checking) of collections
with its own special implementations called <i>collection wrappers</i>.
</p>
</blockquote>

<p>
The lazy bids one-to-many collection is also only <b>loaded on
demand</b>, when accessed and needed, note that you should map
such queries <b>to a Set</b>:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// select * from ITEM where ID = ?</span>
<span class="w">      </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="na">getBids</span><span class="p">();</span><span class="w">               </span><span class="c1">// Understand that you</span>
<span class="w">						    </span><span class="c1">// have to work with</span>
<span class="w">						    </span><span class="c1">// Sets and not</span>
<span class="w">						    </span><span class="c1">// HashSets.</span>

<span class="w">      </span><span class="n">PersistenceUtil</span><span class="w"> </span><span class="n">persistenceUtil</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Persistence</span><span class="p">.</span><span class="na">getPersistenceUtil</span><span class="p">();</span>

<span class="w">      </span><span class="n">assertFalse</span><span class="p">(</span><span class="n">persistenceUtil</span><span class="p">.</span><span class="na">isLoaded</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bids&quot;</span><span class="p">));</span>
<span class="w">      </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">isAssignableFrom</span><span class="p">(</span><span class="n">bids</span><span class="p">.</span><span class="na">getClass</span><span class="p">()));</span>
<span class="w">      </span><span class="n">assertNotEquals</span><span class="p">(</span><span class="n">bids</span><span class="p">.</span><span class="na">getClass</span><span class="p">(),</span><span class="w"> </span><span class="n">HashSet</span><span class="p">.</span><span class="na">class</span><span class="p">);</span><span class="w">  </span><span class="c1">// This is True</span>
<span class="w">      </span><span class="n">assertEquals</span><span class="p">(</span><span class="n">bids</span><span class="p">.</span><span class="na">getClass</span><span class="p">(),</span><span class="w"> </span>
<span class="w">		   </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">collection</span><span class="p">.</span><span class="na">internal</span><span class="p">.</span><span class="na">PersistentSet</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
</pre></div>

<p>
These special collections can detect when you access them and
load their data at that time.
</p>

<p>
Finally note that if you activate <code>LazyCollectionOption.EXTRA</code>,
you get further functionalities that are not included in the
normal setting.
</p>

<p>
There are other performance thing that you can read in the book
if you are interested in it.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org67a6f1c" class="outline-4">
<h4 id="org67a6f1c">On Eager Loading</h4>
<div class="outline-text-4" id="text-org67a6f1c">
<p>
Understand the following concepts of eager loading.
</p>

<p>
If seller were an <i>uninitialized proxy</i>, you’d get a
<b>LazyInitializationException</b> when you accessed it in <b>detached
state</b>.
</p>

<p>
For data <b>to be available in detached state</b>, you need to either
<i>load it manually while the persistence context is still open</i>
<b>or, if you always want it loaded</b>, change your fetch plan to be
<b>eager</b> instead of lazy.
</p>

<p>
So you see that this depends a bit on the application and how
you should set it up.
</p>

<p>
Example:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	  </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">EAGER</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="n">seller</span><span class="p">;</span>
<span class="w">	  </span><span class="nd">@OneToMany</span><span class="p">(</span><span class="n">mappedBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;item&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">EAGER</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	  </span><span class="c1">// ...</span>
<span class="w">      </span><span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgb7cab2f" class="outline-4">
<h4 id="orgb7cab2f">On the different fetching strategies</h4>
<div class="outline-text-4" id="text-orgb7cab2f">
<p>
So basically we will address now the way Hibernate performs the
queries.
</p>

<p>
When you go lazy, your fetch plan will most likely result
in too many SQL statements, each loading only one small piece of
data. This will lead to n+1 selects problems, and we discuss this
issue first.
</p>

<p>
The other option is going eager. You might get here the issue
that larger chunks of data are loaded into memory with each SQL
query. You might then see the Cartesian product problem, as SQL
result sets become too large.
</p>

<blockquote>
<p>
Like fetch plans, you can set a global fetching strategy in your
mappings: the default setting that is always active. Then, for a
particular procedure, you might override the default fetching
strategy.
</p>
</blockquote>
</div>


<ul class="org-ul">
<li><a id="org30a1e2f"></a>The n + 1 case<br />
<div class="outline-text-5" id="text-org30a1e2f">
<p>
Recall that the n + 1 case happen in the following case:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i&quot;</span><span class="p">).</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">      </span><span class="c1">// select * from ITEM</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	  </span><span class="n">assertNotNull</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getSeller</span><span class="p">().</span><span class="na">getUsername</span><span class="p">());</span>
<span class="w">	  </span><span class="c1">// select * from USERS where ID = ?</span>
<span class="w">      </span><span class="p">}</span>
</pre></div>

<p>
So you see 1 query to get the items + n queries for getting the usernames.
</p>
</div>
</li>


<li><a id="org87d14a8"></a>The cartesian product problem<br />
<div class="outline-text-5" id="text-org87d14a8">
<p>
Let's continue from the above.
</p>

<p>
Consider the following:
</p>

<div class="highlight"><pre><span></span><span class="w">      </span><span class="nd">@Entity</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	  </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">EAGER</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">protected</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="n">seller</span><span class="p">;</span>
<span class="w">	  </span><span class="c1">// ...</span>
<span class="w">      </span><span class="p">}</span>
</pre></div>

<p>
You want a guarantee that whenever an Item is loaded, the seller
will be loaded right away—you want that data to be available
when the Item is detached and the persistence context is closed.
</p>

<p>
Now, Hibernate has to <b>stop following your FetchType.EAGER plan</b>
at some point. The number of tables joined depends on the
global hibernate.max<sub>fetch</sub><sub>depth</sub> configuration property.
</p>

<p>
If Hibernate reaches the limit, it will still eagerly load the
data according to your fetch plan, but with additional SELECT
statements. So it happens something similar to the <b>lazy loading
case</b>.
</p>

<p>
Note that the issue is the following now:
</p>

<blockquote>
<p>
Eagerly <b>loading collections with JOINs</b>, on the other hand, can
lead to serious performance issues.
</p>

<p>
If you also switched to FetchType.EAGER for the bids and images
collections, you’d run into the <b>Cartesian product problem</b>.
</p>
</blockquote>

<p>
Considerable processing time and memory are required on the
database server to create such results, which then <i>must be
transferred across the network</i>.
</p>

<p>
If you’re hoping that the JDBC driver <i>will compress the data</i>
on the wire somehow, you’re <i>probably expecting too much</i> from
database vendors.
</p>
</div>
</li>


<li><a id="org8b450d6"></a>The middle ground hummus<br />
<div class="outline-text-5" id="text-org8b450d6">
<p>
So basically you have to understand the middle ground between
the <code>n +1</code> and <code>caretesian product</code>.
</p>

<p>
This can be achieved in the following ways.
</p>
</div>

<ul class="org-ul">
<li><a id="org3f0442f"></a>Prefetching data in batches<br />
<div class="outline-text-6" id="text-org3f0442f">
<p>
This concept is pretty much straightforward.
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="nd">@org.hibernate.annotations.BatchSize</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">       </span><span class="nd">@Table</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;USERS&quot;</span><span class="p">)</span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">};</span>
</pre></div>

<p>
Instead of withdrawing one user at the time in a lazy way, you
would withdraw 10 users at the time.
</p>

<p>
Instead of n+1 SQL queries, you’ll now see <code>n+1/10 queries</code>, a
significant reduction. Reasonable values are usually small,
because you don’t want to load too much data into memory
either, especially if you aren’t sure you’ll need it.
</p>

<p>
Note that batching is <b>also available for collections</b>.
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="nd">@OneToMany</span><span class="p">(</span><span class="n">mappedBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;item&quot;</span><span class="p">)</span>
<span class="w">	   </span><span class="nd">@org.hibernate.annotations.BatchSize</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">	       </span><span class="kd">protected</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>
</div>
</li>


<li><a id="org51058b7"></a>Prefetching collections with subselects<br />
<div class="outline-text-6" id="text-org51058b7">
<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="nd">@OneToMany</span><span class="p">(</span><span class="n">mappedBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;item&quot;</span><span class="p">)</span>
<span class="w">	   </span><span class="nd">@org.hibernate.annotations.Fetch</span><span class="p">(</span>
<span class="w">					    </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">annotations</span><span class="p">.</span><span class="na">FetchMode</span><span class="p">.</span><span class="na">SUBSELECT</span>
<span class="w">					    </span><span class="p">)</span>
<span class="w">	       </span><span class="kd">protected</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
The idea is the following:
</p>

<blockquote>
<p>
Hibernate now initializes <b>all bids</b> collections for all loaded
Item instances as soon as you force the initialization of one
bids collection.
</p>
</blockquote>

<p>
What happens then is the following - embedded subquery;
automatically performed by Hibernate in the background:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i&quot;</span><span class="p">).</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">       </span><span class="c1">// select * from ITEM</span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getBids</span><span class="p">().</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">	   </span><span class="c1">// select * from BID where ITEM_ID in (</span>
<span class="w">	   </span><span class="c1">// select ID from ITEM</span>
<span class="w">	   </span><span class="c1">// )</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
Prefetching using a subselect is a powerful optimization, but
at the time of writing, it was <b>only available for lazy
collections</b>, not for entity proxies.
</p>
</div>
</li>


<li><a id="org5b4a124"></a>Eager fetching with multiple SELECTs<br />
<div class="outline-text-6" id="text-org5b4a124">
<p>
The idea is the following:
</p>

<blockquote>
<p>
When you’re trying to fetch several collections with one SQL
query and JOINs, you run into the Cartesian product problem, as
explained earlier.
</p>

<p>
Instead of a JOIN operation, you can tell Hibernate to <b>eagerly
load data with additional SELECT queries</b> and hence avoid large
results and SQL products with duplicates.
</p>
</blockquote>

<p>
You can achieve this by the following:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@Entity</span>
<span class="w">       </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Item</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="nd">@ManyToOne</span><span class="p">(</span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">EAGER</span><span class="p">)</span>
<span class="w">	   </span><span class="nd">@org.hibernate.annotations.Fetch</span><span class="p">(</span>
<span class="w">					    </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">annotations</span><span class="p">.</span><span class="na">FetchMode</span><span class="p">.</span><span class="na">SELECT</span>
<span class="w">					    </span><span class="p">)</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="n">seller</span><span class="p">;</span>

<span class="w">	   </span><span class="nd">@OneToMany</span><span class="p">(</span><span class="n">mappedBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;item&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchType</span><span class="p">.</span><span class="na">EAGER</span><span class="p">)</span>
<span class="w">	   </span><span class="nd">@org.hibernate.annotations.Fetch</span><span class="p">(</span>
<span class="w">					    </span><span class="n">org</span><span class="p">.</span><span class="na">hibernate</span><span class="p">.</span><span class="na">annotations</span><span class="p">.</span><span class="na">FetchMode</span><span class="p">.</span><span class="na">SELECT</span>
<span class="w">					    </span><span class="p">)</span>
<span class="w">	   </span><span class="kd">protected</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bid</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	   </span><span class="c1">// ...</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
When you run the query to find the Items, you would not join
but actually get the following:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">       </span><span class="c1">// select * from ITEM where ID = ?</span>
<span class="w">       </span><span class="c1">// select * from USERS where ID = ?</span>
<span class="w">       </span><span class="c1">// select * from BID where ITEM_ID = ?</span>
</pre></div>

<p>
The additional SELECT queries aren’t executed lazily; the
find() method produces several SQL queries.
</p>
</div>
</li>


<li><a id="org161119b"></a>Dynamic eager fetching<br />
<div class="outline-text-6" id="text-org161119b">
<p>
So here the idea is to fetch the data in an eager way but
dynamically.
</p>

<p>
Meaning you specify it at query level instead that at a global
level.
</p>

<p>
You can achieve this by the <code>join fetch</code> keywords in the
query. You can see below how these ultimately translate.
</p>

<p>
Apply a dynamic eager fetch strategy in a query:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span>
<span class="w">	   </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i join fetch i.seller&quot;</span><span class="p">)</span>
<span class="w">	   </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>
<span class="w">       </span><span class="c1">// select i.*, u.*</span>
<span class="w">       </span><span class="c1">// from ITEM i</span>
<span class="w">       </span><span class="c1">// inner join USERS u on u.ID = i.SELLER_ID</span>
<span class="w">       </span><span class="c1">// where i.ID = ?</span>

<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>

<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="n">assertNotNull</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getSeller</span><span class="p">().</span><span class="na">getUsername</span><span class="p">());</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>

<p>
Note that join fetching also works for collections - see for
instance below; get all bids for the collection:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span>
<span class="w">	   </span><span class="n">em</span><span class="p">.</span><span class="na">createQuery</span><span class="p">(</span><span class="s">&quot;select i from Item i left join fetch i.bids&quot;</span><span class="p">)</span><span class="w"> </span>
<span class="w">	   </span><span class="p">.</span><span class="na">getResultList</span><span class="p">();</span>

<span class="w">       </span><span class="c1">// select i.*, b.*</span>
<span class="w">       </span><span class="c1">// from ITEM i</span>
<span class="w">       </span><span class="c1">// left outer join BID b on b.ITEM_ID = i.ID</span>
<span class="w">       </span><span class="c1">// where i.ID = ?</span>

<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>

<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	   </span><span class="n">assertTrue</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="na">getBids</span><span class="p">().</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">       </span><span class="p">}</span>
</pre></div>
</div>
</li>


<li><a id="orgdfb03e4"></a>Using Fetch Profiles<br />
<div class="outline-text-6" id="text-orgdfb03e4">
<p>
<code>Fetch Profilies</code>:
</p>

<p>
A proprietary API.
</p>

<p>
This supports overriding lazy-mapped entity associations and
collections selectively, enabling a JOIN eager fetching
strategy for a particular unit of work.
</p>

<p>
<code>Entity Graphs</code>:
</p>

<p>
The @EntityGraph annotation.
</p>

<p>
The provided graph <b>controls what should be loaded</b>;
unfortunately it <b>doesn’t control how it should be loaded</b>.
</p>
</div>


<ul class="org-ul">
<li><a id="org862992b"></a>Declaring Hibernate Fetch Profiles<br />
<div class="outline-text-7" id="text-org862992b">
<p>
This is the global metadata that you have to set up first when
creating your project.
</p>

<p>
Usually you set it up in the <code>package.info</code> java file at
<b>package level</b>.
</p>

<p>
So you see that you would ultimately have a global fetch
strategy at the package level. That is quite handy and you
should set up your project repositories accordingly.
</p>

<p>
An example would be the following:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="nd">@org.hibernate.annotations.FetchProfiles</span><span class="p">({</span>

<span class="w">	       </span><span class="nd">@FetchProfile</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span><span class="p">.</span><span class="na">PROFILE_JOIN_SELLER</span><span class="p">,</span>
<span class="w">			     </span><span class="n">fetchOverrides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@FetchProfile.FetchOverride</span><span class="p">(</span>
<span class="w">									  </span><span class="n">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span>
<span class="w">									  </span><span class="n">association</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;seller&quot;</span><span class="p">,</span>
<span class="w">									  </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchMode</span><span class="p">.</span><span class="na">JOIN</span>
<span class="w">									  </span><span class="p">)),</span>
<span class="w">	       </span><span class="nd">@FetchProfile</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span><span class="p">.</span><span class="na">PROFILE_JOIN_BIDS</span><span class="p">,</span>
<span class="w">			     </span><span class="n">fetchOverrides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@FetchProfile.FetchOverride</span><span class="p">(</span>
<span class="w">									  </span><span class="n">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span>
<span class="w">									  </span><span class="n">association</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;bids&quot;</span><span class="p">,</span>
<span class="w">									  </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FetchMode</span><span class="p">.</span><span class="na">JOIN</span>
<span class="w">									  </span><span class="p">))</span>
<span class="w">		   </span><span class="p">})</span><span class="w">					      </span>
</pre></div>

<ol class="org-ol">
<li>Each profile has a name. This is a simple string isolated in
a constant.</li>

<li>Each override in a profile names <b>one entity association or
collection</b>.</li>

<li>The only supported mode at the time of writing is JOIN.</li>
</ol>

<p>
Then you can <b>activate</b> the specified fetching strategies in
the following way:
</p>

<div class="highlight"><pre><span></span><span class="w">       </span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span>

<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">enableFetchProfile</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">PROFILE_JOIN_SELLER</span><span class="p">);</span>

<span class="w">       </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>

<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// before activating another profile</span>

<span class="w">       </span><span class="n">em</span><span class="p">.</span><span class="na">unwrap</span><span class="p">(</span><span class="n">Session</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">enableFetchProfile</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">PROFILE_JOIN_BIDS</span><span class="p">);</span>
<span class="w">       </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">);</span>
</pre></div>

<ol class="org-ol">
<li>The Item#seller is mapped lazy, so the <i>default fetch</i> plan
only retrieves the Item instance.</li>

<li>You need the Hibernate API to <i>enable a profile</i>. It’s then
active for any operation in that unit of work.</li>

<li>Although basic, Hibernate fetch profiles can be an easy
solution for fetching optimization in smaller or simpler
applications.</li>
</ol>
</div>
</li>


<li><a id="orgdde1034"></a>Working with Entity Graphs<br />
<div class="outline-text-7" id="text-orgdde1034">
<p>
The more involving way of working is the following.
</p>

<p>
With it you can set up more sophisticated fetching
strategies.
</p>

<p>
Check at the following in order to understand everything.
</p>

<div class="highlight"><pre><span></span><span class="w">	</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>

<span class="w">	</span><span class="n">properties</span><span class="p">.</span><span class="na">put</span><span class="p">(</span>
<span class="w">		       </span><span class="s">&quot;javax.persistence.loadgraph&quot;</span><span class="p">,</span>
<span class="w">		       </span><span class="n">em</span><span class="p">.</span><span class="na">getEntityGraph</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getSimpleName</span><span class="p">())</span>
<span class="w">		       </span><span class="p">);</span>

<span class="w">	</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span>
<span class="w">	</span><span class="c1">// select * from ITEM where ID = ?</span>
</pre></div>

<p>
This means attributes that are specified by attribute nodes of
the entity graph are treated as FetchType.EAGER, and
attributes that aren’t specified are treated according to
their specified or default FetchType in the mapping.
</p>

<div class="highlight"><pre><span></span><span class="w">	</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	</span><span class="n">properties</span><span class="p">.</span><span class="na">put</span><span class="p">(</span>
<span class="w">		       </span><span class="s">&quot;javax.persistence.loadgraph&quot;</span><span class="p">,</span>
<span class="w">		       </span><span class="n">em</span><span class="p">.</span><span class="na">getEntityGraph</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getSimpleName</span><span class="p">())</span>
<span class="w">		       </span><span class="p">);</span>
<span class="w">	</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">Item</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ITEM_ID</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span>
<span class="w">	</span><span class="c1">// select * from ITEM where ID = ?</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org4ffe458" class="outline-2">
<h2 id="org4ffe458">Creating different connections to different DBs</h2>
<div class="outline-text-2" id="text-org4ffe458">
<p>
In an ideal setting you would have a single application working
with a single database.
</p>

<p>
In sub-optimal cases this might not be possible.
</p>

<p>
You might have to access different databases.
</p>

<p>
You can do that in the following way.
</p>


<ul class="org-ul">
<li><p>
Step 1: Create two different connectivity pools in your
Spring application settings.
</p>

<div class="highlight"><pre><span></span>     ### Prime Database Details
     app.datasource.prime.url=${db.urldev};database=${db.one};encrypt=true;authentication=ActiveDirectoryPassword;user=${db.username};password=${db.password}

     ### Prime Database Connection Pool Details
     app.datasource.prime.hikari.idle-timeout=10000
     app.datasource.prime.hikari.maximum-pool-size=10
     papp.datasource.prime.hikari.minimum-idle=5
     app.datasource.prime.hikari.pool-name=PrimeHikariPool

     ### Secondary Database Details
     app.datasource.secondary.url=${db.urldev};database=${db.two};encrypt=true;authentication=ActiveDirectoryPassword;user=${db.username};password=${db.password}

     ### Secondary Database Connection Pool Details
     app.datasource.secondary.hikari.idle-timeout=10000
     app.datasource.secondary.hikari.maximum-pool-size=10
     app.datasource.secondary.hikari.minimum-idle=5
     app.datasource.secondary.hikari.pool-name=SecondaryHikariPool
</pre></div></li>
</ul>


<ul class="org-ul">
<li><p>
Step 2:
</p>

<p>
Extend the springboot configurations creating different
EntityMangers and TransactionManagers for the two different
connectivity pools.
</p>

<p>
An example of one such qualified connection is the following:
</p>

<div class="highlight"><pre><span></span><span class="w">     </span><span class="kn">package</span><span class="w"> </span><span class="nn">com.example.springboot</span><span class="p">;</span>

<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.HashMap</span><span class="p">;</span>

<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">javax.sql.DataSource</span><span class="p">;</span>

<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.boot.autoconfigure.jdbc.DataSourceProperties</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.boot.context.properties.ConfigurationProperties</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.context.annotation.Bean</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.context.annotation.Configuration</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.context.annotation.Primary</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.core.env.Environment</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.data.jpa.repository.config.EnableJpaRepositories</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.orm.jpa.JpaTransactionManager</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter</span><span class="p">;</span>
<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.transaction.PlatformTransactionManager</span><span class="p">;</span>

<span class="w">     </span><span class="kn">import</span><span class="w"> </span><span class="nn">com.zaxxer.hikari.HikariDataSource</span><span class="p">;</span>

<span class="w">     </span><span class="nd">@Configuration</span>
<span class="w">     </span><span class="nd">@EnableJpaRepositories</span><span class="p">(</span><span class="n">basePackages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;com.example.jpaRepositories&quot;</span><span class="p">,</span><span class="w">         </span><span class="c1">// Where the JPA Repositories are</span>
<span class="w">			    </span><span class="n">entityManagerFactoryRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;primeEntityManager&quot;</span><span class="p">,</span><span class="w">       </span><span class="c1">// Qualifying the EntityManger - see below how it is constructed. </span>
<span class="w">			    </span><span class="n">transactionManagerRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;primeTransactionManager&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">// Qualifying the TransactionManager - see below how it is constructed.</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PrimaryConnection</span><span class="w"> </span><span class="p">{</span>

<span class="w">	  </span><span class="c1">// Get the environment variables. You specified over there the</span>
<span class="w">	  </span><span class="c1">// variables for connection etc.</span>
<span class="w">	  </span><span class="nd">@Autowired</span>
<span class="w">	  </span><span class="n">Environment</span><span class="w"> </span><span class="n">env</span><span class="p">;</span>

<span class="w">	  </span><span class="nd">@Bean</span>
<span class="w">	  </span><span class="nd">@Primary</span>
<span class="w">	  </span><span class="nd">@ConfigurationProperties</span><span class="p">(</span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;app.datasource.prime&quot;</span><span class="p">)</span>
<span class="w">	  </span><span class="kd">public</span><span class="w"> </span><span class="n">DataSourceProperties</span><span class="w"> </span><span class="nf">primeDataSourceProperties</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	      </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DataSourceProperties</span><span class="p">();</span>
<span class="w">	  </span><span class="p">}</span>

<span class="w">	  </span><span class="nd">@Bean</span>
<span class="w">	  </span><span class="nd">@Primary</span>
<span class="w">	  </span><span class="kd">public</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="nf">primeDataSource</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	      </span><span class="k">return</span><span class="w"> </span><span class="n">primeDataSourceProperties</span><span class="p">().</span><span class="na">initializeDataSourceBuilder</span><span class="p">().</span><span class="na">type</span><span class="p">(</span><span class="n">HikariDataSource</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="w">					     </span><span class="p">.</span><span class="na">build</span><span class="p">();</span>
<span class="w">	  </span><span class="p">}</span>

<span class="w">	  </span><span class="nd">@Bean</span>
<span class="w">	  </span><span class="nd">@Primary</span>
<span class="w">	  </span><span class="kd">public</span><span class="w"> </span><span class="n">LocalContainerEntityManagerFactoryBean</span><span class="w"> </span><span class="nf">primeEntityManager</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	      </span><span class="n">LocalContainerEntityManagerFactoryBean</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LocalContainerEntityManagerFactoryBean</span><span class="p">();</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">setDataSource</span><span class="p">(</span><span class="n">primeDataSource</span><span class="p">());</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">setPackagesToScan</span><span class="p">(</span><span class="s">&quot;com.example.dataEntities&quot;</span><span class="p">);</span><span class="w">                  </span><span class="c1">// Specifying the package with the Entities mapping to the existing DB.</span>
<span class="w">	      </span><span class="n">HibernateJpaVendorAdapter</span><span class="w"> </span><span class="n">vendorAdapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HibernateJpaVendorAdapter</span><span class="p">();</span>
<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">setJpaVendorAdapter</span><span class="p">(</span><span class="n">vendorAdapter</span><span class="p">);</span>

<span class="w">	      </span><span class="c1">// Below you set the relevant properties for your EntityManager. You can see how this was constructed.</span>
<span class="w">	      </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">	      </span><span class="c1">// properties.put(&quot;hibernate.hbm2ddl.auto&quot;, env.getProperty(&quot;hibernate.hbm2ddl.auto&quot;));</span>
<span class="w">	      </span><span class="n">properties</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;hibernate.dialect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="p">.</span><span class="na">getProperty</span><span class="p">(</span><span class="s">&quot;hibernate.dialect&quot;</span><span class="p">));</span>

<span class="w">	      </span><span class="n">em</span><span class="p">.</span><span class="na">setJpaPropertyMap</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
<span class="w">	      </span><span class="k">return</span><span class="w"> </span><span class="n">em</span><span class="p">;</span>
<span class="w">	  </span><span class="p">}</span>

<span class="w">	  </span><span class="nd">@Bean</span>
<span class="w">	  </span><span class="nd">@Primary</span>
<span class="w">	  </span><span class="kd">public</span><span class="w"> </span><span class="n">PlatformTransactionManager</span><span class="w"> </span><span class="nf">primeTransactionManager</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">	      </span><span class="n">JpaTransactionManager</span><span class="w"> </span><span class="n">transactionManager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JpaTransactionManager</span><span class="p">();</span>
<span class="w">		     </span><span class="n">transactionManager</span><span class="p">.</span><span class="na">setEntityManagerFactory</span><span class="p">(</span><span class="n">primeEntityManager</span><span class="p">().</span><span class="na">getObject</span><span class="p">());</span>
<span class="w">		     </span><span class="k">return</span><span class="w"> </span><span class="n">transactionManager</span><span class="p">;</span>

<span class="w">	  </span><span class="p">}</span>

<span class="w">      </span><span class="p">}</span>
</pre></div>

<ul class="org-ul">
<li>Step 3: Inject either programatically / or by Annotation the
EntityManager / TransactionManager of choice and perform your
relevant database operations.</li>
</ul>

<p>
In general you can as well refer to <a href="https://www.javachinna.com/spring-boot-multiple-data-sources/">the following demo</a>.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org4be85a5" class="outline-2">
<h2 id="org4be85a5">On Integration Tests</h2>
<div class="outline-text-2" id="text-org4be85a5">
<p>
This is an important topic in this space. Especially when working
with native queries as you are doing.
</p>

<p>
You should be able to immediately notice if something is going
wrong in such a case.
</p>

<p>
You can refer to <a href="https://reflectoring.io/spring-boot-data-jpa-test/">this arcticle</a> in order to have an introduction in
it.
</p>

<p>
Undestand the idea of working with an in-memory database. Like this
you will remove all of the relevant failures due to possible
networking issues.
</p>

<p>
You will be just left with the programming itself. The question is
how you generate your database in memory etc.
</p>

<p>
A few options are mentioned in the post above. It is clear that
when you work on a green field application you should always work
in such a way as being the most robust one. The question is when
you are on a brown field. What are you doing then?
</p>

<blockquote>
<p>
Important side note: it is important to appreciate as well that if
you work with JPQL or inferred queries you can work with two
different databases, in memory and on the actual cloud etc.
</p>

<p>
You would simply have to change the sql dialect that you are
setting in your application properties.
</p>

<p>
If you work with native queries as is our case now then the
situation looks more problematic. You have to make sure you do not
use any sql specific syntax of the particular database.
</p>

<p>
So you see it is a trade-off: <i>migration vs. performance</i>. Choose
wisely.
</p>
</blockquote>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
TODO - check if this is delt in the section or not.  
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
TODO - you will talk later about versioning in Hibernate.
</p></div></div>


</div>
</div>
