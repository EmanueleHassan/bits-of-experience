<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Python - My Projects Strucuture | Bits of Experience</title>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://marcohassan.github.io/bits-of-experience/posts/python-my-projects-strucuture/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Marco Hassan">
<link rel="prev" href="../refactoring-ediffing-and-merging/" title="Refactoring - Ediffing and Merging" type="text/html">
<link rel="next" href="../a-brief-post-on-smth-nice/" title="A brief Post on Smth Nice" type="text/html">
<meta property="og:site_name" content="Bits of Experience">
<meta property="og:title" content="Python - My Projects Strucuture">
<meta property="og:url" content="https://marcohassan.github.io/bits-of-experience/posts/python-my-projects-strucuture/">
<meta property="og:description" content="Here are some notes about how to set up a project.



I will use this strucuture in the following projects I will have to
do.



For the last project I set up the project from scratch and I think
that">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-07-01T16:03:15+02:00">
<meta property="article:tag" content="Python">
</head>
<body>
    <a href="#page-content" class="sr-only sr-only-focusable">Skip to main content</a>
    
    <section class="social"><ul>
<li><a href="../../pages/aboutme/" title="About me"><i class="fa fa-user-circle"></i></a></li>
            <li><a href="../../pages/bits-of-experience-a-readable-view-on-my-study-adventures/" title="Home"><i class="fa fa-home"></i></a></li>
            <li><a href="../../index.html" title="Blog"><i class="fa fa-edit"></i></a></li>
            <li><a href="../../pages/emacs/" title="A life Configuring Emacs"><i class="fa fa-code"></i></a></li>
            <li><a href="../../pages/papers/" title="Term and Research Papers"><i class="fa fa-university"></i></a></li>
            <li><a href="../../pages/foto-blog/" title="Foto Blog"><i class="fa fa-camera-retro"></i></a></li>
            <li><a href="https://github.com/MarcoHassan" title="My Github"><i class="fab fa-github"></i></a></li>
            <li><a href="https://stackoverflow.com/users/9731177/mhass" title="My Stack"><i class="fab fa-stack-overflow"></i></a></li>
            <li><a href="../../rss.xml" title="RSS"><i class="fa fa-rss"></i></a></li>
            <li><a href="../../categories/index.html" title="Tags"><i class="fa fa-tags"></i></a></li>
    
    

        </ul></section><section class="page-content"><div class="content" rel="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Python - My Projects Strucuture</a></h1>

        <div class="metadata">
            <p class="dateline"><a href="." rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2021-07-01T16:03:15+02:00" itemprop="datePublished" title="2021-07-01 16:03">2021-07-01 16:03</time></a></p>
            <p class="byline author vcard"> <i class="fa fa-user"></i> <span class="byline-name fn" itemprop="author">
                    Marco Hassan
            </span></p>
            
        <p class="sourceline"><a href="index.org" class="sourcelink"><i class="fa fa-file-code"></i> Source</a></p>

            

            
    <div class="tags">
<h3 class="metadata-title">
<i class="fa fa-tags"></i> Tags:</h3>
        <ul itemprop="keywords" class="tags-ul">
<li><a class="tag p-category" href="../../categories/python/" rel="tag">Python</a></li>
        </ul>
</div>

        </div>
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>
Here are some notes about how to set up a project.
</p>

<p>
I will use this strucuture in the following projects I will have to
do.
</p>

<p>
For the last project I set up the project from scratch and I think
that I finally found my way to structure Python Projects in the right
way.
</p>

<p>
Right way - this means - a way that satisfies the following properties:
</p>

<ul class="org-ul">
<li>It is modular. This is extremely important. If you manage to work in
a modular way by clearly separating logical structures you might use
some of these structures for further projects you will work on.</li>

<li>It is portable - by the very same argument explained above.</li>

<li>It is minimal - no double effort</li>

<li>It has strong logic - i.e. it is clear what modules and sub-modules
represent.</li>
</ul>
<p>
I will go into structure and some examples of how to reach such
components next.
</p>

<p>
Note again that this is my second larger project where starting from a
green field I could set everything up. You might want to change and
expand on this structure in following projects.
</p>

<p>
Please, do so and do not forget to expand on that.
</p>

<hr>
<p>
<b>Update 04/04/2022</b>: so I started working on more serious projects. I
noted the importance of sticking to standards. I note that this post
does not comply to any standard. It came out of my particular way of
working. That is fine but before going big on this structure you
should probably rather make a more thorough research on existing
standards and possibly migrate this structure to it. In such a way it
will be easier for external people to understand what you are doing
without too much investigation.
</p>

<p>
Despite of this, good to write such posts. Will help in a couple of
years your new team-mates to enter the work you have done.
</p>

<p>
So it is a good time for starting a new post soon that will be the
synthesis of your experience that far. (As I am not doing it right now
as I have to keep the things moving, I store here some links:
<a href="https://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application">project<sub>structure</sub></a>, <a href="https://stackoverflow.com/questions/1471994/what-is-setup-py">setup<sub>file</sub></a>). It is as well time to start writing
<a href="https://earthly.dev/blog/python-makefile/">Makefiles</a>.
</p>

<p>
Then you can simply pass this and execute this in Docker &amp; Co. and
other similar operations platforms. 
</p>

<hr>
<!-- TEASER_END --><div id="outline-container-orgf19db03" class="outline-2">
<h2 id="orgf19db03">General Basic Strucutre</h2>
<div class="outline-text-2" id="text-orgf19db03">
<p>
Starting from the very beginning the general structure for the
project would look as follows. 
</p>

<pre class="example" id="orgbc52383">
.
├── libraries
├── log
├── Dockerfile
├── postman
├── src
└── test
</pre>

<p>
This general structure is motived by the following:
</p>

<ul class="org-ul">
<li>
<code>libraries</code>: here is a repository where you save the libraries you
work with in your project. This is the usual <code>requirements.txt</code>
text file in python. Like this it will be possible for your peers
or yourself to download all the necessary dependencies when
creating a new virtual environment or pushing to the cloud.</li>

<li>
<code>log</code>: here is a module that will hold the logged information of
your application. this is especially important for doing properly
devOps. Especially when pushing to the cloud you will have the
possibility to double check at later moments important logged
situations. You can then trigger mail alters based on the type of
the logs etc.</li>

<li>
<code>postman</code>: here you save all of your endpoints when you test them
together with all the typical payloads etc. It is especially
useful when you define and expand RESTful API such that you can
quickly share them with your team and so that they can test and
try your endpoints. This especially when they work in the
back-end without being exposed through web-interfaces.</li>

<li>
<code>src</code>: a repo for the code of the project.</li>

<li>
<code>test</code>: a repo for the unit-tests of the project.</li>

<li>
<code>Dockerfile</code>: the <code>Dockerfile</code> with the build image for running
the application.</li>
</ul>
<p>
I will explore the <code>src</code> repo structure next.
</p>
</div>
</div>


<div id="outline-container-org5d58017" class="outline-2">
<h2 id="org5d58017">On the Structure of the Source Code</h2>
<div class="outline-text-2" id="text-org5d58017">
<p>
So given the general structure you should now understand better how
you structure your projects.
</p>

<p>
The general structure of my <code>src</code> repository looks as follows
</p>

<pre class="example" id="org19c340f">
├── app.py
├── app_init
├── forms
├── dataschema
├── log_init
├── migrations
├── models
├── queries
├── routes
├── swagger_config
└── templates
</pre>

<p>
This is a structure I feel particularly well with and it allows the
modularization property previously described.
</p>

<p>
In this sense you have a single script at root level. This is the
application script. I.e. the script your python runtime executes.
</p>

<p>
All of the rest originates from there.
</p>

<p>
I like to keep this script minimal and application agnostic. This
should just run the flask application. The application and its
configuration is not defined in the script, but rather in a separate
application module - the <code>app_init</code> module.
</p>

<p>
An example for such a minimal python script is the following:
</p>

<div class="highlight"><pre><span></span>  <span class="kn">from</span> <span class="nn">swagger_config.swaggerConfig</span> <span class="kn">import</span> <span class="n">api</span>
  <span class="kn">from</span> <span class="nn">app_init</span> <span class="kn">import</span> <span class="n">app</span>

  <span class="n">c</span><span class="c1">## Run the application</span>
  <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
      <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

<p>
So you can see that the script is minimal. You import the modules
and components of interest, i.e. the flask application you specified
in the <code>app_init</code> module as well as the <code>api</code> specifications your
application will serve. You can expose these in different ways,
which I will explore next.
</p>


<p>
One option that I particularly like is the one of leveraging the
<code>flask_restful_swagger_2</code> package.
</p>

<p>
This allows a very strong integration with swagger and it allows you
a very solid structure to work with. You can then build RESTful
endpoints and document everything properly in your code base.
</p>

<p>
I like it as it allows a python native possibility to well annotate
your code and endpoints. You do not separate the two processes and
are less prone to ignore the step because you have to write
everything yourself at the end of the day. In this sense it allows
you to make sure that your documentation develops at the same speed
of your code and allows to have a great documentation both in your
code and easily accessible through the <code>swaggerui</code>.
</p>
</div>

<div id="outline-container-orga6dd30f" class="outline-3">
<h3 id="orga6dd30f">app<sub>init</sub>
</h3>
<div class="outline-text-3" id="text-orga6dd30f">
<p>
Note that this one, together with many other repositories in the
<code>src</code> directory are python modules.
</p>

<p>
This package is usually configured in the following way:
</p>

<pre class="example" id="org3cc4702">
.
├── __init__.py
├── app.db
└── config.py

</pre>

<p>
I.e. I usually keep all of the application configuration in the
configuration file <code>config.py</code>.
</p>

<p>
There all of the important parameters such as the database URL you
connect with are specified. Notice that as I usually push such file
I do not store sensible information in here. Just specifications on
how my flask application should be running.
</p>

<p>
I rather keep the sensible information in an <code>.env</code> file that I load
into the different modules where I need that information. Especially
useful in this sense is the <code>dotenv</code> package.
</p>

<p>
In any case, once you specified all of the specifics of your
application into the <code>config.py</code> file, you import it into the
<code>__init__.py</code> module where you actually specify your app flask
object and configure it accordingly. Finally, as previously noted
you will import such module and the configured application object
from your <code>app.py</code> script.
</p>
</div>
</div>

<div id="outline-container-org48c49e5" class="outline-3">
<h3 id="org48c49e5">forms</h3>
<div class="outline-text-3" id="text-org48c49e5">
<p>
here I store the flask-forms you use to parse content from a <code>html</code>
page. I never worked too much with them apart from implementing a
minimal login front-end.
</p>

<p>
I understand the basic structure, but that is not my bread and
butter and do not even want to waste too much energy on it.
</p>

<p>
You can check the repos in your projects should you want to make
sense of them. Basically you just specify in these forms what the
user should input and can set some validation check to see if an
input that you get makes sense.
</p>
</div>
</div>

<div id="outline-container-org8dbeb19" class="outline-3">
<h3 id="org8dbeb19">dataschema</h3>
<div class="outline-text-3" id="text-org8dbeb19">
<p>
this is an especially important repository where I hold the schema
of my data.
</p>

<p>
Once, more I think it is especially important to have a dedicated
module for it as otherwise you start to have the specifications of
the data models all over the place or implicitly defined in the
code and after some point when the project starts to grow you will
be quickly in troubled waters.
</p>

<p>
Whilst, if you hold such a data schema repository you will have a
centralized location where you store the entire structure of your
data in a very human readable format. You will not have to go
through the code from all over the place and infer from it the data
models.
</p>

<p>
Finally, once you well specify your <code>data schema</code> in such a
repository you can start to pass it as schema to the
<code>flask_restful_swagger_2</code> package and in such a way you will have
everything well documented on your swaggerui. You should then again
be careful to follow some standards in the way you specify such
schema such as the <code>openapi</code> specifications.
</p>

<p>
On the top of it you can also pass such schema to the
<code>flask_expects_json</code> package that will validate the input of given
API and will throw errors in the case the received input does not
comply.
</p>
</div>
</div>

<div id="outline-container-org84d175d" class="outline-3">
<h3 id="org84d175d">log<sub>init</sub>
</h3>
<div class="outline-text-3" id="text-org84d175d">
<p>
In this package I specify the logger specifications you will use
for your application. This is important as especially then when you
deploy to the cloud you must have a solid logging mechanism.
</p>

<p>
You can also set alarms and get mails in the case of some
logging-triggers.
</p>

<p>
Recall the logger has different priority levels. You can configure
the way your messages should be generally logged - i.e. if you want
date, time, minute or whatever… Finally once your logger is
specified in this package you can start to import it in your other
modules of your projects and start to log the information according
to its priority etc.
</p>

<p>
I guess that there are nowadays one of these many 100s
cloud-services doing these kind of job for you. However if you want
the open-source way to do it inherently in python that is the way.
</p>
</div>
</div>

<div id="outline-container-org54900e6" class="outline-3">
<h3 id="org54900e6">migrations</h3>
<div class="outline-text-3" id="text-org54900e6">
<p>
This is an auto-generated repository and is not a python
package. It is auto-generated by the flask-sqlAlchemy package when
doing sql-<b>lite</b> DB migrations.
</p>
</div>
</div>

<div id="outline-container-orgee85603" class="outline-3">
<h3 id="orgee85603">models</h3>
<div class="outline-text-3" id="text-orgee85603">
<p>
here I save some models classes that are needed to store data to
the DB.
</p>

<p>
I.e. here you specify the database schema and based on this you
will have the possibility to create objects in order to read and
write in that DB. Each class might also have methods that allow to
do some processing before saving everything into the DB.
</p>
</div>
</div>

<div id="outline-container-org2f03f0f" class="outline-3">
<h3 id="org2f03f0f">queries</h3>
<div class="outline-text-3" id="text-org2f03f0f">
<p>
That is also a useful repository I use. I started to notice that
sometimes my DB queries were starting to get too long.
</p>

<p>
They started to occupy too much space within the scripts and it
becomes annoying to navigate and get the structure of the
code. This despite all of the different tricks you apply by coding
in emacs - such as the wonderful <code>hide-show</code> mode.
</p>

<p>
So eventually, I decided to start also to save queries in a
separate package and in different modules depending on what their
task/implementation is.
</p>

<p>
Such modules are nothing special. They just contain variables
storing multi-line strings with the queries of interest. You can
then import these in other modules and query/write to your DB based
on that.
</p>

<div class="highlight"><pre><span></span>   <span class="c1">## Example of modules</span>

   <span class="n">createFirstLayer</span> <span class="o">=</span> \
    <span class="sd">"""</span>
<span class="sd">    CREATE (start_0_1:Indication{</span>
<span class="sd">	    layer: 0, </span>
<span class="sd">	    title: 'Unique Histologies',</span>
<span class="sd">	    message: 'Special Considerations for Unique Histologies',</span>
<span class="sd">	    selected: False,</span>
<span class="sd">	    selectedTimestamp: '',</span>
<span class="sd">	    patient: $uuid,</span>
<span class="sd">	    user: $user,</span>
<span class="sd">	    state: 'Workup'</span>
<span class="sd">	    })</span>
<span class="sd">    CREATE (start_0_2:Indication{</span>
<span class="sd">	    layer: 0, </span>
<span class="sd">	    title: 'Other Soft Issue Sarcomas',</span>
<span class="sd">	    message: 'Other soft tissue sarcomas of the extremity/body wall, head/neck',</span>
<span class="sd">	    selected: False,</span>
<span class="sd">	    selectedTimestamp: '',</span>
<span class="sd">	    patient: $uuid,</span>
<span class="sd">	    user: $user,</span>
<span class="sd">	    state: 'Workup'</span>
<span class="sd">	    })</span>
<span class="sd">    """</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga01d39d" class="outline-3">
<h3 id="orga01d39d">routes</h3>
<div class="outline-text-3" id="text-orga01d39d">
<p>
In this package I specify all of the routes of the application.
</p>

<p>
I might split the routes in different modules depending on how big
the application is.
</p>

<p>
Also interesting is to mention the different ways you have to
specify routes.
</p>

<p>
As I previously said, I got into the <code>flask_restful_swagger_2</code>
module and I usually specify my RESTful endpoints in such a way.
</p>

<p>
That is a very powerful module. It allows you to specify an api
object and add endpoints to it by specifying classes inheriting
from the <code>Resource</code> class of <code>flask_restful</code> package.
</p>

<p>
You can then specify <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> methods to such
derived class and add such classes to the api via the
<code>api.add_resource()</code> method.
</p>

<p>
Moreover, as previously noted a module I also like is the <code>from
   flask_expects_json</code> one. From there you can import the
<code>expects_json</code> flag that you can use with the <code>@</code>, passing a
validation schema.
</p>

<p>
Note that here I usually keep one module to serve and specify the
<code>angular</code> routes from which the front-end will be served. I do not
program the front-end myself however it is pretty simply to embed
it into your application once you receive it from a front-end
developer.   
</p>
</div>
</div>

<div id="outline-container-orgb3b1e4a" class="outline-3">
<h3 id="orgb3b1e4a">templates</h3>
<div class="outline-text-3" id="text-orgb3b1e4a">
<p>
Here you keep your <code>html</code> files you can serve from your
backend. Notice that this is not the angular front-end. This one I
usually save it in a different repository. This is much more simple
static or dynamic websites you serve through your
backend. I.e. this is the old way of doing front-end.
</p>

<p>
In most of my projects I do not even have such a repository as
either I am working with front-end people using modern
web-technologies developing in <code>angular</code> or <code>react</code>, or in the
other case I usually do not use a front-end at all.
</p>
</div>
</div>
</div>


<div id="outline-container-org034c287" class="outline-2">
<h2 id="org034c287">Final word</h2>
<div class="outline-text-2" id="text-org034c287">
<p>
You note that when structuring projects in such a way everything is
well defined and the logic is clear.
</p>

<p>
Moreover, once you start to write projects in such a way, you will
start to collect modules you can reuse from project to project. Just
think for instance at how easy it is now to import and use the
logger mechanism or the login-mechanism you implemented into another
project.
</p>

<p>
Therefore, you see that the properties of <code>modularity</code>,
<code>portablity</code>, <code>minimality</code> are fulfilled.
</p>

<p>
Go and expand from here. Find your perfect structure and grow it. 
</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../refactoring-ediffing-and-merging/" rel="prev" title="Refactoring - Ediffing and Merging">Previous post</a>
            </li>
            <li class="next">
                <a href="../a-brief-post-on-smth-nice/" rel="next" title="A brief Post on Smth Nice">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents © 2022         <a href="mailto:marco.hassan30@gmail.com">Marco Hassan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </section><script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
