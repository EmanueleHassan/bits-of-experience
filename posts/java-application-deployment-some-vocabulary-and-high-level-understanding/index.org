#+BEGIN_COMMENT
.. title: Java Application Deployment - Some Vocabulary and high Level Understanding
.. slug: java-application-deployment-some-vocabulary-and-high-level-understanding
.. date: 2021-11-14 20:25:11 UTC+01:00
.. tags: java 
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

Through this post you will gain a bit of vocabulary in the Java
world.

This in the sense that you will understand better the deployment of
application. Server side operations etc. for the Java world. 

{{{TEASER_END}}}

* Java Application

  This section answers the question: how are the bytecode, the relevant
  static front-end files etc. bundled?

** On WAR
  
   A WAR (web application archive) file is used to bundle web
   components, compiled classes, and other resource files like
   deployment descriptors, HTML, JavaScript, and CSS files. Together
   they form a web application.

   To run a Java web application, the WAR file needs to be deployed to
   *the server environment*, a web container.

   The web-app server can be any of Tomcat or Jetty or a Java EE
   server such as JBoss or Glassfish. - in order to understand the
   differences among the many [[https://marcohassan.github.io/bits-of-experience/posts/wsgi-apache-and-nginx/][check at this]].

   Note that in simple words you can say the following:

   #+begin_quote
   A war file is a special jar file that is used to package a web
   application to make it easy to deploy it on an application
   server. The content of the war file must follow a defined
   structure.
   #+end_quote

   Recall the following strucutre. =.jar= is just part of the entire
   system. Can be a package dependency, a bytecode app etc. =war= is
   the entire bundle.
   
   #+begin_export html
   <br>
   <br>
    <img src="../../images/strucutre.png" class="center">
   <br>
   <br>
   #+end_export

   So your app is deployed as =.war= and underneath you might refer to
   =.jar= that package your libraries.

   It is important always to understand where your packaged libraries
   are stored on your file system. In such a way it will be possible
   for you to understnad the dependency structure and see if your
   build and deployment well functioned.

   In this sense refer to your notes about gradle, as like this is
   possible to start to connect the dots.
   
*** More thorough notes on .war structure 

    /Update 21/03/22:/

    So I am starting to connecting the dots. I had a very good session
    with Sergio where we could understand a little bit better the
    current set up. Check at the end of this section. You will start
    to understand a couple of things. 

    I had to spend a little bit more time on the understanding of the
    general java deployment set up. That is important as if you miss
    that one you will never be able to call yourself a java developer.

    So basically the idea is to [[https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch15s03.html][look at the following]]. Below just a
    couple of notes based on it. You might refer to the url directly. 

    Understand that one of the most important bit of the packaged java
    applications is the =web.xml= file. This tells the server what to
    run and how to run it.

    You can inspect the structure of a =.war= through the =jar= tool.

    #+begin_src sh
 jar tvf shoppingcart.war
    #+end_src

    When you build in gradle this should create one of such war
    files. When deployed the /name of the war/ becomes the /root path/ of
    the web-applicaiton.

    #+begin_quote
    The WEB-INF directory (all caps, hyphenated) is a special
    directory that contains all deployment information and application
    code. This directory is protected by the web server, and its
    contents are not visible to outside users of the application, even
    if you add WEB-INF to the base URL.

     The WEB-INF directory also contains the =web.xml= file.
    #+end_quote

    The WEB-INF/classes and WEB-INF/lib directories contain Java class
    files and JAR libraries, respectively.

    The =WEB-INF/classes= directory is automatically added to the
    classpath of the web application, so any class files placed here
    (using the normal Java package conventions) are available to the
    application.

    After that, any JAR files located in =WEB-INF/lib= are appended to
    the web app’s classpath (the order in which they are appended is,
    unfortunately, not specified). You can place your classes in
    either location.

    Nonetheless what is standard is that your source code goes into
    =WEB-INF/classes=, while the libraries you work with will be
    packaged into =WEB-INF/lib=.

    Note now the following bit:

    #+begin_quote
It’s also possible to install JAR files directly in the servlet
container to make them available to all web apps running on that
server. This is often done for common libraries that will be used by
many web apps. It’s also possible to install JAR files directly in the
servlet container to make them available to all web apps running on
that server. This is often done for common libraries that will be used
by many web apps.
    #+end_quote

    The above is important in order to understand what is happening in
    our case. Cause that is the current situation. A big, fat
    web-server with a big chunck of libraries that are installed there
    in the =lib/xtra= etc. that are used across application.

    This has as well the following issue:

    #+begin_quote
The location for placing the libraries, however, is not standard and
any classes that are deployed in this way cannot be automatically
reloaded if changed—a feature of WAR files that we’ll discuss later.
    #+end_quote

    Which is the thing that is disturbing the developer team quite
    much.

*** web.xml working

    The web.xml file is an XML configuration file that /lists servlets
    and related entities to be deployed/, the relative names (URL
    paths) under which to deploy them, their initialization
    parameters, and their deployment details, including security and
    authorization.

    For most of the history of Java web applications, this was the
    only deployment configuration mechanism.

    However, as of the Servlet 3.0 API, there are additional
    options. Most configuration can now be done using Java
    annotations. - This is how you are used to work with.

    So check online at the url described above if you want to go in
    the details. You might have to at some point as you are working
    with legacy code. Would not surprise me if the entire structure of
    the endpoints would be actually defined over there.

*** On reloading web apps

    #+begin_quote
    All servlet containers are supposed to provide a facility for
    reloading WAR files; many support reloading of individual servlet
    classes after they have been modified.

    Reloading WARs is part of the servlet specification and is
    especially useful during development. Support for reloading web
    apps varies from server to server.

    Normally, all that you have to do is drop a new WAR in place of
    the old one in the proper location (e.g., the webapps directory
    for Tomcat) and the container shuts down the old application and
    deploys the new version.
    #+end_quote

    So this is generally what happens when you build your webapp
    through gradle and the ultimate way why you do not have to stop
    the web container and start it again.

    

    

    

    


*** So understand that unorthodoxy with the packaged libraries

    They are in the webapps directory in tomcat.

    So either then the libraries there are added to the classpath
    manually or by default tomcat inspects all of the files in the
    =webapps=.

    This is an open question I will not dig further for now. I will
    ask for more info at the right moment.     
    
** Jakarta Servlet

   A java servlet simply stores a class in Jakarta EE that is conform
   to the specifications of the servlet API. This is simply a standard
   for responding to requests.

   That is basically it. Nothing fancy.

   Thus, a software developer may use a servlet to add dynamic content
   to a web server using the Java platform. The generated content is
   commonly HTML, but may be other data such as XML and more commonly,
   JSON. Servlets can maintain state in session variables across many
   server transactions by using HTTP cookies, or URL mapping. (wiki)

   So again it is a very standard thing. Nothing new under the
   sun. Don't just be scared of the names.

   The only thing is that is the general concept. And that general
   concept must be embedded into the entire ecosystem with the
   different web-containers etc.

   Interesting would then be to understand how frameworks fit in this
   picture. Do they implement the Servlet /under the hood/?

   Note as well that now the historic Servlet API has been replaced by
   two different technologies - I guess two different set of specific
   API albeit wiki does not specify - :

   - Jakarta RESTful Web Services (JAX-RS 2.0) useful for AJAX, JSON
     and REST services

   - Jakarta XML Web Services (JAX-WS) useful for SOAP Web Services
      

** On web-container and Java

   A web-container - also called web-servlet - is the component of a
   web-server that interacts with Jakarta Servlets. (wiki)

   It is essentially the *component (!)* of a *web server* that interacts with
   the servlets. The web container is responsible for managing the
   lifecycle of servlets, mapping a URL to a particular servlet and
   ensuring that the URL requester has the correct access rights.

   Now again nothing new under the sun, Tomcat is the cousin of wsgi
   or something very close to it. The idea of it in the python world
   was discussed [[https://marcohassan.github.io/bits-of-experience/posts/wsgi-apache-and-nginx/][here]]. You can read about the top 5 open source
   web-servers [[https://opensource.com/business/16/8/top-5-open-source-web-servers][here]].

   So do not be confused, it is the servlet component, not the whole
   webserver in itself. I have to well understand in this sense if it
   is still used in combination with a more robust server such apache
   or ngnix or what. 
   
   In any case the post above mentions that you can use the coyote
   extension for Tomcat and serve the role of a web-server, i.e. you
   would have Tomcat not simply handling *Java applications* but as
   well serve static content etc..

   In any case you got the basic idea. With the servlet bit you
   execute the server side java classes answering the requests
   according to the well defined API. Note as well that this goes hand
   in hand in the java world with the JSP Pages, which is basically
   the MVC framework etc. and the way you create dynamic content.

   
