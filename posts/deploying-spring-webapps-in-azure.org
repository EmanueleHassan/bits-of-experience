#+BEGIN_COMMENT
.. title: Deploying Webapps in Azure
.. slug: deploying-spring-webapps-in-azure
.. date: 2022-03-21 16:34:55 UTC+01:00
.. tags: azure, software-engineering, Pyhton, java
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So starting to make a little bit of order and starting to deploy
directly to Azure.

That is nothing fancy at all. Just basics stuff. With it you can start
to properly experiment in your Sandbox. 

{{{TEASER_END}}}

* Choosing the right subscription

  Ok so had a little bit of an hiccup at the beginning. Could not find
  the new subscription to the sandbox environment I could get for
  experimenting on the cloud.

  Turns out that I had to make a new login to my account. With the
  previous login there was no update.

  Weird stuff.

  Anyways after doing that I could see both of my subscriptions - to
  the secure env and to the sandbox

  #+begin_src sh
az account list -o table
  #+end_src

  Now it is possible to specify the subscriptionId of that table and
  the resource group and directly set up stuff over there.  

* One Good tool to monitor your application - Kudu

  This is an open source project you would need to understand more if
  you will work a lot with webapps.

  You can read it over [[https://azure.microsoft.com/en-us/blog/windows-azure-websites-online-tools-you-should-know-about/][here]]. Or [[https://docs.microsoft.com/en-us/azure/app-service/resources-kudu][here]]. And [[https://github.com/projectkudu/kudu/wiki][here]].

  Note that when deploying your apps there is always a runtime of such
  Kudu suite. You can understand better how to work with it.

  To this stage I just understand that this is a project that makes it
  possible to manage and monitor your webapps.

  In this sense the Kudu API that is often mentioned as a possibility
  on the microsoft webpage is interacting with that deployed project
  that will steer your app.

  See for instance [[https://docs.microsoft.com/en-us/azure/app-service/configure-language-java?pivots=platform-linux#starting-jar-apps][here]]. You see that you are actually deploying your
  war to that endpoint. There a bit of magic must also happen.

  *Note* there you have as well a bash shell which has a much higher
  response time in comparison to the ssh option.


* Java
  
** Choosing the runtime

   So the first thing is to choose the right config for your
   applications.

   You can check at the available runtimes with the following:

   #+begin_src sh
az webapp list-runtimes --os linux | grep "JAVA\|TOMCAT\|JBOSSEAP"
   #+end_src

   Interesting is that there is for instance no =Jetty= server. Given
   your recent exploration into async programming and the power of such
   server in that dimension I am struck that azure did not offer such
   an option yet.

   Note that different runtimes need different packaging of the
   underlying bytecode. 


** Gradle Deployment

   There is a nice plug-in in both gradle and maven that will handle
   the deployment and set up of webapps resources.

   You can check it [[https://docs.microsoft.com/en-us/azure/app-service/configure-language-java?pivots=platform-linux#deploying-your-app][here]].

   Then basically through the plug-in you will have a new command that
   will create your webapp with the given specifications of your
   choice.

   #+begin_src java
azurewebapp {
    subscription = '<your subscription id>'
    resourceGroup = '<your resource group>'
    appName = '<your app name>'
    pricingTier = '<price tier like 'P1v2'>' // check here https://azure.microsoft.com/en-us/pricing/details/app-service/linux/#purchase-options
    region = '<region like 'westus'>' // view locations with az account list-locations -o table
    runtime {
      os = 'Linux'
      webContainer = 'Tomcat 9.0'     // or 'Java SE' if you want to run an executable jar
      javaVersion = 'Java 8'
    }
    // appSettings {
    //     <key> = <value>               // here you can pass specific parameter settings for your application
    // }
    auth {
        type = 'azure_cli'            // support azure_cli, oauth2, device_code and service_principal
    }
}
   #+end_src

   Good.

   Note that in general the above is good but should be now embedded in
   a bigger devOps logic. Otherwise it makes little sense.

   The other option is to abstract in the DevOps from all of this. Just
   create a proper environment with all of the relevant
   resources. Deploy then to that targeted resources. 

   Anyways that is a different topic that will just come in time. Back
   to it. Will be useful in any case for my sandbox env. I will have to
   decide soon how I want to work over there.
  
   Now there is a bit of a distinction you have to do depending on the
   server you are using for your deployment.

*** JAVA SE

    This should be the way to run SpringBoot on Linux. It is clearly
    stated by one person of the App service team on the Microsoft
    blogs.

    See [[https://social.msdn.microsoft.com/Forums/azure/en-US/fe9e80d4-7263-46d4-891c-bf38ca4fcc25/azure-webapp-http-status-404-8211-not-found?forum=windowsazurewebsitespreview][here]].

    So start to work through such server if there is no strong point
    for continuing along the way of TOMCAT.

    Would need to talk with the team.

    If you work with such server everything is straightforward; you
    just
   
    #+begin_src sh
  gradle azureWebAppDeploy
    #+end_src

    and badaboom. Everything will work smoothly.

    Your application is converted to an =app.jar= in
    =/home/site/wwwroot= and everything will be unpackaged and run
    correctly.

    It just may take a while.
  
*** TOMCAT

    So here the thing is a bit different as your TOMCAT reads and works
    with =.war=.

    So the first step is to build a =.war= and pass it to the TOMCAT
    within the WebApp in the proper way. 

    Note now that if you deploy a Spring application things are slightly
    more tricky.

    This is because by default Spring packages everything into a
    =.jar=. You can then execute that =.jar= in gradle via the standard

    #+begin_src sh
  ./gradlew.bat bootRun
    #+end_src

    If you want to understand more about that concept check at your
    notes [[https://marcohassan.github.io/bits-of-experience/posts/spring/][here]] in the deployment section.

    Now understand that under the hood when you deploy with the plug-in
    above the thing will not simply start the server but will start as
    well to deploy the artifact of your application.

    Now understand that the TOMCAT server is set up to deploy
    applications packaged as =.war= not as =.jar=.

    In this sense is of paramount importance when deploying spring
    applications to apply as well the =war= plugin such that everything
    will be packaged as a =war= in the correct default location and your
    webapp with your TOMCAT runtime can boot the application correctly.

    #+BEGIN_SRC java :results output drawer :classname 
plugins {

    // Spring Plug-ins
    id 'org.springframework.boot' version '2.4.2'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    
    id 'java'
    id 'war'  // very important
    
    // Microsoft Webapp Plug-in
    id "com.microsoft.azure.azurewebapp" version "1.2.0"
}
    #+END_SRC
  
    Then with it you can deploy your application in the following way

    #+begin_src sh
  gradle azureWebAppDeploy
    #+end_src

    Note that in such a case you deploy a =.war= to the
    =/home/site/wwwroot=.

    So not good enough as you should live in the
    =/home/site/wwwroot/webapps=.

    Check now the following testing etc.
  
*** TODO open issues

    Not working correctly. The application seems to be deployed but I
    cannot hit the endpoint. Get 404 error.

    See the [[https://social.msdn.microsoft.com/Forums/azure/en-US/fe9e80d4-7263-46d4-891c-bf38ca4fcc25/azure-webapp-http-status-404-8211-not-found?forum=windowsazurewebsitespreview][following issue]]. This actually put me off the road. Weird
    stuff.... should work according to my mind.

    So not clear to this stage.

    This is a bit what happens in my team. No idea where to put the
    =.war= so weird pipelines are being created that finally reproduce
    the structure of a TOMCAT.

    You could then force everything in a similar way along these lines
    by following the thing over [[https://www.baeldung.com/spring-boot-war-tomcat-deploy][here]].

    What is weird that in such a case you are not leveraging the magic
    of PaaS and for what is worth you could then well go for IaaS in
    this sense.

    So makes totally no sense.

    So will need to fix that at some point when the right moment will
    come. 

    Giving up for now as it is taking too much time and I have to move
    on with other work. Posted a Question on StackOverflow. Try to
    check what answers you get over there. [[https://stackoverflow.com/questions/71584566/deploying-a-war-on-azure-webapps-tomcat-server][Monitor it]].

    --------------

    Talked with Valerio. It seems that everything I am doing is
    correct.

    So I really do not understand what is going on. Try not with the
    free tier.

    Note that you can as well use the [[https://github.com/projectkudu/kudu/wiki/Deploying-WAR-files-using-wardeploy][Kudu API]]. Good reference as well
    to understand what is happening under the hood.

    For these you need your webapp credentials. You can get them [[https://docs.microsoft.com/en-us/azure/app-service/deploy-configure-credentials?tabs=cli][like
    that]].


    #+begin_src sh
az webapp deployment list-publishing-profiles --resource-group <group-name> --name <app-name>
    #+end_src

    This is actually what you did the first time when deploying your
    applications to the cloud. Had to go there via UI and get that
    info and store it in a config file.

    Obviously not the best. I guess in any case that is really the same
    as deploying with the =az webapp deploy= command directly which is
    already integrated with your credentials.

    So that cannot be it.


* Python

  This section deals with the deployment of python runtimes.

  I am still considering some best of breed approach. I still have to
  consider as managing two stacks concurrently will not be a trivial
  task.

  If you manage to properly set up a devOps pipeline for it, it might
  be easier then. Check with the team to see at what point we are in
  this dimension.

  In any case the way to do it is well outlined [[https://medium.com/@nikovrdoljak/deploy-your-flask-app-on-azure-in-3-easy-steps-b2fe388a589e][here]].

  Note this way of interacting with Kudu. This is a little bit
  different to the one you explored so far.

  It is nonetheless the way through which we interact with AzureWebapp
  so far in the Java stack in your team in production. The way to work
  directly with gradle and specify all of the pipelines in there is not
  the way decided by the team. So check at how the situation develops
  across time.

** Creating an Application

   You can do it with the ~az webapp up [args]~ command.

   So for instance you can specify

   #+begin_src sh
az webapp up--runtime PYTHON:3.7 \
    --sku F1 \
    --os Linux \
    --subscription <blabla> \
    --resource-group <blabla> \ 
    --logs
   #+end_src
   

** Deploying

   So note that this section will be relevant as well for understand
   the general set up and how you currently deploy the applications on
   azure.

   So basically what you can do it to set a user specific crendential
   to deploy to the webapps.

   You can start in such a way for your sandbox, then again in devOps
   with the pipelines everything will be integrated.

   The idea is that there is an application specific =user= and
   =password= that you can theoretically use to deploy over there.

   Once you set your options for a specific subscription you can as
   well use this. This is actually better as you can then see who did
   what.

   You can view your user configurations for depoying to a webapp
   under a specific subscription in the following way:

   #+begin_src sh
   az webapp deployment user show --subscription <blabla>
   #+end_src

   Note that I think that the password parameter is not displayed even
   when it is set.

   You can set it via shell for a specific subscription via:

   #+begin_src sh
   az webapp deployment user set --subscription <blabla> --password {password} --user-name MyUserName
   #+end_src   

   Then with it it will be possible for you to deploy your code on a
   given application.

   

** Set up the startup script

   Note that in order to correctly deploy the thing you must follow
   some given standards.

   This is the ugly thing of working with such services instead of
   going with Docker directly.

   You do not really undestand what is going on and I must say that
   the official documentation abstracts a little bit too much away.

   In any case this is my current set-up and in such a way it works.

   Check [[https://docs.microsoft.com/en-us/azure/app-service/configure-language-python][here]] the section: Custom Flask main module.

   See [[https://github.com/microsoft/python-sample-vscode-flask-tutorial][this]] as an example. Implemented a similar logic with
   =__init__.py= actually implementing the application logic and
   another one importing it. So basically have ultimately a
   =startup.py= importing the app.

   So note now that everything works with a =startup.py= script and a
   =requirements.txt= file in the higher level of the application
   repository you are passing to the webapp.

   I have something in this setting

   #+begin_quote
├───app_init
├───azurestorage
├───deploymentFiles
├───etl
├───forms
├───log
├───migrations
│   └───versions
├───models
├───postman
├───routes
├───swaggerui
│   ├───css
│   ├───fonts
│   ├───images
│   ├───lang
│   └───lib
├───templates
└───test
   #+end_quote

   Note that the structure has to be refined. 
   
   The only thing you have to add is a strartup command to your app -
   see setting -> configuration -> .

   In my case:

   #+begin_src sh
gunicorn --bind=0.0.0.0 --timeout 600 startup:app
   #+end_src

   Just recall the last part which is
   =<file_you_run_as_script>:<app_name_defined_within>=.

   You are ready to push then to your app through git and the PaaS
   will then start to read and unpackage everything in the right way. 


** Note that the inner architecture of Azure is complex

   Here the functioning and the hidden inner structrues are more
   complex in comparison to the deployment of a Java app.

   What you actually get in the =/home/site/wwwroot= is a packaged
   Oryx file.

   So basically that is the piece of software that manages the thing.

   Then what basically happens is that a directory is created in
   =/tmp=.

   There a virtual environment will be instantiated, you will download
   all of the needed dependencies there and start the app.

   This will be then the source and the space where your app moves
   in. You can see it cause if you log to a file in the project, you
   will find the added log of the application over there. 


* Debugging

** Java
  
   So you have to get used to the things in life.

   So basically by deploying via the gradle plugin you do not get a lot
   of logged info.

   So as mentioned it might seem that everything is working properly
   when it is not.

   Or at least will have to understand better how to properly log
   everything. In this sense it makes sense to start with the Azure
   certification soon. Will help you to gain that knowledge and it will
   be a guided tour instead of an unstructured go and conquer.

   In any case here you will have little info but if the applicaiton
   is not able to boot despite the successfuly deployment of the
   =.jar= on the webapp, then you will get an application error
   response when trying to hit one of your endpoints.

   If you then go on the diagnostic tools you should be able to have
   an option where you can ultimately see the spring boot application
   logs and there you will find the root cause of the issue.

   Or at least will help you to understand what is going on wrong over
   there. 
   
** Python

   In the way you deploy via git integration you will get a lot of
   feedback.

   So basically in this way of deploying your can check your
   log-stream and you will get a good idea of the issues.

*** Use log-stream for debugging

     This is nice way to check about what is happening in your deployed
     webapp.

     You will see there if the application did not start and it will
     give you some hints on what went wrong.

     This is actually quite annoying of these webapps. I was used to
     work in a different way.

     Either everything started or you would get a failure message.

     Here you do not necessarily get a failure. Cause if you manage to
     upload the files to AzureWebApps then you get a success message.

     Whether then the PaaS service manages to correcly unpack everything
     and start the application out of the box is a different question
     for this you would actually have to check at the logs.

     You can use is it as well to check at your logs for the
     application.

     Note that I was used to write the logs to a file. I have to explore
     all of the logging monitoring services more into detail. It is
     clear nonetheless that with all of the log services and log queries
     services it probably makes sense to log everything directly into
     the console.


* Understand pricing tiers in Azure

  How are they constrcuted? What are the specifics?

  You can find them [[https://azure.microsoft.com/en-us/pricing/details/app-service/windows/][here]].

  Now for testing on the sandbox env that I finally managed to get you
  can go with the free tier without any issue.

  In any case should you in the future need an overview you can check
  there cause it is not convenient to fake the mock creation via
  web-UI and then exploring there.

  Note as well [[https://docs.microsoft.com/en-us/answers/questions/285699/is-there-a-way-to-get-the-sku-for-a-list-of-web-ap.html][the following option]] if you want to do that via CLI as
  you mostly work and live in there.
  
  

