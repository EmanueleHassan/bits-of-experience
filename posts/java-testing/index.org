#+BEGIN_COMMENT
.. title: Java Testing
.. slug: java-testing
.. date: 2022-01-27 16:20:12 UTC+01:00
.. tags: java, testing
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So I am starting to deliver some solutions on some minor features on
some applications.

There was quite a bit of work to be done in the last couple of
months. I mean I had to get up and running with Java, reverse engineer
some bit of application, write documentation etc. I am slowly getting
up to speed. I have still quite a few things on my mind and I guess
that to reach the point where I would like to be it will be another
6-12 months but I am moving at a /decent/ speed so that I am not
complaining too much.

The structure and challenges of the job gets clearer everyday so that
is fine - now it is a question of adapting and working strategically
to overcome the various issues.

The next bit that is on the list is about testing. This post deals
with it. I am ready to get up and running with it and start to write
well-covered software. In a further step you can then imagine some
further integration with tools as [[https://en.wikipedia.org/wiki/SonarQube][sonarqube]] etc.

Cool. Starting to test seriously. Like this we can soon set up serious
devOps pipelines.

{{{TEASER_END}}}

* Testing 

  So basically I am starting to dig in the testing bit.

  Always recall the essential three kind of tests in the ideal world:

  - unit testing

  - integration testing

  - functional testing

  I will start by writing unit tests for my application. I will then
  maybe go into the other in time.   
  

* Unit Testing
  
** Index for the page

   - [[*JUnit][JUnit]]
  
     - [[*Set Up][Set Up]]

     - [[*Actually Testing][Actually Testing]]

     - [[*Test Classes And Method][Test Classes And Method]]

     - [[*JUnit Jupiter][JUnit Jupiter]]:

       - [[*@ExtendWith][@ExtendWith]]

       - [[*@RegisterExtension][@RegisterExtension]]

       - [[*@TempDir][@TempDir]]

       - [[*Testing Annotations][Testing Annotations]]

       - [[*Tagging][Tagging]]

       - [[*Naming and UI Style Annotations][Naming and UI Style Annotations]]

       - [[*LifeCycle Annotations][LifeCycle Annotations]]

       - [[*Templates - @TestTemplate][Templates - @TestTemplate]]

       - [[*Dynamic Testing][Dynamic Testing]]

       - [[*URI][URI]]

       - [[*Timeouts][Timeouts]]

       - [[*check how to combine the annoations above into meta-annotations][check how to combine the annoations above into meta-annotations]]


     - [[*AssertionTypes][AssertionTypes]]

     - [[*Assumptions][Assumptions]]

  - [[*The bigger picture in unit-testing][The bigger picture in unit-testing]]
   
  - [[*Stub][Stub]]
   
  - [[*Mocks - Mockito][Mocks - Mockito]]

     - [[*What is a mock object][What is a mock object]]
     - [[*Creating a mock() object and verifying the parameters received][Creating a mock() object and verifying the parameters received]]
     - [[*Dependency Injection Tool][Dependency Injection Tool]]
     - [[*@Spy][@Spy]]
     - [[*@Capture][@Capture]]
     - [[*Resources used for the tutorial][Resources used for the tutorial]]       


** JUnit
   
*** Index
   
    - [[*JUnit][JUnit]]
  
      - [[*Set Up][Set Up]]

      - [[*Actually Testing][Actually Testing]]

      - [[*Test Classes And Method][Test Classes And Method]]

      - [[*JUnit Jupiter][JUnit Jupiter]]:

	- [[*@ExtendWith][@ExtendWith]]

	- [[*@RegisterExtension][@RegisterExtension]]

	- [[*@TempDir][@TempDir]]

	- [[*Testing Annotations][Testing Annotations]]

	- [[*Tagging][Tagging]]

	- [[*Naming and UI Style Annotations][Naming and UI Style Annotations]]

	- [[*LifeCycle Annotations][LifeCycle Annotations]]

	- [[*Templates - @TestTemplate][Templates - @TestTemplate]]

	- [[*Dynamic Testing][Dynamic Testing]]

	- [[*URI][URI]]

	- [[*Timeouts][Timeouts]]

	- [[*check how to combine the annoations above into meta-annotations][check how to combine the annoations above into meta-annotations]]


      - [[*AssertionTypes][AssertionTypes]]

      - [[*Assumptions][Assumptions]]
	- [[*The bigger picture in unit-testing][The bigger picture in unit-testing]]
	 
*** Set Up

    So essentially I will use the JUnit package for running unit
    tests.

    First of all include it in your gradle dependencies

    #+begin_src gradle
dependencies {

  ...

  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'

  ...
}
    #+end_src

    Then basically you are good to go.

    Note that I work with gradle. Note that there you essentially have
    the default that your tests should lie in the =src/test/java=
    directory.

    So essentially when working in Eclipse you can start by creating a
    source-folder (meaning folder containing source code) respecting
    this convention =src/test/java=.

    Then from there you can go on by creating =JUnit Test= Cases. Note
    that in Eclipse everything is pretty much embedded. So everything
    goes through the UI. In this sense you click on the =src/test/java=
    source file and from there you create a new JUnit test. There you
    have to specify the package you want to work on, say
    =com.zurich.im.b1.feeds.model=.

    Then you can specify the class in that package that you want to
    test. Finally you declare your test file with the following naming
    convention =<MyClass>Test=.

    You are done then, bu as soon as you will manage to fix your issues with
    emacs start to migrate as that is a much more powerful tool.

*** Actually Testing

    This is then straightforward. You can read and refer a bit to the
    [[https://junit.org/junit5/docs/current/user-guide/][following documentation]].

    So first thing you have to understand:

    #+begin_quote
    JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
    #+end_quote

    So what are the three:

    - =JUnit Platform=: it is the actual platform for running your
      tests. This is used by the different clients - be a process from
      your shell, the one embedded in your Eclipse IDE etc.

    - =JUnit Jupiter=: This module includes new programming and
      extension models for writing tests in JUnit 5. You have new
      annotators etc.

    - =JUnit Jupiter=: This is for running JUnit 3 and JUnit 4 based
      tests on the platform.  

    So we will now focus on =JUnit Jupiter= as that is the actually
    coding part for writing your tests. You will then check with the
    time at the rest - if you will check at them at all... just need
    to decide on how to connect to the =JUnit Platform=... for now use
    the Eclipse IDE... there everything is more less embedded. Move
    then to Emacs with time.

*** Test Classes And Method
    
    What are the first-class citizens. 

    - =Test Class=  this is a top-level class, static member class or
      =@Nested= class that contains at least 1 test method.

    - =Test Method= any instance method that is directly annotated or
      meta-annotated with =@Test, @RepeatedTest, @ParameterizedTest,
      @TestFactory, or @TestTemplate=

    - =Lifecycle Method= any method that is directly annotated or
      meta-annotated with =@BeforeAll, @AfterAll, @BeforeEach, or
      @AfterEach=.

    So that is nothing new. Trivial I would say it is just setting
    naming conv.

    Note that =Test Method= and =Lifecycle Method= does not have to
    return any value.

    The only *exception* are =@TestFactory= methods where you are
    required to return a value.

*** JUnit Jupiter

    - [[*@ExtendWith][@ExtendWith]]

    - [[*@RegisterExtension][@RegisterExtension]]

    - [[*@TempDir][@TempDir]]

    - [[*Testing Annotations][Testing Annotations]]

      - [[*@RepeatedTest][@RepeatedTest]]
      - [[*@RepeatedTest][@RepeatedTest]]
      - [[*@ParameterizedTest][@ParameterizedTest]]


    - [[*Tagging][Tagging]]

    - [[*Naming and UI Style Annotations][Naming and UI Style Annotations]]

      - [[*@DisplayName][@DisplayName]]
      - [[*@DisplayNameGeneration][@DisplayNameGeneration]]
      - [[*@IndicativeSentencesGeneration][@IndicativeSentencesGeneration]]
      - [[*@Nested][@Nested]]      

    - [[*LifeCycle Annotations][LifeCycle Annotations]]

      - [[*Tests Lifecycle][Tests Lifecycle]]
      - [[*@BeforeEach][@BeforeEach]]
      - [[*@AfterEach][@AfterEach]]
      - [[*@BeforeAll][@BeforeAll]]
      - [[*@AfterAll][@AfterAll]]
      - [[*@Disabled][@Disabled]]
      - [[*@TestInstance][@TestInstance]]
      - [[*@TestMethodOrder][@TestMethodOrder]]
      - [[*@TestClassOrder][@TestClassOrder]]

    - [[*Templates - @TestTemplate][Templates - @TestTemplate]]

    - [[*Dynamic Testing][Dynamic Testing]]

      - [[*@TestFactory][@TestFactory]]
      - [[*Examples][Examples]]


    - [[*URI][URI]]

    - [[*Timeouts][Timeouts]]

    - [[*check how to combine the annoations above into meta-annotations][check how to combine the annoations above into meta-annotations]]

    
    Basically in order to understand well how to write tests in Java
    understand on the one hand the following annotators through which
    it is possible to specify the general logic of your tests and on
    the other hand the possible assertions treated in the [[*AssertionTypes][next
    section]]. Also recall about [[*Assumptions][Assumptions]].

    - [[*LifeCycle Annotations][LifeCycle Annotations]]

**** @ExtendWith

     Used to register extensions declaratively. Such annotations are
     inherited. 

**** @RegisterExtension

     Used to register extensions programmatically via fields. Such fields
     are inherited unless they are shadowed. 

**** @TempDir

     Used to supply a temporary directory via field injection or parameter
     injection in a lifecycle method or test method; located in the
     org.junit.jupiter.api.io package. 
        

**** Testing Annotations

     These annotations are basically used for testing itself.

     They specify how methods in test classes should be read and
     processed.

     
***** Index
      
      - [[*@RepeatedTest][@RepeatedTest]]
      - [[*@RepeatedTest][@RepeatedTest]]
      - [[*@ParameterizedTest][@ParameterizedTest]]

***** @Test

      Denotes that a method is a test method.

      That is the most trivial one. 

***** @RepeatedTest

      JUnit Jupiter provides the ability to repeat a test a specified
      number of times by annotating a method with @RepeatedTest and
      specifying the total number of repetitions desired. Each
      invocation of a repeated test behaves like the execution of a
      regular @Test method with full support for the same lifecycle
      callbacks and extensions.

      See you demo test. Then when you run the test you will basically
      see the repetitions nested in the method of interest.

      Use the following example as per the offficial docu to style
      your tests:

      #+BEGIN_SRC java :results output drawer :classname 
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.logging.Logger;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.TestInfo;

class RepeatedTestsDemo {

    private Logger logger = // ...

	@BeforeEach
	void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        String methodName = testInfo.getTestMethod().get().getName();
        logger.info(String.format("About to execute repetition %d of %d for %s", //
				  currentRepetition, totalRepetitions, methodName));
    }

	@RepeatedTest(10)
	void repeatedTest() {
	    // ...
	}

    @RepeatedTest(5)
    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {
        assertEquals(5, repetitionInfo.getTotalRepetitions());
    }

    @RepeatedTest(value = 1, name = "{displayName} {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeat!")
    void customDisplayName(TestInfo testInfo) {
        assertEquals("Repeat! 1/1", testInfo.getDisplayName());
    }

    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)
    @DisplayName("Details...")
    void customDisplayNameWithLongPattern(TestInfo testInfo) {
        assertEquals("Details... :: repetition 1 of 1", testInfo.getDisplayName());
    }

    @RepeatedTest(value = 5, name = "Wiederholung {currentRepetition} von {totalRepetitions}")
    void repeatedTestInGerman() {
        // ...
    }

}
      #+END_SRC

      :results:
      INFO: About to execute repetition 1 of 10 for repeatedTest
      INFO: About to execute repetition 2 of 10 for repeatedTest
      INFO: About to execute repetition 3 of 10 for repeatedTest
      INFO: About to execute repetition 4 of 10 for repeatedTest
      INFO: About to execute repetition 5 of 10 for repeatedTest
      INFO: About to execute repetition 6 of 10 for repeatedTest
      INFO: About to execute repetition 7 of 10 for repeatedTest
      INFO: About to execute repetition 8 of 10 for repeatedTest
      INFO: About to execute repetition 9 of 10 for repeatedTest
      INFO: About to execute repetition 10 of 10 for repeatedTest
      INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
      INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
      INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
      INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
      INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
      INFO: About to execute repetition 1 of 1 for customDisplayName
      INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
      INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
      INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
      INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
      INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
      INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
      import static org.junit.jupiter.api.Assertions.assertEquals;
      :end:

      Nice, you can then add this to your logs and inspect them
      etc. Have still to decide on the workflow for such tests but that
      is a good option.
      
      Such methods *are inherited* unless they are overridden.
      
***** @ParameterizedTest

      Understand the following naming conventition that will be used
      in this section

      - =factory method=: a non-private, static method declared in the
      target type that accepts a single String argument and returns an
      instance of the target type. The name of the method can be
      arbitrary and need not follow any particular convention. 

      - =factory constructor=: a non-private constructor in the target
      type that accepts a single String argument. Note that the target
      type must be declared as either a top-level class or as a static
      nested class.

      These can then be used for parameterizing your test cases.
      
****** Most basic example

       It is possible for the tests to run with different parameters
       with the use of this tag.

       See for instace the following

       #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@ValueSource(strings = { "hello", "world", "I love J.N." }) // source for the parameters
void words(String candidate) {
    Assertions.assertTrue(candidate.equals("hello"));
}      
       #+END_SRC
      :results:
 words(String) ✔
 ├─ [1] candidate=hello ✔
 ├─ [2] candidate=world X
 └─ [3] candidate=I love J.N. X
      :end:

      Such methods are inherited unless they are overridden.

****** On Methods implementing Autocloseable
     
       Recall the following point. Might be useful at some point in
       the future.
       
       #+BEGIN_SRC java :results output drawer :classname 
       Arguments that implement java.lang.AutoCloseable (or
       java.io.Closeable which extends java.lang.AutoCloseable) will
       be automatically closed after @AfterEach methods and
       AfterEachCallback extensions have been called for the current
       parameterized test invocation.  

       To prevent this from happening, set the autoCloseArguments
       attribute in @ParameterizedTest to false. Specifically, if an
       argument that implements AutoCloseable is reused for multiple
       invocations of the same parameterized test method, you must
       annotate the method with @ParameterizedTest(autoCloseArguments
       = false) to ensure that the argument is not closed between
       invocations. 
       #+END_SRC                

****** On the possible sources for parameterized methods 

       Recall that there are various sources for parametrized methods that
       you can use when working with these.

       Essentially you can work with the follwoing:

       - =@ValueSource=

	 this is basically the one in the example above. It is the
         trivial and most basic one. You pass primitives to it. 

       - Null and Empty Sources

	 So essentially these are tags to pass /empty and null values/
         as paramters. Play around with them in the next step.

	 =@NullSource=: provides a single null argument to the
         annotated method.

	 =@EmptySource=: provides a single empty argument to the
         annotated =@ParameterizedTest= method for parameters of the
         following types: java.lang.String, java.util.List,
         java.util.Set, java.util.Map, primitive arrays (e.g., int[],
         char[][], etc.), object arrays (e.g.,String[], Integer[][],
         etc.).
	 
       - =@EnumSource=

	 With this you can use Enum constants.

	 #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@EnumSource(names = { "DAYS", "HOURS" }) // names of the constant you will pass. 
void testWithEnumSourceInclude(ChronoUnit unit) { // ChronoUnit is the enum you will use
    assertTrue(EnumSet.of(ChronoUnit.DAYS, ChronoUnit.HOURS).contains(unit));
}
	 #+END_SRC

	 You can even use exclude logic or regex

	 #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@EnumSource(mode = EXCLUDE, names = { "ERAS", "FOREVER" })
void testWithEnumSourceExclude(ChronoUnit unit) {
    assertFalse(EnumSet.of(ChronoUnit.ERAS, ChronoUnit.FOREVER).contains(unit));
}
@ParameterizedTest
@EnumSource(mode = MATCH_ALL, names = "^.*DAYS$")
void testWithEnumSourceRegex(ChronoUnit unit) {
    assertTrue(unit.name().endsWith("DAYS"));
}
	 #+END_SRC
	 
       - =@MethodSource=

	 @MethodSource allows you to refer to one or more /factory
         methods/ of the test class or external classes.

	 These will supply the input of interest.

	 Each *factory method* must generate a stream of arguments, and
         each set of arguments within the stream will be provided as
         the physical arguments for individual invocations of the
         annotated @ParameterizedTest method.

	 #+BEGIN_SRC java :results output drawer :classname 

// Single Parameter Example //
@ParameterizedTest
@MethodSource("stringProvider")
void testWithExplicitLocalMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> stringProvider() {
    return Stream.of("apple", "banana");
}

// Multiple Paramter Parameter Example //
@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(5, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        arguments("apple", 1, Arrays.asList("a", "b")), // note how you have to return an argument object
        arguments("lemon", 2, Arrays.asList("x", "y"))
    );
}
	 #+END_SRC	 	 

	 recall that Argument Inteface. It is something specific in
         Junit. See [[https://junit.org/junit5/docs/5.0.0/api/org/junit/jupiter/params/provider/Arguments.html][official docu]]. In any case just take it as given
         and understand it in the way as used above.

	 Note that you can as well work by calling a factory reference.

	 #+BEGIN_SRC java :results output drawer :classname 
package example;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

class ExternalMethodSourceDemo {

    @ParameterizedTest
    @MethodSource("example.StringsProviders#tinyStrings")
    void testWithExternalMethodSource(String tinyString) {
        // test with tiny string
    }
}

class StringsProviders {

    static Stream<String> tinyStrings() {
        return Stream.of(".", "oo", "OOO");
    }
}
	 #+END_SRC

       - =@CsvSource=:

	 /@CsvSource/ allows you to express argument lists as
         comma-separated values.

	 So basically you pass your csv as comma separated values
         there.

	 This might be good for writing tests checking and your
         implemented parsers.

	 Example

	 #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@CsvSource({
    "apple,         1",
    "banana,        2",
    "'lemon, lime', 0xF1", // note single quote ' for quote character.
    "strawberry,    700_000"
})
void testWithCsvSource(String fruit, int rank) {
    assertNotNull(fruit);
    assertNotEquals(0, rank);
}
	 #+END_SRC

	 An empty, quoted value ('') results in an empty String unless
         the emptyValue attribute is set; whereas, an entirely empty
         value is interpreted as a null reference.

	 Note as well the following parameters that you can set

	 #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@CsvSource(delimiter = '|', quoteCharacter = '"', textBlock = """
    #-----------------------------
    #    FRUIT     |     RANK
    #-----------------------------
         apple     |      1
    #-----------------------------
         banana    |      2
    #-----------------------------
      "lemon lime" |     0xF1
    #-----------------------------
       strawberry  |    700_000
    #-----------------------------
    """)
void testWithCsvSource(String fruit, int rank) {
    // ...
}
	 #+END_SRC

	 - =@CsvFileSource=

	   This lets you use CSV files from the classpath or the local
           file system.

	   That is very good to know. Like this you can perform all of
           the necessary tests for your different parsers and you can
           see immediately if you did break anything before building
           or even deploying into UAT etc.

	   Check the following examples

	   #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@CsvFileSource(files = "src/test/resources/two-column.csv", numLinesToSkip = 1)
void testWithCsvFileSourceFromFile(String country, int reference) {
    assertNotNull(country);
    assertNotEquals(0, reference);
}

@ParameterizedTest(name = "[{index}] {arguments}")
@CsvFileSource(resources = "/two-column.csv", useHeadersInDisplayName = true)
void testWithCsvFileSourceAndHeaders(String country, int reference) {
    assertNotNull(country);
    assertNotEquals(0, reference);
}
	   #+END_SRC

	 - =@ArgumentsSource=

	   Not really understanding the point of this to this stage	   

	   #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}
public class MyArgumentsProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("apple", "banana").map(Arguments::of);
    }
}

	   #+END_SRC


****** On implicit argument passsing

       Note the following example. There are a couple of defaults. 

       I.e. for instance the below uses the concept of /factory
       method/ and /factory classes/ mentioned before.

       So you can see for instance that in the below there is a
       /factory method/ fromTitle. Note that it is =static= and
       non-private. 

       Note now the following *fallback* mechanism:

       #+begin_quote
       See blow you have a string parameter that you pass with
       ValueSource.

       Then the idea is:

       for automatic conversion from a String to a given target type
       if the target type declares /exactly one/ suitable factory method
       or a factory constructor as defined below - see that it has the
       String argument and there is a match in this sense -. 
       #+end_quote

       #+BEGIN_SRC java :results output drawer :classname
@ParameterizedTest
@ValueSource(strings = "42 Cats")
void testWithImplicitFallbackArgumentConversion(Book book) {
    assertEquals("42 Cats", book.getTitle());
}
public class Book {

    private final String title;

    private Book(String title) {
        this.title = title;
    }

    public static Book fromTitle(String title) {
        return new Book(title);
    }

    public String getTitle() {
        return this.title;
    }
} 
       #+END_SRC

****** On Explicit Argument Passing

       Note that the above can as well be stated in a more torough and
       complete way as follows:
       
       #+BEGIN_SRC java :results output drawer :classname 
@ParameterizedTest
@EnumSource(ChronoUnit.class)
void testWithExplicitArgumentConversion(
        @ConvertWith(ToStringArgumentConverter.class) String argument) {

    assertNotNull(ChronoUnit.valueOf(argument));
}
public class ToStringArgumentConverter extends SimpleArgumentConverter {

    @Override
    protected Object convert(Object source, Class<?> targetType) {
        assertEquals(String.class, targetType, "Can only convert to String");
        if (source instanceof Enum<?>) {
            return ((Enum<?>) source).name();
        }
        return String.valueOf(source);
    }
}
       #+END_SRC

              
      
****** TODO double check when you have time - could not understand when reading

       Note that there is quite a few things that you will need to
       make sense of when you have time.

       In the notes they talk about =@TestImplementation= etc. also in
       the context of Parameterized tests.

       Moreover, they talk about the ordering of the parameters and
       of some =@AggregateWith= annotator. Double check the entire
       thing when you have time.

****** TODO understand better this and Mockito

       - difference with Mockito... might seem trivial to the user
         that has a strong clue about it. I do not have one so we will
         see. How do you supply things there that are not working
         here? 

	 what is missing etc.?

****** TODO better understand the @ArgumentsSource method


**** Tagging

***** @Tag

      Test classes and methods can be tagged via the @Tag
      annotation. Those tags can later be used to filter test discovery
      and execution.
     
      Such annotations are inherited at the class level but not at the
      method level. 


**** Naming and UI Style Annotations

     This are used for setting the naming of your test methods.

     You can set naming through such annotators and organize
     everything in such a way the standard output of running the
     tests. That will be required in order to keep order when things
     will grow large.

     Consider the following good example:

     #+BEGIN_SRC java :results output drawer :classname DisplayNameGeneratorDemo
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.IndicativeSentencesGeneration;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {
        }

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {
        }

    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }

    }

}
     #+END_SRC

     #+RESULTS:
     :results:
+-- DisplayNameGeneratorDemo [OK]
  +-- A year is not supported [OK]
  | +-- A negative value for year is not supported by the leap year computation. [OK]
  | | +-- For example, year -1 is not supported. [OK]
  | | '-- For example, year -4 is not supported. [OK]
  | '-- if it is zero() [OK]
  '-- A year is a leap year [OK]
    +-- A year is a leap year -> if it is divisible by 4 but not by 100. [OK]
    '-- A year is a leap year -> if it is one of the following years. [OK]
      +-- Year 2016 is a leap year. [OK]
      +-- Year 2020 is a leap year. [OK]
      '-- Year 2048 is a leap year. [OK]     
     :end:

     So based on the above you can easily infer the following rules.

***** Index

     - [[*@DisplayName][@DisplayName]]
     - [[*@DisplayNameGeneration][@DisplayNameGeneration]]
     - [[*@IndicativeSentencesGeneration][@IndicativeSentencesGeneration]]
     - [[*@Nested][@Nested]]


***** @DisplayName

      Declares a custom display name for the test class or test method. Such
      annotations are not inherited.

      Note that if such an annotator is not used you will work with
      the default method name. See for instance the method
      =if_it_is_zero= and the result as above:

      #+begin_quote
      if it is zero() [OK]
      #+end_quote
 
***** @DisplayNameGeneration

      Declares a custom display name generator for the test class. Such
      annotations are inherited.

      Sets some general standards for the naming to be returned by the
      methods. Nothing too fancy above but see again how the method
      =if_it_is_zero= with underscores was replaced with spaced in
      the output in the example above.
       
***** @IndicativeSentencesGeneration

      Sets some standards for displaying the hierarchy. I think this
      is especially important / might be especially important.

***** @Nested

      This basically creates the hieararchical structure that you will
      ultimately see on your GUI. It will help to structure your tests
      in a meaningful way in this sense.
      
      Denotes that the annotated class is a non-static nested test
      class. @BeforeAll and @AfterAll methods cannot be used directly in a
      @Nested test class unless the "per-class" test instance lifecycle is
      used. Such annotations are not inherited.


**** LifeCycle Annotations

***** Index

      - [[*Tests Lifecycle][Tests Lifecycle]]
      - [[*@BeforeEach][@BeforeEach]]
      - [[*@AfterEach][@AfterEach]]
      - [[*@BeforeAll][@BeforeAll]]
      - [[*@AfterAll][@AfterAll]]
      - [[*@Disabled][@Disabled]]
      - [[*@TestInstance][@TestInstance]]
      - [[*@TestMethodOrder][@TestMethodOrder]]
      - [[*@TestClassOrder][@TestClassOrder]]

***** Tests Lifecycle

      In order to proper understand testing lifecycle you can check at
      the following 101 test-example.

      Next you have all of the basics standard types of tests.

      Basic to understand then how that works. Trivial.

      #+BEGIN_SRC java :results output drawer :classname 
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }

}
      #+END_SRC
     
***** @BeforeEach

      Denotes that the annotated method should be executed before each
      @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in
      the current class; analogous to JUnit 4’s @Before. Such methods are
      inherited unless they are overridden. 

***** @AfterEach

      Denotes that the annotated method should be executed after each @Test,
      @RepeatedTest, @ParameterizedTest, or @TestFactory method in the
      current class; analogous to JUnit 4’s @After. Such methods are
      inherited unless they are overridden. 

***** @BeforeAll

      Denotes that the annotated method should be executed before all @Test,
      @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the
      current class; analogous to JUnit 4’s @BeforeClass. Such methods are
      inherited (unless they are hidden or overridden) and must be static
      (unless the "per-class" test instance lifecycle is used). 

***** @AfterAll

      Denotes that the annotated method should be executed after all @Test,
      @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the
      current class; analogous to JUnit 4’s @AfterClass. Such methods are
      inherited (unless they are hidden or overridden) and must be static
      (unless the "per-class" test instance lifecycle is used). 

***** @Disabled

      Simple tag to disable a particular test.

      Say for instance

      #+BEGIN_SRC java :results output drawer :classname 
@Disabled("Disabled until bug #99 has been fixed")
      #+END_SRC

      Note that there are some extensions in order to condtionally
      disable. You can check at it online on the official
      documentation. There you have the correct reference.                  


***** TODO @TestInstance

      Used to configure the test instance lifecycle for the annotated test
      class. Such annotations are inherited.

      This is more interesting for =integration= and =functional=
      tests. Basically you can specify there the lifecycle of the
      thing.

      Study it later at a later time-point.

***** TODO @TestMethodOrder

      Used as well to

      Used to configure the test method execution order for the annotated
      test class; similar to JUnit 4’s @FixMethodOrder. Such annotations are
      inherited. 
 
      
***** TODO @TestClassOrder

      Used to configure the test class execution order for @Nested test
      classes in the annotated test class. Such annotations are inherited.


**** Templates - @TestTemplate

     It is essentially possible as well to write template tests. 

     These will not be run in the normal way but will rather be
     invoked by =TestTemplateInvocationContextProvider= extension.

     So have to understand that better.

     Note in any case that:

     #+begin_quote
     Each invocation of a test template method behaves like the
     execution of a regular @Test method with full support for the
     same lifecycle callbacks and extensions. 
     #+end_quote

***** TODO understand TestTemplateInvocationContextProvider better

      check [[https://junit.org/junit5/docs/current/user-guide/#extensions-test-templates][this]] in this sense.

 
**** Dynamic Testing

     See the following to understand these:

     #+begin_quote
     =@Test=: These test cases are static in the sense that they are
     /fully specified at compile time/, and their behavior cannot be
     changed by anything happening at runtime. 
     Assumptions provide a basic form of dynamic behavior but are
     intentionally rather *limited in their expressiveness*. 
     #+end_quote

     In order to enrich the testing environment you have now the
     introction of =dynamic test= in Junit.

     These is a kind of test that is generated *at runtime* by a factory
     method that is annotated with [[*@TestFactory][@TestFactory]].

***** Index

      - [[*@TestFactory][@TestFactory]]
      - [[*Examples][Examples]]

***** @TestFactory

      Denotes that a *method is a test factory* for dynamic tests. 

      So essentially the idea is similar to the one of TestTemplates
      in the sense that methods annotated as such are not standard
      test case. 

      #+begin_quote
      @TestFactory method is not itself a test case but rather a
      factory for test cases. 
      #+end_quote

      Technically speaking, a =@TestFactory= method must return a
      single DynamicNode or a Stream, Collection, Iterable, Iterator,
      or array of DynamicNode instances.

      Note that =DynamicContainer= and =DynamicTest= are subclasses of
      =DynamicNode=. 

      Understand now the two:

      - =DynamicContainer= instances are composed of a display name and
        a list of dynamic child nodes, enabling the creation of
        arbitrarily nested hierarchies of dynamic nodes. 

      - =DynamicTest= instances will be executed lazily, enabling
        dynamic and even non-deterministic generation of test cases. 

      Note as well the following: 

      Any Stream returned by a @TestFactory /will be properly closed/
      by calling ~stream.close()~, making it safe to use a resource
      such as Files.lines().

      *Important* is as well to understand the following:

      #+begin_quote
      A DynamicTest is a test case generated at runtime. It is
      composed of a display name and an Executable. *Executable* is a
      =@FunctionalInterface= which means that the implementations of
      dynamic tests can be provided as *lambda expressions* or *method
      references*. 
      #+end_quote

      So that is it. See the examples in the next section. You see in
      fact that you specify lambda functions in order to interact with
      that functional interface.
      
      One last *very important remark*:

      #+begin_quote
!!!
The execution lifecycle of a dynamic test is quite different than it
is for a standard @Test case. Specifically, there are /no lifecycle
callbacks/ for individual dynamic tests. This means that @BeforeEach
and @AfterEach methods and their corresponding extension callbacks are
executed for the @TestFactory method but not for each dynamic test.  
!!!
      #+end_quote

      Finally, note that such methods are inherited unless they are
      overridden. 

***** Examples

      Try to go with the following:

       #+BEGIN_SRC java :results output drawer :classname 
import static example.util.StringUtils.isPalindrome;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;
import static org.junit.jupiter.api.Named.named;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import example.util.Calculator;

import org.junit.jupiter.api.DynamicNode;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Named;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.function.ThrowingConsumer;

class DynamicTestsDemo {

    private final Calculator calculator = new Calculator();

    // This will result in a JUnitException!
    // if you check at the error - is says that @TestFactory must return a single 
    // one of 
    @TestFactory
    List<String> dynamicTestsWithInvalidReturnType() {
        return Arrays.asList("Hello"); 
    }

    // So se how it reference a dynamicTest. So that is fine. 
    // note the return type. Collection here.
    // note that there is nothing dynamic in here. it is just to illustrate how it works with
    // the return types. 
    // Note that usually the dynamic compoenent would come from performing the test in a dynamic
    // way by dynamically testing the values within the collection.
    @TestFactory
    Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("2nd dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        );
    }

    // Note the return type in here: Iterable. 
    // So you see that if you return an Object such an array that is both a Collection and
    // an Iterable you are free to specify the two return types.
    @TestFactory
    Iterable<DynamicTest> dynamicTestsFromIterable() {
        return Arrays.asList(
            dynamicTest("3rd dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("4th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        );
    }

    // Again nothing fancy - just here for completeness in order to see possible reutrn types
    // An Iterable is a simple representation of a series of elements that can be iterated over. 
    // It does not have any iteration state such as a "current element". Instead, 
    // it has one method that produces an Iterator.

    // An Iterator is the object with iteration state. 
    // It lets you check if it has more elements using hasNext() 
    // and move to the next element (if any) using next(). 
    @TestFactory
    Iterator<DynamicTest> dynamicTestsFromIterator() {
        return Arrays.asList(
            dynamicTest("5th dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("6th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        ).iterator();
    }

    
    @TestFactory
    DynamicTest[] dynamicTestsFromArray() {
        return new DynamicTest[] {
            dynamicTest("7th dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("8th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        };
    }

    // Here you actually see the dynamic component of the tests. 
    // Note not everything is fixed at compile time. 
    // At runtime actually the tests execute by passing the stream.
    // A stream is also returned.
    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStream() {
        return Stream.of("racecar", "radar", "mom", "dad")
            .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));
    }

    // See the following example of dynamic behaviour with a collection result.
    // so you see that the returning method is the key.
    // usually you do not work with such conversion. Not good practice. 
    // The practice is to have the return type as the object type you pass to be dynamically tested.   
    @TestFactory
    Collection<DynamicTest> dynamicTestsFromStreamtoCollection() {
        return Stream.of("racecar", "radar", "mom", "dad")
            .map(text -> dynamicTest(text, () -> assertTrue(text.equals("hello"))))
            .collect(Collectors.toList());
    }


    @TestFactory
    Stream<DynamicTest> dynamicTestsFromIntStream() {
        // Generates tests for the first 10 even integers.
        return IntStream.iterate(0, n -> n + 2).limit(10)
            .mapToObj(n -> dynamicTest("test" + n, () -> assertTrue(n % 2 == 0)));
    }

    @TestFactory
    Stream<DynamicTest> generateRandomNumberOfTestsFromIterator() {

        // Generates random positive integers between 0 and 100 until
        // a number evenly divisible by 7 is encountered.
        Iterator<Integer> inputGenerator = new Iterator<Integer>() {

            Random random = new Random();
            int current;

            @Override
            public boolean hasNext() {
                current = random.nextInt(100);
                return current % 7 != 0;
            }

            @Override
            public Integer next() {
                return current;
            }
        };

        // Generates display names like: input:5, input:37, input:85, etc.
        Function<Integer, String> displayNameGenerator = (input) -> "input:" + input;

        // Executes tests based on the current input value.
        ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
    }


    /** Lovely to see such stream of tests. Very nice way to program in a way 
     *  where it is easy to keep the overview. Nice.
     */
    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStreamFactoryMethod() {
        // Stream of palindromes to check
        Stream<String> inputStream = Stream.of("racecar", "radar", "mom", "dad");

        // Generates display names like: racecar is a palindrome
        Function<String, String> displayNameGenerator = text -> text + " is a palindrome";

        // Executes tests based on the current input value.
        ThrowingConsumer<String> testExecutor = text -> assertTrue(isPalindrome(text));

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputStream, displayNameGenerator, testExecutor);
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStreamFactoryMethodWithNames() {
        // Stream of palindromes to check
        Stream<Named<String>> inputStream = Stream.of(
                named("racecar is a palindrome", "racecar"),
                named("radar is also a palindrome", "radar"),
                named("mom also seems to be a palindrome", "mom"),
                named("dad is yet another palindrome", "dad")
            );

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputStream,
            text -> assertTrue(isPalindrome(text)));
    }


    /** See Dynamic containers here. 
    *   This is nice. Basically each time you nest a container is one level
    *   lower in the call hieararchy. 
    *   The first string argument is the title of the particular hierarchical name 
    *   of the test. 
    */
    @TestFactory
    Stream<DynamicNode> dynamicTestsWithContainers() {
        return Stream.of("A", "B", "C")
            .map(input -> dynamicContainer("Container " + input, Stream.of(
                dynamicTest("not null", () -> assertNotNull(input)),
                dynamicContainer("properties", Stream.of(
                    dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
                    dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
                ))
            )));
    }

    @TestFactory
    DynamicNode dynamicNodeSingleTest() {
        return dynamicTest("'pop' is a palindrome", () -> assertTrue(isPalindrome("pop")));
    }

    @TestFactory
    DynamicNode dynamicNodeSingleContainer() {
        return dynamicContainer("palindromes",
            Stream.of("racecar", "radar", "mom", "dad")
                .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text)))
        ));
    }

}
       #+END_SRC

       Example of dynamic Node in a picture. Run it on my Eclipse
       together a couple of others tests in order to understand the
       entire thingy.
       
#+begin_export html
 <img src="../../images/Screenshot 2022-01-31 140121.png" class="center">
#+end_export

**** URI

     Note that this might particularly be interesting for working with
     dynamic Tests or Test-templates.

     The idea is that you can reference then particular tests that you
     want to use through URI.

     The idea is essentially the following:

     The JUnit Platform provides TestSource, a representation of the
     source of a test or container used to navigate to its location by
     IDEs and build tools. 

     The TestSource for a dynamic test or dynamic container can be
     constructed from a java.net.URI which can be supplied via the
     DynamicTest.dynamicTest(String, URI, Executable) or
     DynamicContainer.dynamicContainer(String, URI, Stream) factory method,
     respectively. The URI will be converted to one of the following
     TestSource implementations.
     

**** Timeouts

***** @Timeout

      Used to fail a test, test factory, test template, or lifecycle method
      if its execution exceeds a given duration. 

      Note that you have as well the assertion timeout option - see
      the section [[*AssertionTypes][AssertionTypes]].

      So that will be as well a design choice to understand which one
      of the two you should use.

      Check at the following quote:

      #+begin_quote
Contrary to the assertTimeoutPreemptively() assertion, the execution
of the annotated method proceeds in the main thread of the test. If
the timeout is exceeded, the main thread is interrupted from another
thread. This is done to ensure interoperability with frameworks such
as Spring that make use of mechanisms that are sensitive to the
currently running thread — for example, ThreadLocal transaction
management. - Double check this.
      #+end_quote

      So I guess that there would be a slight difference in the
      logic. 

      An example is the following:

#+BEGIN_SRC java :results output drawer :classname 
class TimeoutDemo {

    @BeforeEach
    @Timeout(5)
    void setUp() {
        // fails if execution time exceeds 5 seconds
    }

    @Test
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void failsIfExecutionTimeExceeds100Milliseconds() {
        // fails if execution time exceeds 100 milliseconds
    }

}
#+END_SRC

      Such annotations are inherited.

***** TODO understand better the difference with Assertion Kind of errors. 
     

**** TODO check how to combine the annoations above into meta-annotations

     see chapter 2.1 in this sense. 

     have as well to understand the benefit of properly combining
     annotations. 

     
**** Parallel Execution

     This might be useful in order to keep a fast and nimble execution
     of your tests.

     Understand the following:

     #+begin_quote
By *default*, JUnit Jupiter tests are *run sequentially* in a single
thread. 

Running tests in parallel — for example, to speed up execution — is
available as an opt-in feature since version 5.3. To enable parallel
execution, set the junit.jupiter.execution.parallel.enabled
configuration parameter to true — for example, in
=junit-platform.properties=.


This property is /only the first step/ required to execute tests in
parallel. If enabled, test classes and methods will /still be executed
sequentially by default/. Whether or not a node in the test tree is
executed concurrently is controlled by its execution mode. The
following two modes are available:


- SAME_THREAD: execution in the same thread as the parent.

- CONCURRENT: Execute concurrently unless a resource lock forces
  execution in the same thread. 
     #+end_quote

     Note now that with the understanding above you have essentially
     two options in order to implment the parallel execution strategy.

     + Method 1 - set it at global level:

       #+BEGIN_SRC java :results output drawer :classname 
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
       #+END_SRC

       Note here that: most of your test classes can be *run in
       parallel* without any synchronization but you have some test
       classes that need to run in isolation, you can mark the latter
       with the @Isolated annotation. 

     + Method 2 - set it for sepcific tests:

       You can use the =@Execution= annotation to change the execution
       mode for the annotated element and its subelements (if any)
       which allows you to activate parallel execution for individual
       test classes, one by one.  

       Example: set - ~@Execution(CONCURRENT)~

     + Method 3 - parallel classes but methods sequentially

       There is also the option to run the tests of methods in the same
       class on a specific thread, while tests across classes are
       executed on separate threads. You can achieve that through the
       following function:

       #+BEGIN_SRC java :results output drawer :classname 
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = same_thread
junit.jupiter.execution.parallel.mode.classes.default = concurrent
       #+END_SRC

     + Method 4 - Classes sequentially while methods within in
       parallel

       So essentially the exact opposite of above.

       #+BEGIN_SRC java :results output drawer :classname 
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
junit.jupiter.execution.parallel.mode.classes.default = same_thread
       #+END_SRC

***** Recall that it is as well possible to set ResourceLocks

      These will be especially important in order to avoid race
      conditions. 

      When access to shared resources is declared using the
      @ResourceLock annotation, the JUnit Jupiter engine uses this
      information to ensure that no conflicting tests are run in
      parallel. 

*** AssertionTypes

    Check in the following all of the different types of possible
    assertion methods - note again in junit package.

    Note that should you want to start to go deeper into the topic
    there is the following statement on the official documentation:

    #+begin_quote
There are times when more power and additional functionality such as
matchers are desired or required. In such cases, the JUnit team
recommends the use of third-party assertion libraries such as =AssertJ,
Hamcrest, Truth=, etc. Developers are therefore free to use the
assertion library of their choice. 
    #+end_quote

    Might want to check at these.

    In any case coming back to our case, see the following script with
    the possible assertions. I especially like the
    *assertionTimeOut*. I never worked with it before but I can
    already picture beautiful use-cases for it. Very neat.

    #+BEGIN_SRC java :results output drawer :classname 
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));

        assertEquals(4, calculator.multiply(2, 2),
		     "The optional failure message is now the last parameter");


	// well the next point is a I wanna be thing. I don't think that compiling a string is such a big issue
	// anyways see the point of lazy evaluation.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
		   + "to avoid constructing complex messages unnecessarily."); 
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and all
        // failures will be reported together.
        assertAll("person",
		  () -> assertEquals("Jane", person.getFirstName()),
		  () -> assertEquals("Doe", person.getLastName())
		  );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
		  () -> {
		      String firstName = person.getFirstName();
		      assertNotNull(firstName);

		      // Executed only if the previous assertion is valid.
		      assertAll("first name",
				() -> assertTrue(firstName.startsWith("J")),
				() -> assertTrue(firstName.endsWith("e"))
				);
		  },
		  () -> {
		      // Grouped assertion, so processed independently
		      // of results of first name assertions.
		      String lastName = person.getLastName();
		      assertNotNull(lastName);

		      // Executed only if the previous assertion is valid.
		      assertAll("last name",
				() -> assertTrue(lastName.startsWith("D")),
				() -> assertTrue(lastName.endsWith("e"))
				);
		  }
		  );
    }

    // so note the syntax of assertThrows:
    // first argument: exception that should result
    // second arg: the actual code that should throw the exception.
    // third arg: message – If the executable code does not throw
    //            any exception, this message will be printed along with FAIL result 
    // so basically use it in order to see if you get the error as desired. 
    @Test 
    void exceptionTesting() {
        Exception exception = assertThrows(ArithmeticException.class, () ->
					   calculator.divide(1, 0)); 
	
        assertEquals("/ by zero", exception.getMessage());
    }

    // this is a very nice one.
    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
		// Perform task that takes less than 2 minutes.
	    });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
		return "a result";
	    });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
		// Simulate task that takes more than 10 ms.
		Thread.sleep(100);
	    });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
		// Simulate task that takes more than 10 ms.
		new CountDownLatch(1).await();
	    });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
    #+END_SRC

*** Assumptions

    Ok... that is as well something I never came across
    before. Interesting to know of its existence.

    The idea is the following, if you include an /assumption/
    statement in a test, if the assumption is met then you run the
    rest of the test otherwise you will abort the test *without
    throwing an error* for it.

    It is essentially and if condition that has to hold in order to
    run the test.

    Then see the following two options (=assumeTrue= and =assumeThat=)

    #+BEGIN_SRC java :results output drawer :classname 
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV"))); // note that it
						       // is a boolean
						       // condition. It
						       // is not a
						       // function of
						       // multiple
						       // parameters.
        // remainder of test
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
        assumeTrue("DEV".equals(System.getenv("ENV")),
            () -> "Aborting test: not on developer workstation"); // with message
        // remainder of test
    }

    // note that you could do the above in two different tests but
    // good to know the compact option.
    @Test
    void testInAllEnvironments() {
        assumingThat("CI".equals(System.getenv("ENV")),
            () -> {
                // perform these assertions only on the CI server
                assertEquals(2, calculator.divide(4, 2));
            });

        // perform these assertions in all environments
        assertEquals(42, calculator.multiply(6, 7));
    }

}
    #+END_SRC        


** The bigger picture in unit-testing

   Ok so basically the part above deals on how to write the unit-tests
   themselves. 

   That is the easy bit. You have now your basic logic in order to
   write your testing suits. 

   The issue is that sometimes you have one of the following
   circumstances:

   - the object supplies /non-deterministic results/ (e.g. the current
     time or the current temperature); 

   - it has states that are difficult to create or reproduce (e.g. a
     network error); 

   - it is slow (e.g. a complete database, which would have to be
     initialized before the test); 

   - it does not yet exist or may change behavior;

   - it would have to include information and methods exclusively for
     testing purposes (and not for its actual task). 

   Then you understand that it is not that trivial to /test a bit of
   code/. What you are interesting into is testing the application
   logic of your code. Does it fulfill the goal? 

   Though, what you will ultimately have is in most of the cases above
   a *dependency* that makes testing the application bit
   difficult/annoying. In this case the idea is to rely on mock
   objects and other practices addressed in this section that will
   make it possible for you to properly isolate the logic of your code
   and test this in a shielded environment.

   So the concept that you have to dominate are now the following:

   - =Stub= : an implementation that returns a hard-coded value for
     purposes of testing is known as a stub. 

   - =Mocks=: A mock is a test construct that provides emulated
     behavior and also does the job of *verifying whether or not it
     received all the parameters expected*.

   - =Fakes=:
   

** Stub 

   So basic example of a stub is the following as from the book
   /Pragmatic Unit Testing/.

   Say you have an http response that you will need to use in a bit of
   your code. Then you can do the following:

   #+BEGIN_SRC java :results output drawer :classname 
// See the following object creation
Http http = new Http() {
	@Override
	public String get(String url) throws IOException {
	    return "{\"address\":{"
		+ "\"house_number\":\"324\","
		+ "\"road\":\"North Tejon Street\","
		// ...
		}};
   #+END_SRC

   Then you can use that stub by invoking the object from the
   anonymous inner class:

   #+BEGIN_SRC java :results output drawer :classname 
public Address retrieve(double latitude, double longitude)
throws IOException, ParseException {
String parms = String.format("lat=%.6flon=%.6f", latitude, longitude);
 String response = http.get(
 "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&"
 + parms); // here you have your stub
JSONObject obj = (JSONObject)new JSONParser().parse(response);
// ...
}
   #+END_SRC

   You can then continue with your test in the most classical way. 

   I.e. with the two above methods you would have something as
   follows:

   #+BEGIN_SRC java :results output drawer :classname 
import java.io.*;
import org.json.simple.parser.*;
import org.junit.*;
import util.*;
import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
public class AddressRetrieverTest {
    @Test
    public void answersAppropriateAddressForValidCoordinates()
	throws IOException, ParseException {
	Http http = (String url) ->
	    "{\"address\":{"
	    + "\"house_number\":\"324\","
	    + "\"road\":\"North Tejon Street\","
	    + "\"city\":\"Colorado Springs\","
	    + "\"state\":\"Colorado\","
	    + "\"postcode\":\"80903\","
	    + "\"country_code\":\"us\"}"
	    + "}";
	AddressRetriever retriever = new AddressRetriever(http);
	Address address = retriever.retrieve(38.0,-104.0);
	assertThat(address.houseNumber, equalTo("324"));
	assertThat(address.road, equalTo("North Tejon Street"));
	assertThat(address.city, equalTo("Colorado Springs"));
	assertThat(address.state, equalTo("Colorado"));
	assertThat(address.zip, equalTo("80903"));
    }
}
   #+END_SRC

   so you see that you pass the =http= dependency to the
   =AddressRetriever= where your stub will be declared.
   
   So note now that it is up to you to specify how you pass that exact
   dependency. You can use as well spring and the way you pass
   dependencies over there.             

*** Side note - why is this a stub?

    This because you use the object from the anonymous class above in
    order to get your hard-coded string.   I.e. you are actually
    calling the ~get~ method.


** Mocks - Mockito

   Basically the fundamental idea of the framework is the one of
   giving the possibility to =mock= the /dependencies/.

   A mock object is a dummy implementation for an interface or a
   class. It allows to /define the output of certain method calls/. They
   typically record the interaction with the system and tests can
   validate that. 

   So basically that is the idea. You have a dependency and use
   Mockito to feed the dependency record/object.

   This is in fact interesting and important. You can create
   *mock-objects* that you will use in your tests. So understand that
   this is not simply for feeding values or calling a single
   method. It is creating an /entire mock-object/.

*** Index

    - [[*What is a mock object][What is a mock object]]
    - [[*Creating a mock() object and verifying the parameters received][Creating a mock() object and verifying the parameters received]]
    - [[*Dependency Injection Tool][Dependency Injection Tool]]
    - [[*@Spy][@Spy]]
    - [[*@Capture][@Capture]]
    - [[*Resources used for the tutorial][Resources used for the tutorial]]

*** What is a mock object

    In object-oriented programming, mock objects are /simulated
    objects/ that mimic the behavior of real objects in controlled
    ways, most often as part of a software testing initiative. A
    programmer typically creates a mock object to test the behavior of
    some other object, in much the same way that a car designer uses a
    crash test dummy to simulate the dynamic behavior of a human in
    vehicle impacts. The technique is also applicable in generic
    programming.

*** Creating a mock() object and verifying the parameters received
    
    In order to create a mock object you can do the following - as in
    the example:

    #+BEGIN_SRC java :results output drawer :classname 
import static org.mockito.Mockito.*;

public class AddressRetrieverTest {
    @Test
    public void answersAppropriateAddressForValidCoordinates()
	throws IOException, ParseException {
	Http http = mock(Http.class);
	when(http.get(contains("lat=38.000000&lon=-104.000000"))).thenReturn(
									     "{\"address\":{"
									     + "\"house_number\":\"324\","
									     // ...
									     + "}");
	AddressRetriever retriever = new AddressRetriever(http);
	Address address = retriever.retrieve(38.0,-104.0); // parameters
							   // you pass
							   // you are
							   // testing.
	assertThat(address.houseNumber, equalTo("324"));
	// ...
    }

    #+END_SRC

    Then understand the following:

    - first you understand the mock-object from the Http.class.

    - then you verify the parameters: ~when(contains...)~

    - finally you return the stub values.

    Note now that the =http.get= method does not has the argument
    above. Where do you pass this exactly? Have to double check. Not
    that trivial. It means that the call of the get method providing
    the argument to it is done somewhere else.

    When a call to the http method =get()= is made with a parameter
    containing the string "lat=38.000000&lon=- 104.000000", then
    return the hardcoded JSON string. 

*** Dependency Injection Tool

    Passing a mock to a target class using a constructor is one
    technique. It requires a change to the interface and exposes a
    *private detail* to another class in the production code. Not a
    great deal, but you can do better by using a /dependency injection
    (DI)/ tool.

    However, not that Mockito has its own dependency injection tool:

    #+BEGIN_SRC java :results output drawer :classname 
public class AddressRetrieverTest {
    @Mock private Http http;  // here you specify the mock object to
			      // be synthetized.
    @InjectMocks private AddressRetriever retriever;  // dependency
						      // injection. I.e. you
						      // tell that
						      // your mock
						      // should be
						      // injected in
						      // here.
    @Before
    public void createRetriever() {
	retriever = new AddressRetriever();
	MockitoAnnotations.initMocks(this);
    }

    @Test
    public void answersAppropriateAddressForValidCoordinates()
	throws IOException, ParseException {
	when(http.get(contains("lat=38.000000&lon=-104.000000")))
	    .thenReturn("{\"address\":{"
			+ "\"house_number\":\"324\","
			// ...
			)
    }
}
    #+END_SRC
    
    Understand now the following:

    #+BEGIN_SRC java :results output drawer :classname 
    @Before
    public void createRetriever() {
	retriever = new AddressRetriever();
	MockitoAnnotations.initMocks(this);
    }
    #+END_SRC

    So basically you first instantiate a retriever object.

    Then you call MockitoAnnotations.initMocks(this). The =this=
    argument refers to the test class itself. Mockito retrieves any
    @Mock-annotated fields on the test class and synthesizes a mock
    instance for each.  It then retrieves any @InjectMocks-annotated
    fields and injects mock objects into them. 

    This is how things work and how dependency are injected through
    annotators. 

    *Finally note:* the =when= method is not strictly restricted to
    fix-values. You can as well pass methods to it. See for instance
    the following way of getting a value value out of a list.

    #+BEGIN_SRC java :results output drawer :classname 
when(mockList.get(anyInt())).thenReturn("hello");
    #+END_SRC

*** @Spy

    Spies are known as /partially mock objects/. 

    It means spy creates a partial object or a half dummy of the real
    object by stubbing or spying the real ones. 

    In spying, the *real object remains unchanged*, and we just spy some
    specific methods of it. In other words, we take the existing
    (real) object and replace or spy only some of its methods. 

    What this practically means is the following:

#+BEGIN_SRC java :results output drawer :classname 
// Mock 
@Test
public void whenCreateMock_thenCreated() {
    List mockedList = Mockito.mock(ArrayList.class);

    mockedList.add("one");
    Mockito.verify(mockedList).add("one");

    assertEquals(0, mockedList.size()); // will be TRUE. adding an
					// element into the mocked
					// list doesn't actually add
					// anything, it just calls the
					// method with no other
					// side-effects.
}

// Spy
public void whenCreateMock_thenCreated() {
    List spyList = Mockito.spy(ArrayList.class);

    spyList.add("one");
    Mockito.verify(spyList).add("one");

    assertEquals(0, spyList.size());  // will be FALSE. The spy it
				      // will actually call the real
				      // implementation of the add
				      // method and add the element to
				      // the underlying list.
}

#+END_SRC

    When using spy objects, the default behavior of the methods (when
    not stubbed) is the real method behavior. 

    See the following way to use spies:

    #+BEGIN_SRC java :results output drawer :classname 
@Spy
List<String> spyList = new ArrayList<String>(); // Spy

@Test
public void whenUsingTheSpyAnnotation_thenObjectIsSpied() {
    spyList.add("one");
    spyList.add("two");

    Mockito.verify(spyList).add("one");
    Mockito.verify(spyList).add("two");

    assertEquals(2, spyList.size());


    Mockito.doReturn(100).when(spyList).size(); // stubbed value.
    assertEquals(100, spyList.size());
}
    #+END_SRC
    
*** TODO @Capture
    
   
*** Resources used for the tutorial

    - [[https://www.journaldev.com/21816/mockito-tutorial][Resource 1]]

    - [[https://pragprog.com/titles/utj2/pragmatic-unit-testing-in-java-8-with-junit/][Resource 2]]





** Testing in Spring Boot

   Especially important is to understand the testing compoenent of MVC
   as I plan to use this a lot. 

   There basically you have a couple of spring specific tags that you
   use to properly tag and create your test. 

   See the following 101 example from spring in action.


   #+BEGIN_SRC java :results output drawer :classname 
package tacos;
import static org.hamcrest.Matchers.containsString;
import static 
    org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static 
    org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static 
    org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static 
    org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

@RunWith(SpringRunner.class)
@WebMvcTest(HomeController.class)  // this is necessary to make the
				   // HomeController seeable.

public class HomeControllerTest {

    @Autowired
    private MockMvc mockMvc;       // this is the Mock object through
				   // which you will perform the calls
				   // to your endpoints and test them.

    @Test 
    public void testHomePage() throws Exception {    // this is the
						     // test through
						     // the mock
						     // object.
	mockMvc.perform(get("/")) 
	    .andExpect(status().isOk()) 
	    .andExpect(view().name("home")) 
	    .andExpect(content().string(containsString("Welcome to...")));
    }
}
   #+END_SRC

So this is how you can test the actual business logic of your end-points.
