#+BEGIN_COMMENT
.. title: Java Testing
.. slug: java-testing
.. date: 2022-01-27 16:20:12 UTC+01:00
.. tags: java, testing
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So I am starting to deliver some solutions on some minor features on
some applications.

There was quite a bit of work to be done in the last couple of
months. I mean I had to get up and running with Java, reverse engineer
some bit of application, write documentation etc. I am slowly getting
up to speed. I have still quite a few things on my mind and I guess
that to reach the point where I would like to be it will be another
6-12 months but I am moving at a /decent/ speed so that I am not
complaining too much.

The structure and challenges of the job gets clearer everyday so that
is fine - now it is a question of adapting and working strategically
to overcome the various issues.

The next bit that is on the list is about testing. This post deals
with it. I am ready to get up and running with it and start to write
well-covered software. In a further step you can then imagine some
further integration with tools as [[https://en.wikipedia.org/wiki/SonarQube][sonarqube]] etc.

{{{TEASER_END}}}

* Testing 

  So basically I am starting to dig in the testing bit.

  Always recall the essential three kind of tests in the ideal world:

  - unit testing

  - integration testing

  - functional testing

  I will start by writing unit tests for my application. I will then
  maybe go into the other in time.   
  
* Unit Testing
   
*** Set Up

    So essentially I will use the JUnit package for running unit
    tests.

    First of all include it in your gradle dependencies

    #+begin_src gradle
dependencies {

  ...

  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'

  ...
}
    #+end_src

    Then basically you are good to go.

    Note that I work with gradle. Note that there you essentially have
    the default that your tests should lie in the =src/test/java=
    directory.

    So essentially when working in Eclipse you can start by creating a
    source-folder (meaning folder containing source code) respecting
    this convention =src/test/java=.

    Then from there you can go on by creating =JUnit Test= Cases. Note
    that in Eclipse everything is pretty much embedded. So everything
    goes through the UI. In this sense you click on the =src/test/java=
    source file and from there you create a new JUnit test. There you
    have to specify the package you want to work on, say
    =com.zurich.im.b1.feeds.model=.

    Then you can specify the class in that package that you want to
    test. Finally you declare your test file with the following naming
    convention =<MyClass>Test=.

    You are done then, bu as soon as you will manage to fix your issues with
    emacs start to migrate as that is a much more powerful tool.


*** Actually Testing

    This is then straightforward. You can read and refer a bit to the
    [[https://junit.org/junit5/docs/current/user-guide/][following documentation]].

    So first thing you have to understand:

    #+begin_quote
    JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
    #+end_quote

    So what are the three:

    - =JUnit Platform=: it is the actual platform for running your
      tests. This is used by the different clients - be a process from
      your shell, the one embedded in your Eclipse IDE etc.

    - =JUnit Jupiter=: This module includes new programming and
      extension models for writing tests in JUnit 5. You have new
      annotators etc.

    - =JUnit Jupiter=: This is for running JUnit 3 and JUnit 4 based
      tests on the platform.  

    So we will now focus on =JUnit Jupiter= as that is the actually
    coding part for writing your tests. You will then check with the
    time at the rest - if you will check at them at all... just need
    to decide on how to connect to the =JUnit Platform=... for now use
    the Eclipse IDE... there everything is more less embedded. Move
    then to Emacs with time.


*** Test Classes And Method
    
    What are the first-class citizens. 

    - =Test Class=  this is a top-level class, static member class or
      =@Nested= class that contains at least 1 test method.

    - =Test Method= any instance method that is directly annotated or
      meta-annotated with =@Test, @RepeatedTest, @ParameterizedTest,
      @TestFactory, or @TestTemplate=

    - =Lifecycle Method= any method that is directly annotated or
      meta-annotated with =@BeforeAll, @AfterAll, @BeforeEach, or
      @AfterEach=.

    So that is nothing new. Trivial I would say it is just setting
    naming conv.

    Note that =Test Method= and =Lifecycle Method= does not have to
    return any value.

    The only *exception* are =@TestFactory= methods where you are
    required to return a value.


*** JUnit Jupiter

    Basically in order to understand well how to write tests in Java
    understand on the one hand the following annotators through which
    it is possible to specify the general logic of your tests and on
    the other hand the possible assertions treated in the [[*AssertionTypes][next
    section]]. Also recall about [[*Assumptions][Assumptions]].
    
**** @Test

     Denotes that a method is a test method. 

**** @ParameterizedTest

     Denotes that a method is a parameterized test. Such methods are
     inherited unless they are overridden.
 
**** @RepeatedTest

     Denotes that a method is a test template for a repeated test. Such
     methods are inherited unless they are overridden.
     
**** @TestFactory

     Denotes that a method is a test factory for dynamic tests. Such
     methods are inherited unless they are overridden. 
 

**** @TestTemplate

     Denotes that a method is a template for test cases designed to be
     invoked multiple times depending on the number of invocation contexts
     returned by the registered providers. Such methods are inherited
     unless they are overridden. 
 
**** @TestClassOrder

     Used to configure the test class execution order for @Nested test
     classes in the annotated test class. Such annotations are inherited.

**** @TestMethodOrder

     Used to configure the test method execution order for the annotated
     test class; similar to JUnit 4’s @FixMethodOrder. Such annotations are
     inherited. 
 

**** @Disabled

     Used to disable a test class or test method; analogous to JUnit 4’s
     @Ignore. Such annotations are not inherited. 

**** @Timeout

     Used to fail a test, test factory, test template, or lifecycle method
     if its execution exceeds a given duration. Such annotations are
     inherited. 

**** @ExtendWith

     Used to register extensions declaratively. Such annotations are
     inherited. 

**** @RegisterExtension

     Used to register extensions programmatically via fields. Such fields
     are inherited unless they are shadowed. 

**** @TempDir

     Used to supply a temporary directory via field injection or parameter
     injection in a lifecycle method or test method; located in the
     org.junit.jupiter.api.io package. 
        




      



     
**** Tagging

***** @Tag

      Test classes and methods can be tagged via the @Tag
      annotation. Those tags can later be used to filter test discovery
      and execution.
     
      Such annotations are inherited at the class level but not at the
      method level. 

     
**** Naming and UI Style Annotations

     This are used for setting the naming of your test methods.

     You can set naming through such annotators and organize
     everything in such a way the standard output of running the
     tests. That will be required in order to keep order when things
     will grow large.

     Consider the following good example:

     #+BEGIN_SRC java :results output drawer :classname DisplayNameGeneratorDemo
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.IndicativeSentencesGeneration;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {
        }

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {
        }

    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }

    }

}
     #+END_SRC

     #+RESULTS:
     :results:
+-- DisplayNameGeneratorDemo [OK]
  +-- A year is not supported [OK]
  | +-- A negative value for year is not supported by the leap year computation. [OK]
  | | +-- For example, year -1 is not supported. [OK]
  | | '-- For example, year -4 is not supported. [OK]
  | '-- if it is zero() [OK]
  '-- A year is a leap year [OK]
    +-- A year is a leap year -> if it is divisible by 4 but not by 100. [OK]
    '-- A year is a leap year -> if it is one of the following years. [OK]
      +-- Year 2016 is a leap year. [OK]
      +-- Year 2020 is a leap year. [OK]
      '-- Year 2048 is a leap year. [OK]     
     :end:

     So based on the above you can easily infer the following rules.

***** @DisplayName

      Declares a custom display name for the test class or test method. Such
      annotations are not inherited.

      Note that if such an annotator is not used you will work with
      the default method name. See for instance the method
      =if_it_is_zero= and the result as above:

      #+begin_quote
      if it is zero() [OK]
      #+end_quote
 
***** @DisplayNameGeneration

      Declares a custom display name generator for the test class. Such
      annotations are inherited.

      Sets some general standards for the naming to be returned by the
      methods. Nothing too fancy above but see again how the method
      =if_it_is_zero= with underscores was replaced with spaced in
      the output in the example above.
       
***** @IndicativeSentencesGeneration

      Sets some standards for displaying the hierarchy. I think this
      is especially important / might be especially important.

***** @Nested

      This basically creates the hieararchical structure that you will
      ultimately see on your GUI. It will help to structure your tests
      in a meaningful way in this sense.
      
      Denotes that the annotated class is a non-static nested test
      class. @BeforeAll and @AfterAll methods cannot be used directly in a
      @Nested test class unless the "per-class" test instance lifecycle is
      used. Such annotations are not inherited.

**** LifeCycle Annotations

***** Tests Lifecycle

      In order to proper understand testing lifecycle you can check at
      the following 101 test-example.

      Next you have all of the basics standard types of tests.

      Basic to understand then how that works. Trivial.

      #+BEGIN_SRC java :results output drawer :classname 
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }

}
      #+END_SRC
     


     
***** @BeforeEach

      Denotes that the annotated method should be executed before each
      @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in
      the current class; analogous to JUnit 4’s @Before. Such methods are
      inherited unless they are overridden. 

***** @AfterEach

      Denotes that the annotated method should be executed after each @Test,
      @RepeatedTest, @ParameterizedTest, or @TestFactory method in the
      current class; analogous to JUnit 4’s @After. Such methods are
      inherited unless they are overridden. 

***** @BeforeAll

      Denotes that the annotated method should be executed before all @Test,
      @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the
      current class; analogous to JUnit 4’s @BeforeClass. Such methods are
      inherited (unless they are hidden or overridden) and must be static
      (unless the "per-class" test instance lifecycle is used). 

***** @AfterAll

      Denotes that the annotated method should be executed after all @Test,
      @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the
      current class; analogous to JUnit 4’s @AfterClass. Such methods are
      inherited (unless they are hidden or overridden) and must be static
      (unless the "per-class" test instance lifecycle is used). 



***** @Disabled

      Simple tag to disable a particular test.

      Say for instance

      #+BEGIN_SRC java :results output drawer :classname 
@Disabled("Disabled until bug #99 has been fixed")
      #+END_SRC

      Note that there are some extensions in order to condtionally
      disable. You can check at it online on the official
      documentation. There you have the correct reference.                  

***** @TestInstance

      Used to configure the test instance lifecycle for the annotated test
      class. Such annotations are inherited.

      This is more interesting for =integration= and =functional=
      tests. Basically you can specify there the lifecycle of the
      thing.

      Study it later at a later time-point.
       

**** TODO check how to combine the annoations above into meta-annotations

     see chapter 2.1 in this sense. 
     
     


*** AssertionTypes

    Check in the following all of the different types of possible
    assertion methods - note again in junit package.

    Note that should you want to start to go deeper into the topic
    there is the following statement on the official documentation:

    #+begin_quote
There are times when more power and additional functionality such as
matchers are desired or required. In such cases, the JUnit team
recommends the use of third-party assertion libraries such as =AssertJ,
Hamcrest, Truth=, etc. Developers are therefore free to use the
assertion library of their choice. 
    #+end_quote

    Might want to check at these.

    In any case coming back to our case, see the following script with
    the possible assertions. I especially like the
    *assertionTimeOut*. I never worked with it before but I can
    already picture beautiful use-cases for it. Very neat.

    #+BEGIN_SRC java :results output drawer :classname 
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));

        assertEquals(4, calculator.multiply(2, 2),
		     "The optional failure message is now the last parameter");


	// well the next point is a I wanna be thing. I don't think that compiling a string is such a big issue
	// anyways see the point of lazy evaluation.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
		   + "to avoid constructing complex messages unnecessarily."); 
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and all
        // failures will be reported together.
        assertAll("person",
		  () -> assertEquals("Jane", person.getFirstName()),
		  () -> assertEquals("Doe", person.getLastName())
		  );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
		  () -> {
		      String firstName = person.getFirstName();
		      assertNotNull(firstName);

		      // Executed only if the previous assertion is valid.
		      assertAll("first name",
				() -> assertTrue(firstName.startsWith("J")),
				() -> assertTrue(firstName.endsWith("e"))
				);
		  },
		  () -> {
		      // Grouped assertion, so processed independently
		      // of results of first name assertions.
		      String lastName = person.getLastName();
		      assertNotNull(lastName);

		      // Executed only if the previous assertion is valid.
		      assertAll("last name",
				() -> assertTrue(lastName.startsWith("D")),
				() -> assertTrue(lastName.endsWith("e"))
				);
		  }
		  );
    }

    // so note the syntax of assertThrows:
    // first argument: exception that should result
    // second arg: the actual code that should throw the exception.
    // third arg: message – If the executable code does not throw
    //            any exception, this message will be printed along with FAIL result 
    // so basically use it in order to see if you get the error as desired. 
    @Test 
    void exceptionTesting() {
        Exception exception = assertThrows(ArithmeticException.class, () ->
					   calculator.divide(1, 0)); 
	
        assertEquals("/ by zero", exception.getMessage());
    }

    // this is a very nice one.
    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
		// Perform task that takes less than 2 minutes.
	    });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
		return "a result";
	    });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
		// Simulate task that takes more than 10 ms.
		Thread.sleep(100);
	    });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
		// Simulate task that takes more than 10 ms.
		new CountDownLatch(1).await();
	    });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
    #+END_SRC
    

*** Assumptions

    Ok... that is as well something I never came across
    before. Interesting to know of its existence.

    The idea is the following, if you include an /assumption/
    statement in a test, if the assumption is met then you run the
    rest of the test otherwise you will abort the test *without
    throwing an error* for it.

    It is essentially and if condition that has to hold in order to
    run the test.

    Then see the following two options

    #+BEGIN_SRC java :results output drawer :classname 
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
        // remainder of test
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
        assumeTrue("DEV".equals(System.getenv("ENV")),
            () -> "Aborting test: not on developer workstation"); // with message
        // remainder of test
    }

    // note that you could do the above in two different tests but
    // good to know the compact option.
    @Test
    void testInAllEnvironments() {
        assumingThat("CI".equals(System.getenv("ENV")),
            () -> {
                // perform these assertions only on the CI server
                assertEquals(2, calculator.divide(4, 2));
            });

        // perform these assertions in all environments
        assertEquals(42, calculator.multiply(6, 7));
    }

}
    #+END_SRC

        
    
** TODO Mockito

