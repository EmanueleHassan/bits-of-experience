#+BEGIN_COMMENT
.. title: On Programs Design
.. slug: on-programs-design
.. date: 2022-08-26 09:46:35 UTC+02:00
.. tags: software-engineering, frameworks
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So I am continuing my journeys into proper and solid software
engineering.

Basically, I always used frameworks and in my first experience it was
out of question whether to use them. But the things were more short
term and now that the software that I am touching is very long lived
the situation is different.

In fact, the topic around framework and which exactly to use is a hot
topic in our team. Some prefer to avoid them as much as possible. Some
are heavy proponents of them.

As always it is ultimately a trade-off question. I am writing here
some points in order to make such trade-offs more explicit.

In fact the way you decide to set up your software - such as trhoguh
inversion of control as when using frameworks or via simple libraries
and toolkits -, as well the task that the software is required to
complete will ultimately define the way you should set up and
program.

This is the ultimate reason why there should be a thorough design
phase before touching any bit of code and immersing yourself into
it. What you do not design today will come to hunt you down tomorrow.

Depending on the choice of your software set up you should as well
make strategic decisions that go hand in hand with it. This is the aim
of this post; to make this explicit. 

{{{TEASER_END}}}

Note that the following general structure - the first taste of this
post - comes from the book /Design Patterns - Elements of Reusable
OO-Software/.

In the book the following broad distinction across the following 3
classes of software is made. Note that in our team we are mainly
concerned in developing /Application Programs/. Some /toolkits/ are
also developed along the process, these are published and consumed as
artifacts.

There are some subsystem components that have a framework alike
experience with inversion of control. These won't be developed
anymore. Note that the major frameworks out there such as /Spring/ and
/Hibernate/ are used. It makes sense in this sense to stop a moment
and think about the characteristics of these frameworks such that you
develop software that is able to develop with them across time. This
is a general major pain point when working with frameworks.

** Application Programs

   The major points that you have to be aware of and set your focus on
   when developing internal application programs are the ones of:

   1. maintainability
      
   2. extension

   In this sense you should set up your software in a way that it easy
   to extend and customize in the future as the business requirements
   for it will change.

   On the other hand, you should keep maintainability in the back of
   your mind. The software should be easy to maintain, meaning easy
   enough to modify, refactor and get your hands into it. Both for you
   and for your successors.

   In general in this sense it is important to use design patterns for
   your code that favours loose coupling across the system. I.e. that
   increase the potential for one class to cooperate with several
   others. I.e. you should try to implement software that is /as
   transparent as possible/.

   Note that the two goals are conflicting. You usually have to set a
   layer of indirection in order to gain extensibility. This makes the
   system more complex and adds burden to the maintainability.
   
** Toolkits

   So these are the libraries that are designed to provide useful,
   general purpose functionalities. Think for instance at the Java
   standard libraries etc.

   Note that toolkits *don't impose a particular design* on your
   application; they just provide functionality that can help your
   application do its job. They let you as an implementer avoid
   receding common functionality. Toolkits emphasize code reuse.

   This is the main difference with Frameworks as we will see
   next. There inversion of control actually happens.

   When you develop toolkits it is important that you design them in a
   way that does not hamper the application usage. In this sense,
   important is to avoid assumptions and dependencies that can limit
   the toolkit's flexibility and consequently its applicability and
   effectiveness.

** Frameworks

   Note that when you use a framework it works as follows:

   #+begin_quote
You customize a framework to a particular application by creating
application-specific subclasses of abstract classes from the
framework.
   #+end_quote

   This is actually what you are doing by tagging all of your classes
   in the different frameworks with the relevant annotations.

   Note that it is important to realize the inversion of control
   characteristic of frameworks, meaning that:

   - the framework *dictates the architecture of the application*.

   So that in general:

   #+begin_quote
The framework captures the design decisions that are common to its
application domain. 

Frameworks thus emphasize design reuse over code reuse, though a
framework will usually include concrete subclasses you can put to work
immediately.

(Inversion of Control!) When you use a framework, you reuse the main
body and write the code it calls. You'll have to write operations with
particular names and calling conventions, but that reduces the design
decisions you have to make.

[Finally note that] not only can you build applications faster as a
result, but the applications have similar structures. They are *easier
to maintain*, and they seem more consistent to their users. 
   #+end_quote

   However, you have to be careful when using frameworks. You should
   check who is the maintainer and developer community behind it. You
   are actually making your application tight to the architecture of
   the framework. In this sense you must make sure that the framework
   is mature, that the community behind it is strong and professional
   such that they will not make too big architecture changes to the
   frameworks that will not be reverse compatible and will cause a lot
   of headache on your side in order to rework your solution.

   So that is mostly it and this is the reason why you should be
   careful in the decision you take when selecting a framework over
   the other.

   Note as well the following and why it is important to know the
   relevant design patterns

   #+begin_quote
An added benefit comes when the framework is documented with the
design patterns it uses.

People who know the patterns gain insight into the framework faster.

While design patterns might not flatten the learning curve of
frameworks entirely, they can make it less steep by making key
elements of the framework's design more explicit.
   #+end_quote
   
   
