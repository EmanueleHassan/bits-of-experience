#+BEGIN_COMMENT
.. title: Git Useful Commands
.. slug: git-useful-commands
.. date: 2019-08-29 16:40:59 UTC+02:00
.. tags: git, magit
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So here are some notes about some useful commands in git.

I might start to use it again from the command line as magit in my
emacs is dead slow on Windows OS.

I read online that there are some fundamental issues with it on
Windows.

This is not the only program where I am experiencing some performance
hiccup on Windows systems.

I will switch back to Mac soon as it seems that here in the company
they started to offer the possibility to have one. Have to wait a
couple of months for it still as I have to wait for the migration of
the IT systems to the cloud to have proper access to everything
without having to manually make new auth-modules. 

{{{TEASER_END}}}

** On the many files you touch that you do not want to touch

   It is normal to make minor modifications to multiple files when you
   edit the files of a larger project.

   You enter here and there in a ton of files and especially if you use
   emacs it is easy to add a space or a new line because of the many
   shortcuts.

   So basically what you do then is just to stage the files you
   want. You then write your different commits for them.

   You then push to the origin.

   You then fetch from the origin and reset your local repo based on
   it.

   Like this you will have eliminated all of the minor modifications
   that were unintendended and you keep your commits clean.

   You can do that with the following command

   #+begin_src sh
git fetch  # will fetch the latest changes on the remote
git reset --hard origin/master # will set your local branch to match the representation of the remote just pulled down.
   #+end_src


** On the right way to work and commit on git
  
   I also took the habit of making multiple commits per different logic
   chuncks of the modifications or as well for individual files.

   In such a way it is easier to keep track of your changes. You will
   read the different logical portions of your code and it will be easy
   for you to switch back to them.

   This is ultimately the way of working and thinking in git. You
   understand it by the default way git is implemented.

   You see that then if you rebase you rebase to some particular very
   well defined logical unit - and you keep your other future changes.

   Check at the following entry from [[https://stackoverflow.com/questions/46275070/why-do-i-get-conflicts-when-i-do-git-revert][this post here]].
  
   -------------------

   That's actually not what revert does. Revert doesn't "take you back
   to" that commit and pretend that subsequent commits didn't
   happen. It applies a logical negation of a single commit - and that
   commit alone - leaving subsequent commits in place. 

   Let's say you have some initial commit of some file - let's call it commit #1 for simplicity - and the file looks like this:

   #+begin_example
  One
  Two
  Three
  Four
   #+end_example

   Now let's say you have a commit #2 that changes one line:

   #+begin_example
  One
  2
  Three
  Four
   #+end_example

   And finally, commit #3 that changes a different line:

   #+begin_example
  One
  2
  Three
  4
   #+end_example

   If you try to revert commit #2, it will undo only the line changed
   in that commit, and leave the changes introduced in commit #3, so
   the result will be: 

   #+begin_example
  One
  Two
  Three
  4
   #+end_example

   Now, if there was a subsequent commit that had changed the same line
   as the commit that you're trying to revert, then you'll have a
   conflict. For example, let's say you have a commit #4 that also
   changed the second line: 

   #+begin_example
  One
  TWO
  THREE
  4
   #+end_example

   Now if your HEAD is commit #4 and you try to revert commit #2, you
   will have a conflict. Revert expects to take second line back - to
   undo the changes made in commit #2. So it expects the second line to
   currently be 2, and it will then revert it to what it was in the
   previous commit, setting it to Two.

   However, that expectation was invalidated, since commit #4 had also
   changed it. So you have a conflict.

   If your goal isn't to revert at all, but to get back to commit #1
   and ignore all the changes that have gone on since then, then you
   want to reset instead of revert.

   #+begin_example
  git reset --hard 1 
   #+end_example


** On staging and committing different parts of different files separately

   This is an important concept that relates to the way git commits
   work as seen before.

   So far I was rather clumsy in my commits... meaning that I was
   either committing entire file edits or nothing. This was fine as
   pure software development was not my primary task.

   Things are slowly changing such that it is important to adjust to
   the new conditions.

   Now, when working on projects and edits that last for multiple days
   you might have to add piece of code to try things out that is not
   really beneficial for the ultimate solution. The question is
   then... can you commit that part of the code separately. In such a
   way it will be possible to split the commits and potentially revert
   to edits previously made without having to unwind all of the trial
   and error crap that you used in the code.

   In git you can do that as follows:

   #+begin_src sh
  git add --patch
   #+end_src

   Then git will start asking you interactively if you want to stage
   different edits within a file or not.

   This is not the most user friendly way to do that. Check out [[https://filip-prochazka.com/blog/git-commit-only-parts-of-a-file][this
   url]] in this sense.

   Note that the point made in the comment is correct. Once you are set
   up with your CI pipeline things will not look that linear. But leave
   that reasoning and solution finding for a later timepoint.

   Note finally that magit - your emacs - tool is best suited for
   performing this task. You never noticed / never thought about
   it. But there basically the file is already split in the different
   hunks of edits. You can then stage the different as usual by going
   to the relevant hunk and pressing =s=, from there on is your very
   classical workflow so nothing new under the sun. 


** On discarding all of the unstaged edits

   #+begin_src sh
git checkout -- .
   #+end_src


   
* Magit component

** On worktree
  
   Ok so here some notes about magit itself.

   So one of the best things is for ediffing. I already talked about it
   in a different post. Go to check this out when you have time.

   So one of the features I particularly like is the one of showing the
   worktree. There you can view the history. You can open individual
   commits and see what you changed in each etc.

   Now say that you want to go back to a previous commit... *exactly
   that one*.. you can reset based on that commit.

*** TODO not that simple that story... will have to read more into it at some point. :noexport:

    tried with

    #+begin_src sh
git checkout 0d1d7fc32 
    #+end_src

    Then I went back... I think to the exact one... after commiting I
    lost all of the previous commits... not sure how that happened.

    Double check at some point more into the detail in these things.
   

** Checking changes between two commits
  
   Then you can change exactly what you changed on a given file between
   two commits.

   Then you can open the log worktree =l= in magit console, with
   =Ctrl-space= you select the range of commits. Then =E= for Ediff
   and finally =r= for range.

   This will open up your ediff buffer from which you can work as per
   your merging post etc.


** Magit reverting to a particular commit.

   Magit reversion is bounded to =V= in magit.

   What magit does is then to create a new commit with the specific
   reversion.

   There are two options that you can check in more depth for making
   that reversion. I understand that the difference between the two is
   minimal. I think it is something in the direction do you want to
   edit and insert the commit message yourself or not.

   In any case the only bit you should remember is the following.

   To decide which commits to revert you first enter your worktree =l
   l= in the magit console.

   Then you select the commits of interest (recall with =SPC= bar) and
   just then, when the commits are selected you revert. 




** Cherry Picking in Magit

   This is a very nice feature. The essential is to say don't merge
   everything from the other branch but just a specific commit.

   You can see how to do that in the plain way from the shell at the
   following [[https://mattstauffer.com/blog/how-to-merge-only-specific-commits-from-a-pull-request/][entry]].

   In magit - at least my version you do it in the following way.

   You open your graph with all of the commits. *You go on the branch
   where your commit sits* - the commit you want to pick and import
   into another branch.

   You open the commit tree there =l l=.

   Then you go on the commit you want to copy (or potentially you
   highlight a couple of commits C-Space and select the relevant).

   Then you go with =A A=. You will then select the branch you want
   to import the commit to and badaboom, you are done.

   
