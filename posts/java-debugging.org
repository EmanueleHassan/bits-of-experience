#+BEGIN_COMMENT
.. title: Java Debugging
.. slug: java-debugging
.. date: 2021-12-12 12:32:32 UTC+01:00
.. tags: java, debugging, dev, software-engineering
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

#+begin_export html
<style>
img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>
#+end_export


So it is time to start some serious post and exploration on Java
debugging.

Note that I believe that having the right tooling is paramount of
performing a job well. It can save you a lot of time that is worth.

So this post will contain all of the concepts in order to properly
work with the debugger.

Cause yeah... we all know about breakpoints... but you better start to
properly work with conditional breakpoints, trace-points, watchpoints,
time-reversion features etc.

As always in the IT world, lots of heads worked on a thing, so you
start to dig and you will never end. You simply open a pandora box.

I will start easy withe the basics and then I will start to dig a
little bit deeper into more advanced stuff.

{{{TEASER_END}}}

* Conditional Breakpoints

  This is nothing new under the sun you already used it extensively -
  especially back in the days when you coded yourself that genrealized
  tree method in your Master Thesis at the end of your first Masters.

  In Eclipse you just open the breakpoint conditions, write then a
  boolean condition and the execution stops there when the condition
  evalues to =TRUE=.


* Step Filters

  This is not related to breakpoints but rather to individual steps
  you do after the breakpoint is hit.

  It is helpful to continue iterating over needless stuff like a fool.

  Basically in the step-filters you can define what to ignore when
  doing your steps in debug mode.

  You can for instance ignore entire things belonging to a given
  package etc. 


* Exception Breakpoints

  Can also be handy - [[https://medium.com/@sanketmeghani/eclipse-tips-exception-breakpoints-e36634f1579b][quite intuitive]].


* Tracepoint

  This is a nice feature.

  Allows users to *creates conditional breakpoints* to *print out
  messages* without halting at the breakpoints and cluttering the code
  base.

  You could theoretically do everthing by changing your code base.

  This clutters the code and requires yourself to recall then to
  remove all of the code.

  Check at the functionality when you have time. In any case it is
  nothing big if there is not.

  Note that you can achieve exactly the same by defining a function
  that returns a boolean and before returning you can execute all of
  the logic you desire there.

  See for instance [[https://stackoverflow.com/questions/14937363/tracepoints-in-eclipse/14937367][this]].


* Trigger points

  This is nice... especially if you have recursive code.

  The idea is the following:

  - you set 1 or multiple trigger points - these are also
    breakpoints.

  - you set other "normal" breakpoints. Note that these can belong to
    the types of breakpoints mentioned above.

  Then all of the breakpoints that *are not trigger points* will be
  ignored until the first trigger point is hit and activates all of
  the breakpoints friends.

#+begin_export html
 <img src="../../images/Screenshot 2021-12-12 145916.png" class="center">
#+end_export

  You could do everthing by just setting a frist breakpoint, ignoring
  all of the others - i.e. deactivating them manually - and then
  activating them again as soon as the first breakpoint is hit.... you
  see the pain involved in it in comparison to standard trigger
  points.
  
  
* Time reversion

  Ok so this is a thing that I would especially like to have well
  sorted out.

  Cause with these compiled languages you loose a ton of time if you
  cannot do proper testing of stuff on the fly as you go along.

  So basically once you are in the debugging mode and you are trying
  to understand the proper working of a given mechanism it is easy to
  go over a step get some knew understanding then go back to the
  previous step in order to actually test smth and check if the
  mechanism is really as intended.
  
** Drop to Frame

   In order to do that there is the =drop to frame= option in the
   Eclipse IDE. Check at [[https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fviews%2Fdebug%2Fref-droptoframe.htm][this]]. You should also check at the other pages
   in it to properly get a sense of the IDE.

   Your migration to Emacs-lsp is still ongoing but according to plan
   it should not last too long. Have now overcome runtime issues,
   understand better gradle working... but that is a side note and a
   different discussion.

   *Important Note:* it won't unroll any state changes that have
   happened, so it may not work depending on the sort of method you're
   in.
   
** More intersting stuff

   Note that the research always pays off. You should explore the
   following as found in [[https://stackoverflow.com/questions/4331336/how-to-step-back-in-eclipse-debugger][this thread]]:

   #+begin_quote
there are a few Eclipse-based tools that could be used to "go back" in
(run)time:

- [[https://cse.buffalo.edu/jive/][JIVE]]: Java Interactive Visualization Environment

- Chronon: A “flight data recorder” for Java programs

- Diver (discontinued): Dynamic Interactive Views For Reverse
  Engineering -- not nice that it has been *discontinued*

- Halik: Only for *IntelliJ* for now, but porting to Eclipse is
  mentioned on the roadmap. - so also out of my list
   #+end_quote

   Check at JIVE next week when you have time as it apparently also
   provides the UML features you are looking forward to, in order to
   write proper software that can be easily managed and migrated.

   
* Execution of Stuff

  One of the things you can do is change the value of a variable - see
  [[https://stackoverflow.com/questions/11646999/change-variable-value-eclipse-in-debug-perspective-at-run-time][here]]. Check then how that works.

  You can also inspect and execute chuncks of code to see what they
  would be evaluated to.

  Still too poor developing experience. Have to understand better how
  to solve this bottleneck. Would be nice to have more developing
  experience in this domain.

  Explore other Java debuggers in this sense. I think that this is
  highly a non-solvable issue due to the way Java was set up. Check
  especially the jdb. I think this is a well used IDE agonostic
  debugger. 

  But you never know. Give it a research try.


* On viewing the stacktrace of an Throwable

  I do not understand yet the entire set-up of the multiple
  applications we have.

  For some when debugging you do not manage to see the stacktrace of
  errors, i.e. they are not returned to the console where your TOMCAT
  is running.

  I guess this is normal as that web-server theoretically deals with
  multiple applications and so there just erros regarding the smooth
  working of the server itself are logged + plus connection errors
  etc. that hamper the general availability of the system.

  On some applications I was able to identify a log file where all of
  the errors are redirected. There you can see the logs for a
  particular application, its state, errors, stacktrace etc. So all
  good.

  On other applications the situation is still not that clear. Dig
  into them and check where the issue is and how the set-up is. In the
  meanwhile when you encounter an error in Debug mode - there is
  always the method ~printStackTrace ()~. Use this method of
  =Throwable= objects and keep going.

* On one useful thing

  So basically as you are working on a single huge monolith, all of
  the different components run on a single process.

  Now there is the use to work on different applications concurrently
  as maybe you are debugging something but it needs a bit to process
  the application and you would like to work in the meanwhile on a
  different application.

  You understand how crucial the above is not to get stuck all of the
  time when programming as you have to wait for some longer
  computation etc.

  Now there is an easy way to do it. You can refer to [[https://stackoverflow.com/questions/8409943/remote-debug-multiple-eclipse-projects-at-the-same-time][this post]]. The
  essential idea is the following:

  - you have bounded your debugger at the beginning to some specific
    project.

  - now if you start debugging into another project the source code
    might not be visible there.

    the solution is simply to edit the /"Change Source Attachment"/ as
    following.

  #+begin_export html
   <img src="../../images/Screenshot 2022-01-20 112317.png" class="center">
  #+end_export

     you can then select there the project which source code should be
     included. Do not forget to tick the mark to also include
     sub-folders. 

* TODO JFR files

  check [[https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170][here]].

  
