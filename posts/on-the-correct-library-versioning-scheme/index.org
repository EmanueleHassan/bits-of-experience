#+BEGIN_COMMENT
.. title: On the Correct Library Versioning Scheme
.. slug: on-the-correct-library-versioning-scheme
.. date: 2022-09-26 13:07:34 UTC+02:00
.. tags: software-engineering, java, Python
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So basically this is a very quick post on how to properly version your
libraries.

Essentially, you will use it in both of your python packages twine
uploads and in your gradle java libraries packages. 

Moreover, it is important as once you appreciate the proper way of
versioning libraries you will understand why Azure DevOps prevents you
from uploading two libraries with the same version - or let's say to
overwrite the thing. 

You will understand that this actually happens as a way to indicate
you that you should comply with standard versioning systems used
across the world.

In general there are two different schools of working with the general
versioning schema. You should decide which school you want to comply
with. I will explore the both in this post. 

{{{TEASER_END}}}

** On the conflict between (Maven) versioning model and CD mind-set

   So basically there is an inherent tension between the prescribed
   versioning schema in maven and the one you should leverage when
   performing CD - continuous delivery.

   Essentially the tension comes from the development process when
   performing a library/app update.

   In order to see this let's start with the Maven way of doing things
   before switching to the CD way of doing things. Before a 20
   sec. look into how to properly read the versioning numbers.
   

*** Maven Dev Versioning Practices

    So essentially the idea of maven is to have a distinction between:

    1. snapshots

    2. release versions

    The fundamental idea is that when developing you should not
    increase the versioning for every build. You should rather use the
    =snapshot= keyword. I.e a snapshot represents that an artifact is
    still under development and shall not be used to production.

    Note that under this development paradigm the following holds:

    #+begin_quote
Whenever the artifact is published to a binary repository, it’s
uploaded with the same version.

Any consumer of this artifact will only be able to retrieve the latest
version of that snapshot version.

At some point in development, it’s determined that the software is feature-complete.
Once it passes the QA process, it’s ready to be released to
production.

At that time, the -SNAPSHOT suffix is taken off the version and it’s
released to production.

Now you’re dealing with a release version of the artifact. Ultimately,
this means having to modify the version attribute in the POM file and
*checking it into VCS*.

A new development cycle starts by bumping up the *major and/or minor
version of your project*; the -SNAPSHOT suffix is added again. So you
see that the last - the build number stays always at 0.
    #+end_quote

    Note that this school is quite outdated and you should rather work
    as next embedding everything in a strong DevOps process. 
        
*** CD Versioning

    In contrast to the maven school the idea of CD is to include your
    development in VCS and work in a way that every commit can become
    a release to production.

    I.e. every commit should be deployed by your pipeline in the
    different environments.  Meaning it should be deployed to Dev and
    then potentially UAT and finally if passing the user acceptance
    tests to production.

    Obviously deployment just happens if the software passes all
    phases defined by the build pipeline with the quality standards
    agreed on by the team.

    This is how versioning is and shall be used in the CD world.

    #+begin_quote
2.11.177

2 -> major version update

11 -> minor version update / features

177 -> build number
    #+end_quote

    In this sense you see that it is necessary to increase the build
    number after each build.

    Check at your gradle scripts in order to see how to do it. 
   
*** Overview of the two Schools

    So you understand the two schools of thought above. In one the
    build increase and every commit could be potentially the release
    to production.

    In the other not but you rather work with snapshots. 
    
    #+begin_export html
     <img src="../../images/Screenshot 2022-09-27 142038.png" class="center">
    #+end_export

*** On the CD school

    I declare that I will be CD school scholar. 
    

** On the Implemenation of the Above in Java And Python

   So basically once you fixed the school, the question is how to work
   in such away with your go to languages.

   We will see it next. 

*** Python

    I start with Python. The system is more developed in this
    sense. At least from what I could find online and with what comes
    out of the box. I guess there are solutions in java if you dig
    enough. In any case I created a tailored made one as you can read
    in the next section.

    See in this sense [[https://python-poetry.org/docs/cli/#version][poetry version concept]] [[[https://py-pkgs.org/07-releasing-versioning][other link]]]. You can
    easily see there how you can deploy with different bump rules that
    will automatically increase the build etc. 

    Take some time in order to properly see poetry is quite
    extensive. Understand how it fits into your python stack. I guess
    it could replace the build tool I am using and should be triggered
    after the relevant tox processes. 

*** Java

    Here I created a relevant task in gradle in order to perform this
    necessary step.

    You can find the relevant commit [[https://github.com/MarcoHassan/mySpringPlayground/commit/dc74b3e904f343d3d9f7b9c51cb0dba00f932efa][here]]. It borrows heavily from
    [[https://stackoverflow.com/questions/39824574/version-increment-using-gradle-task][this]].

    Note that what is missing is making the relevant build steps
    dependent on this newly created task.

    In such a way you can use the general command and do not have to
    trigger complex logic for your build. Keep it simple, always.
    
