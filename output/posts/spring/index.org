#+BEGIN_COMMENT
.. title: Spring
.. slug: spring
.. date: 2021-11-01 16:46:56 UTC+01:00
.. tags: java
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT


So this is the next piece of the cake. As we transition to the cloud
it makes sense to have the spring-framework in your skillset.

The notes are based on Spring in Action - 5th edition.

{{{TEASER_END}}}

* General Idea

   At its core, Spring offers a container, often referred to as the
   Spring application context, that creates and manages application
   components.

   These components, or beans, are wired together inside the Spring
   application context to make a complete application, much like
   bricks, mortar, timber, nails, plumbing, and wiring are bound
   together to make a house.

   The act of wiring beans together is based on a pattern known as
   /dependency injection/ (DI).

   Rather than have components create and maintain the lifecycle of
   other beans that they depend on, a /dependency-injected
   application/ relies on a *separate entity (the container)* to
   create and maintain all components and inject those into the beans
   that need them. This is done typically through constructor
   arguments or property accessor methods.

   On top of its core container, Spring and a full portfolio of
   related libraries offer a web framework, a variety of data
   persistence options, a security framework, integration with other
   systems, runtime monitoring, microservice support, a reactive
   programming model, and many other features necessary for modern
   application development.

   
** NOTE:                                                           :noexport:

   So that is interesting. You always heard about Spring because of
   all of the rest.

   It is interesting that the main component - the container was never
   properly addressed.


* Spring Project Structure

  - =TacoCloudApplication.java= - This is the Spring Boot main class
    that bootstraps the project.

  - =application.properties= - here you can specify the configuration
    properties. 

  - =static= - here you save your static files for your application.

  - =templates= - here you have template files that will be used to
    render content to the browser. 

  - =TacoApplicationTests.java= - this is a simple test class that
    ensures that the Spring application context loads successfully. 

* Gradle Configuration

  Note that one of the most important thing that you have in your
  build configuration is that you deploy to a =jar= not into a =war=.

  Whereas WAR files are perfectly suitable for deploying to a
  traditional Java application server, they’re not a natural fit for
  most cloud platforms.

  Although some cloud platforms (such as Cloud Foundry) are capable of
  deploying and running WAR files, *all Java cloud platforms are
  capable of running an executable JAR file*. Therefore, the Spring
  Initializer defaults to JAR packaging unless you tell it to do
  otherwise.

  Basically you can then set up your project with the required
  dependecies. In order to do that, always work through
  https://start.spring.io/.

  This is useful as through it you can get your skeleton for working
  with Spring and through it you can quickly jump-start into your
  projects.

  Note that through /transitive dependencies/ you will manage to keep
  your build tools lean. This in the sense that by simply specifying
  the follwoing dependecies:

  - spring-boot-starter-thymeleaf

  - spring-boot-starter-web

  You get out of the box dependencies that makes the following
  available:

  - Spring’s MVC framework

  - Embedded Tomcat

  - Thymeleaf and the Thymeleaf layout dialect

  Moreover, you get autoconfiguration libraries that automatically:

  - Configure the beans in the Spring application context to enable Spring MVC

  - Configure the embedded Tomcat server in the Spring application context

  - Configure a Thymeleaf view resolver for rendering Spring MVC
    views with Thymeleaf templates.


  Note that Thymeleaf is a framework to handle the views. This is
  front-end stuff. You did some stuff in there in Python but it is not
  your bread and butter and neither your main interest. You are rather
  interested in the Spring MVC for writing your endpoints and do the
  back-end work.

  Note as well there is a devtools dependency:
  =spring-boot-starter-devtools=. This is handy when programming as
  through it you will be able to have quicker updates and
  deployments. It achieves similar results as running flask in
  debugging mode. But it adds much more to it. There is also this
  H2-console that you need to understand better at some later point.

  Anyways read more into such devtools when you start properly
  developing with it. For now focus on the general structure in these
  notes.
  
* Running the Spring web-application
  
** Run App

   This is the equivalent to your =flask.run= command. 

   #+begin_src java :results output raw 
package myCoolPackage;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication 
public class TacoCloudApplication {
 public static void main(String[] args) {
 SpringApplication.run(TacoCloudApplication.class, args); 
 }
}
   #+end_src 

   Through the Spring framework you know that this will be the entry
   point for your application and its =main=.

   You see that you call then the static =run= method. This does the
   actual bootstrapping of the application, creating the *application
   context* we mentioned before.

   Note that you pass to the =run= method:

   - a *configuration class*

   - the *command-line arguments*

   Note that in the example above the configuration class is the same
   as the /bootstrap class/. This does not have to be the case.

   We will see that in fact the larger the projects - the more you
   usually work with separate classes.
   
** MVC - through it you write your back-end endpoints

   This is a web-framework.

   At the center of it there is the concept of /controller/.

   This is a class that handles requests and responds with
   information. I.e. it is the class through which you classically
   implement your endpoints.

   So in order to implement the most basic endpoint you can work as
   follows:

   #+begin_src java :results output raw 
package myCoolPackage;

import org.springframework.stereotype.Controller;

import org.springframework.web.bind.annotation.GetMapping;

@Controller 
public class HomeController {
 @GetMapping("/") 
 public String home() {
 return "home"; 
 }
}
   #+end_src 
   

   Note that the =@Controller= annotation doesn't do much. It is there
   to identify the class as a component. This will be useful as you
   will do some component-scanning in your Spring-application context
   then.

   I.e. through the annotation Spring’s component scanning
   automatically discovers it and creates an instance of
   Home-Controller as a bean in the Spring application context.

   The =@GetMapping= is there to note that the endpoint will work with
   GET requests. 

   
** Endpoints Testing

   You can check in the book. This will be a quite big waste of time
   nonetheless.

   Start first by deciding on which tests suite you want to use. All
   of these books explain you the stuff pretending there would be just
   a single way of doing it.

   This is not the case. So get the general structure and idea. But do
   not spend too much time on it now on doing documentation. You might
   use then a complete different testing-suite.
  
* Important Spring Modules

  Note that on that spring initialzer page you can see all of the
  dependencies nicely integrated with the spring framework.

  You can navigate it in detail in time.

  However, in general there are macroscopic classes, that you need to
  understand:

** Core Spring Framework

   This is the fundation of everything in the spring universe.

   It provides the core container and dependencies injection
   framework.

   It also provides the following essential features:m

   - Spring MVC

   - Template based JDBC support

   - Spring WebFlux (for *reactive* programming)

** Spring Boot

   This is what makes autoconfiguration and starter-depencies
   possible.

   Note that the starter-dependencies are exactly the thing we
   mentioned. I.e. you specified these very general
   =spring-boot-starter-xxx= dependencies and through it you get a ton
   of others transitive dependencies and autoconfigurations of them.

   Note that Spring Boot also allows the following:

   - The *Actuator* provides runtime insight into the inner workings of
     an application, including metrics, thread dump information,
     application health, and environment properties available to the
     application.
     
   - Flexible specification of environment properties.
     
   - Additional testing support on top of the testing assistance found
     in the core framework.

   Spring Boot offers an alternative programming model based on Groovy
   scripts that’s called the Spring Boot CLI (command-line
   interface). With the Spring Boot CLI, you can write entire
   applications as a collection of Groovy scripts and run them from
   the command line.

   Not interesting to me. It is another layer of config. It seems that
   this Groovy is quite some config language in the Java world as it
   is used for both specifying things in Gradle as well as here in
   Spring at macro-level.

** Spring Data

   What’s more, Spring Data is capable of working with a /several
   different kinds of databases/, including relational (JPA), document
   (Mongo), graph (Neo4j), and others.

   So interesting altough as mentioned I do not like to work with such
   interfaces as then you stick too much into a single language.

   I prefer to work with the native declarative languages of each as
   these are quite stable and will provide the necessary portability
   across languages.

** Spring Security

   Through it you can manage a broad range of application security
   needs, including authentication, authorization, and API security.

   This is what you did in your last Flask project. So similar
   thing. Was never a fun of it. I hope I will not have to dig too
   much into it. However, with the Zero-trust Architecture paradigm I
   might have to do that at some point. 

** Spring Integration and Spring Batch

    *Spring Integration*: addresses real-time integration where data is
    processed as it’s made available.

    *Spring Batch*: addresses batched integration where data is allowed
    to collect for a time until some trigger (perhaps a time trigger)
    signals that it’s time for the batch of data to be processed.

    So this will be important as with it you can push the boundaries
    of your market risk system and make a nice machine out of it. It
    will be very important in this sense to master functional
    programming and these frameworks in order to have a proper baby. 
   
** Spring Cloud

    Microservices are a hot topic, addressing several practical
    development and runtime concerns. In doing so, however, they bring
    to fore their own challenges. Those challenges are met head-on by
    Spring Cloud, a collection of projects for developing cloud-native
    applications with Spring.

    So that is interesting and what Sergio was mentioning. I am
    interested in looking into it as many things were provided by
    external dashboards on the cloud from my experience at IBM.

    I am interested in this sense to understand how that is working
    and how exactly is it monitoring things given that the things work
    in different runtimes.
   
* Web-applications with Spring

** Spring MVC

   With it you can both display information to the front-end in a
   dynamic way.

   Or, alternatively, it will be possible for you to develop REST
   endpoints with it.

   I will not make big notes of the first. It is not my bread and
   butter. Note that it is pretty much what you saw at the times of
   your IBM projects when you worked with flask.

   I.e. you serve the static content via MVC, and you have different
   =views=, through which it is possible to embedd the application
   logic into the front-end.

   The book worked with Thymeleaf as a view framework in order to
   embedd the application logic into the front-end. We work with
   Mustache. Though, you can imagine that the two are quite similar -
   and again, from what you can read this is exactly what you could
   see when working on your flask-login module. 

   Note that in general you always talk with the controller when
   instatiating the HTTP request. Then you perform your application
   logic and pass on the relevant info to the views.

   
* Spring Data

  So we will treat here how to interact with JDBC and JPA in Spring.

  Note that the difference between the two is the level of
  abstraction. Through JDBC you communicate directly with the DB by
  passing SQL queries and interacting with the driver of the DB.

  JPA is the higher level of abstraction. There you can work with the
  first-class citzens of java: objects. Check your other post where
  you digged a little bit more deeper into them.

  Note that these notes are just approximate. You make sense of the
  java way of developing in here. Note that you should then just refer
  to these to get the gist of the idea when creating your first
  restful service with data persistence.

  You should then create the most logical and classical way for
  persistence using the following repository holding the code for the
  application in a unified way: [[https://github.com/habuma/spring-in-action-5-samples/tree/master/ch03/tacos-jdbc/src/main/java/tacos][here]].

** Spring JDBC

 Spring JDBC support is rooted in the JdbcTemplate class.

 JdbcTemplate provides a means by which developers can perform SQL
 operations against a relational database without all the ceremony and
 boilerplate typically required when working with JDBC.

 So basically with jdbc you do not have to handle all of the
 connections and the error messages explicitely. So the module in Java
 helps you to work without all of the boilerplate.

 I like this code as it is more lean than without the templates. 

** Reading from RDMS

   You would do that in the follwoing way leveraging on the JDBC templates

 #+begin_src java :results output raw 
// Note how you focus on the query in here. No connection is handeled. 
@Override
public Ingredient findOne(String id) {
 return jdbc.queryForObject(
 "select id, name, type from Ingredient where id=?",
 this::mapRowToIngredient, id);  
}

// Your function for mapping queries to results.
private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
 throws SQLException {
 return new Ingredient(
 rs.getString("id"),
 rs.getString("name"),
 Ingredient.Type.valueOf(rs.getString("type")));
}
 #+end_src


 Note that the ~queryForObject~ above maps the query to a single
 object.

 If you want to map each row of the query to an object which you then
 would save in a *Collection* you can use the ~query~ method. Check
 the below in this sense:

 #+begin_src java :results output raw 
@Override
// note the Collection result here.
public Iterable<Ingredient> findAll() { 
 return jdbc.query("select id, name, type from Ingredient",
 this::mapRowToIngredient); // not same mapRowToIngredient method
}
 #+end_src

 So basically that is how it works. you just have then to embedd such
 methods into a class that is initialized with jdbc template.

 You can do that as [[https://github.com/habuma/spring-in-action-5-samples/blob/master/ch03/tacos-jdbc/src/main/java/tacos/data/JdbcIngredientRepository.java][here]]. Note as well the constructor with
 =@Autowired= there. This is a Spring specific annotation in order to
 get things in the context etc. Note as well the installation of
 =RowMapper=. Note that this necessary as the second argument of the
 ~query~ etc. is in fact a rowmapper and the referenced methods are
 interenally treated as such. You can find in the book an example on
 how to work explicitely with Rowmapper but this is not in my interest
 as it just clutters the code.
 
** Writing to RDMS

   To write into the RDMS using JDBC template you can use the
   ~update~ method.

   You can do that in the follwoing way

   #+begin_src java :results output raw 
@Override
public Ingredient save(Ingredient ingredient) {
 jdbc.update(
 "insert into Ingredient (id, name, type) values (?, ?, ?)",
 ingredient.getId(),
 ingredient.getName(),
 ingredient.getType().toString());
 return ingredient;
}
   #+end_src 

   Because it isn’t necessary to map ResultSet data to an object, the
   ~update()~ method is much simpler than ~query()~ or
   ~queryForObject()~.

   There is then a messy section about writing the stuff in the DB
   when you have to make sure all of the keys relations are
   satisfied. I jumped it as it is not well written. In this book you
   do not have an overview of what piece of code is written were, so I
   thought I will understand at the time of getting my hands dirty
   with it. So wait for it and tackle this down at a later point.

** Creating and Populating your Tables

   You can define the db schema in Java in the following way:

   #+begin_src java :results output raw 
create table if not exists Ingredient (
 id varchar(4) not null,
 name varchar(25) not null,
 type varchar(10) not null
);

create table if not exists Taco (
 id identity,
 name varchar(50) not null,
 createdAt timestamp not null
);

create table if not exists Taco_Ingredients (
 taco bigint not null,
 ingredient varchar(4) not null
);

alter table Taco_Ingredients
 add foreign key (taco) references Taco(id);

alter table Taco_Ingredients
 add foreign key (ingredient) references Ingredient(id);

create table if not exists Taco_Order (
 id identity,
 deliveryName varchar(50) not null,
 deliveryStreet varchar(50) not null,
 deliveryCity varchar(50) not null,
 deliveryState varchar(2) not null,
 deliveryZip varchar(10) not null,
 ccNumber varchar(16) not null,
 ccExpiration varchar(5) not null,
 ccCVV varchar(3) not null,
 placedAt timestamp not null
);

create table if not exists Taco_Order_Tacos (
 tacoOrder bigint not null,
 taco bigint not null
);

alter table Taco_Order_Tacos
 add foreign key (tacoOrder) references Taco_Order(id);

alter table Taco_Order_Tacos
 add foreign key (taco) references Taco(id);
   #+end_src 


   Now the question is if you want to do it like that in Java or not.

   I like the idea as this is plain SQL. So you can keep it in your
   project repo. You can moverover generate the schema for localhost
   embedded DB as H2 where you can test and work in dev mode.

   Moreover once everything defined you can run the same sql file to
   populate your DB of interest.

   If you take this approach you just have to make sure that the H2
   embedded DB has the same SQL dialect as the server you are using
   and make all of these kind of reasoning. 

   So the question is how do you execute the schema definition above?

   Again Spring comes at rescue. In the moment where you will save the
   stuff in the proper repo and adhere to some basic convention the
   file *will be executed* against the DB when the application
   starts.

   I.e. you should save the file as =schema.sql= in the
   =src/main/resources= repo.

   You can find the example fo the book [[https://github.com/habuma/spring-in-action-5-samples/tree/master/ch03/tacos-jdbc/src/main/resources][here]].

   You can as well pre-populate the DB with some records by writing
   some insert statements in a =data.sql= file also saved on the same
   repo.

** Spring JPA

   Ok - here there is a big discussion among the Java experts in my
   team and other people coming from other programming languages.

   I still have to understand it properly. Heavy Java users claim it
   is the way to work with data in Java. It will allow the developer
   to keep thinking and programming in terms of objects.

   On the other hand it is true that if you work through such layer
   you will create a strong dependency to Java. It will not be easy to
   migrate to other modern data-driven languages that direct SQL.

   Think for instance the SQL in the python environment where you can
   apply it directly to pandas, apache-spark-sql etc.

   I also have to understnad better the scope of Spring JPA - and the
   extent to which it differs from Hibernate JPA. I think in fact that
   Spring JPA leverages by default the Hibernate JPA but would have
   eventually to check it up once and if you decided to go through
   this JPA experience in the way you develop in Java. 
   


* Securing Spring

  There is even all of the layer about securing the spring application
  such that it properly communicate by encrypting data in transfer.

  You might need it for your next assignment.

  Keep it in the back of your mind and skip it for the moment and go
  back to it when the project will require it. 
   
* Configuring Spring

  So basically Spring it is nice cause you have tons of beans in
  spring that will ultimately be injected in your context and you will
  have a well rounded Java development environment.
   
  So this is basically the idea. You differentiate two components in
  Java:

  - /Bean wiring/: through this component you can define the beans
    that you will use in your spring application. I.e. the beans that
    will be discoverable from the spring context. Moreover, through
    /beans wiring/ you specify how the different beans will be
    injected into each other. 

  - /Property injection/: this sets the values on the different beans
    in the Spring context of the application.

  We will see how to specify these two fundamental components through
  Spring boot. You will then be able to create your modularized
  application and work with it in a smooth and agile way.
  

** How the spring framework works

   In order to properly understand how to do /beans wiring/ and
   /property injection/ you should first understand the following
   general flow spring boot follows.

   The following chart of the book gives a good overview:

#+begin_export html
 <img src="../../images/Screenshot 2021-11-14 182534.png" class="center">
#+end_export

   I.e. what you do is to instantiate the spring application by
   setting all of the relevant parameters that will be used in order
   to instantiate the relevant beans with the relevant configurations.

   I.e. you specify the spring configuration you want by specifying
   the relevant paramters through cmd line, yaml configuration files
   etc.

   Spring boot will then refer to the relevant configuration available
   in the /spring environment/ to initiate the relevant beans and make
   them accessible by the proper injection into the spring context.

   So given the general picture above understand the following
   components that are key to every proper Spring application and that
   you should accordingly set.

** Embedded Server

   Here you can decide where your embedded server will communicate.

   The default embedded server is Tomcat. You can change the option
   and work with different servers.

   #+begin_src yaml
server:
 port: 0
   #+end_src

   Note that port =0= is a sensible choice as you will be able in such
   a way to do proper integration testing. You do not hard-wire a port
   but each time a different port is selected.

   You will therefore make sure that your tests do not simply pass
   because a port was hard-wired.

   Note that this is a good point but it can well be a moot
   point. Everything ultimately depends on the infrastructure
   initialization.

   Here you can also specify all of the options for ssl, your
   key-stores etc. I just note it here but again I do not think I will
   never need that stuff as we are in the era of the cloud and I think
   it is a sensible decision to leverage the abstraction layer in
   there.
   
** Data

   Here you can specify the driver and the location of the DB you will
   interact with.

   You have to understand how this overlaps with Gradle. There you
   specify as well parts of this.

   So double check how these two fits together. I am quite sure that
   if you work with spring you do not specify the stuff in
   gradle. I.e. you just specify the spring dependencies in gradle.

   Then once this is specified it is all of a game within spring. This
   is the big difference. While when programming without Spring you
   have to pull the modules one-by-one into gradle and you compose
   everything yourself.

   Moreover as there is not a framework putting everything in an
   opinionated context you have to do the manual config yourself.

   I mean in the notes above I put a bit of notes that are nose-driven
   so I am not sure everything is correct at 100% but more or less it
   should be that.

   You can then see in the book how to properly instantiate your db
   with the different tables schema etc. I refer to the book in case
   you want to go down that road. 
   
** Logging

   This is nice, you can set there the standard output of your
   logger.

   Refer to the book. But basically there is an option to do that via
   a xml file.

   Moreover on the top of it once you defined the output of the logger
   you can define all of the different levels that should be printed
   by the logger.

   You can that through the standards yaml configuration files.

** Property injection via special property values

   This is a nice way to make dynamic and intelligent properties
   injection into your spring environment - and consequently beans -.

   The standard format would be something like that:

   #+begin_src  yaml
greeting:
 welcome: You are using ${spring.application.name}
   #+end_src

** Creating your own configuration properties

   Configuration properties are nothing more than properties of beans
   that have been designated to accept configurations from Spring’s
   environment abstraction.

   So the above configurations are easy to integrate.

   This is the *important* section. We will see how the beans are
   actually designed to consume the configuration in the spring
   environment and how you can actually set up your configuration and
   inject it into the beans.

   In order to do that you have to understand a couple of flags as in
   the usual case of spring - i.e. these are actually the first class
   citizens of spring through which you can manage it all.

   In this sense, one of the most important annotation is the
   following:

   - @ConfigurationProperties annotation. When placed on any Spring
     bean, it specifies that the properties of that bean can be
     injected from properties in the Spring environment.

   It is then immediate to understand the logic. You can check at it
   in the book and online but you get the essential idea of beans and
   property injection and how that works.

   
** TODO continue from configuring with profiles. 
