<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Git Useful Commands | Bits of Experience</title>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://marcohassan.github.io/bits-of-experience/posts/git-useful-commands/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Marco Hassan">
<link rel="prev" href="../spark-session-initalization/" title="Spark Session Initialization, RDD and DataFrames" type="text/html">
<link rel="next" href="../Docker/" title="Docker" type="text/html">
<meta property="og:site_name" content="Bits of Experience">
<meta property="og:title" content="Git Useful Commands">
<meta property="og:url" content="https://marcohassan.github.io/bits-of-experience/posts/git-useful-commands/">
<meta property="og:description" content="img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-08-29T16:40:59+02:00">
<meta property="article:tag" content="git">
<meta property="article:tag" content="magit">
</head>
<body>
    <a href="#page-content" class="sr-only sr-only-focusable">Skip to main content</a>
    
    <section class="social"><ul>
<li><a href="../../pages/aboutme/" title="About me"><i class="fa fa-user-circle"></i></a></li>
            <li><a href="../../pages/bits-of-experience-a-readable-view-on-my-study-adventures/" title="Home"><i class="fa fa-home"></i></a></li>
            <li><a href="../../index.html" title="Blog"><i class="fa fa-edit"></i></a></li>
            <li><a href="../../pages/emacs/" title="A life Configuring Emacs"><i class="fa fa-code"></i></a></li>
            <li><a href="../../pages/papers/" title="Term and Research Papers"><i class="fa fa-university"></i></a></li>
            <li><a href="../../pages/foto-blog/" title="Foto Blog"><i class="fa fa-camera-retro"></i></a></li>
            <li><a href="https://github.com/MarcoHassan" title="My Github"><i class="fab fa-github"></i></a></li>
            <li><a href="https://stackoverflow.com/users/9731177/mhass" title="My Stack"><i class="fab fa-stack-overflow"></i></a></li>
            <li><a href="../../rss.xml" title="RSS"><i class="fa fa-rss"></i></a></li>
            <li><a href="../../categories/index.html" title="Tags"><i class="fa fa-tags"></i></a></li>
    
    

        </ul></section><section class="page-content"><div class="content" rel="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Git Useful Commands</a></h1>

        <div class="metadata">
            <p class="dateline"><a href="." rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2019-08-29T16:40:59+02:00" itemprop="datePublished" title="2019-08-29 16:40">2019-08-29 16:40</time></a></p>
            <p class="byline author vcard"> <i class="fa fa-user"></i> <span class="byline-name fn" itemprop="author">
                    Marco Hassan
            </span></p>
            
        <p class="sourceline"><a href="index.org" class="sourcelink"><i class="fa fa-file-code"></i> Source</a></p>

            

            
    <div class="tags">
<h3 class="metadata-title">
<i class="fa fa-tags"></i> Tags:</h3>
        <ul itemprop="keywords" class="tags-ul">
<li><a class="tag p-category" href="../../categories/git/" rel="tag">git</a></li>
            <li><a class="tag p-category" href="../../categories/magit/" rel="tag">magit</a></li>
        </ul>
</div>

        </div>
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <style>
img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>
<p>
So here are some notes about some useful commands in git.
</p>

<p>
I might start to use it again from the command line as magit in my
emacs is dead slow on Windows OS.
</p>

<p>
I read online that there are some fundamental issues with it on
Windows.
</p>

<p>
This is not the only program where I am experiencing some performance
hiccup on Windows systems.
</p>

<p>
I will switch back to Mac soon as it seems that here in the company
they started to offer the possibility to have one. Have to wait a
couple of months for it still as I have to wait for the migration of
the IT systems to the cloud to have proper access to everything
without having to manually make new auth-modules. 
</p>

<!-- TEASER_END -->

<div id="outline-container-org6a0f401" class="outline-2">
<h2 id="org6a0f401">Three Pictures to Understand it all</h2>
<div class="outline-text-2" id="text-org6a0f401">
<p>
I had to prepare a presentation for my fellow colleagues.
</p>

<p>
Basically it is the hard prove that a lot of people work but do not
think. Me included for quite a bit of time. Now I am starting to see
the things as they truly are.
</p>

<p>
Basically once I was forced to take a look on that helicopter I was
able to understand all of git and the notes I created in time in an
even better way. Maybe that would have not been possible straight
away as this was possible through an inductive line of thinking.
</p>

<p>
Anyways, from here on you should be able to understand git through
the following three pictures:
</p>

<img src="../../images/Screenshot%202022-09-05%20135034.png" class="center"><img src="../../images/Screenshot%202022-09-05%20135122.png" class="center"><img src="../../images/Screenshot%202022-09-05%20135153.png" class="center">
</div>
</div>



<div id="outline-container-orgf6e0c21" class="outline-2">
<h2 id="orgf6e0c21">Commands and confused notes</h2>
<div class="outline-text-2" id="text-orgf6e0c21">
</div>
<div id="outline-container-org91395fb" class="outline-3">
<h3 id="org91395fb">On the right way to work and commit on git</h3>
<div class="outline-text-3" id="text-org91395fb">
<p>
I also took the habit of making multiple commits per different logic
chuncks of the modifications or as well for individual files.
</p>

<p>
In such a way it is easier to keep track of your changes. You will
read the different logical portions of your code and it will be easy
for you to switch back to them.
</p>

<p>
This is ultimately the way of working and thinking in git. You
understand it by the default way git is implemented.
</p>

<p>
You see that then if you rebase you rebase to some particular very
well defined logical unit - and you keep your other future changes.
</p>

<p>
Check at the following entry from <a href="https://stackoverflow.com/questions/46275070/why-do-i-get-conflicts-when-i-do-git-revert">this post here</a>.
</p>

<hr>
<p>
That's actually not what revert does. Revert doesn't "take you back
to" that commit and pretend that subsequent commits didn't
happen. It applies a logical negation of a single commit - and that
commit alone - leaving subsequent commits in place. 
</p>

<p>
Let's say you have some initial commit of some file - let's call it commit #1 for simplicity - and the file looks like this:
</p>

<pre class="example" id="orgf2a498a">
One
Two
Three
Four
</pre>

<p>
Now let's say you have a commit #2 that changes one line:
</p>

<pre class="example" id="orga906a37">
One
2
Three
Four
</pre>

<p>
And finally, commit #3 that changes a different line:
</p>

<pre class="example" id="org658f8e6">
One
2
Three
4
</pre>

<p>
If you try to revert commit #2, it will undo only the line changed
in that commit, and leave the changes introduced in commit #3, so
the result will be: 
</p>

<pre class="example" id="orgd1dedba">
One
Two
Three
4
</pre>

<p>
Now, if there was a subsequent commit that had changed the same line
as the commit that you're trying to revert, then you'll have a
conflict. For example, let's say you have a commit #4 that also
changed the second line: 
</p>

<pre class="example" id="org5bcc208">
One
TWO
THREE
4
</pre>

<p>
Now if your HEAD is commit #4 and you try to revert commit #2, you
will have a conflict. Revert expects to take second line back - to
undo the changes made in commit #2. So it expects the second line to
currently be 2, and it will then revert it to what it was in the
previous commit, setting it to Two.
</p>

<p>
However, that expectation was invalidated, since commit #4 had also
changed it. So you have a conflict.
</p>

<p>
If your goal isn't to revert at all, but to get back to commit #1
and ignore all the changes that have gone on since then, then you
want to reset instead of revert.
</p>

<pre class="example" id="orge00f696">
git reset --hard 1 
</pre>
</div>
</div>

<div id="outline-container-orgcb2f5a2" class="outline-3">
<h3 id="orgcb2f5a2">On staging and committing different parts of different files separately</h3>
<div class="outline-text-3" id="text-orgcb2f5a2">
<p>
This is an important concept that relates to the way git commits
work as seen before.
</p>

<p>
So far I was rather clumsy in my commits… meaning that I was
either committing entire file edits or nothing. This was fine as
pure software development was not my primary task.
</p>

<p>
Things are slowly changing such that it is important to adjust to
the new conditions.
</p>

<p>
Now, when working on projects and edits that last for multiple days
you might have to add piece of code to try things out that is not
really beneficial for the ultimate solution. The question is
then… can you commit that part of the code separately. In such a
way it will be possible to split the commits and potentially revert
to edits previously made without having to unwind all of the trial
and error crap that you used in the code.
</p>

<p>
In git you can do that as follows:
</p>

<div class="highlight"><pre><span></span>   git add --patch
</pre></div>

<p>
Then git will start asking you interactively if you want to stage
different edits within a file or not.
</p>

<p>
This is not the most user friendly way to do that. Check out <a href="https://filip-prochazka.com/blog/git-commit-only-parts-of-a-file">this
url</a> in this sense.
</p>

<p>
Note that the point made in the comment is correct. Once you are set
up with your CI pipeline things will not look that linear. But leave
that reasoning and solution finding for a later timepoint.
</p>

<p>
Note finally that magit - your emacs - tool is best suited for
performing this task. You never noticed / never thought about
it. But there basically the file is already split in the different
hunks of edits. You can then stage the different as usual by going
to the relevant hunk and pressing <code>s</code>, from there on is your very
classical workflow so nothing new under the sun. 
</p>
</div>
</div>

<div id="outline-container-org125ccf4" class="outline-3">
<h3 id="org125ccf4">On the many files you touch that you do not want to touch</h3>
<div class="outline-text-3" id="text-org125ccf4">
<p>
It is normal to make minor modifications to multiple files when you
edit the files of a larger project.
</p>

<p>
You enter here and there in a ton of files and especially if you use
emacs it is easy to add a space or a new line because of the many
shortcuts.
</p>

<p>
So basically what you do then is just to stage the files you
want. You then write your different commits for them.
</p>

<p>
You then push to the origin.
</p>

<p>
You then fetch from the origin and reset your local repo based on
it.
</p>

<p>
Like this you will have eliminated all of the minor modifications
that were unintendended and you keep your commits clean.
</p>

<p>
You can do that with the following command
</p>

<div class="highlight"><pre><span></span>   git fetch  <span class="c1"># will fetch the latest changes on the remote</span>
   git reset --hard origin/master <span class="c1"># will set your local branch to match the representation of the remote just pulled down.</span>
</pre></div>

<p>
This is suboptimal - not using this anymore - you can rather use the
<a href="#org1c3351d">Discarding directly through Magit</a> - more user-friendly way.
</p>
</div>
</div>

<div id="outline-container-orgc83a0c6" class="outline-3">
<h3 id="orgc83a0c6">On discarding all of the unstaged edits</h3>
<div class="outline-text-3" id="text-orgc83a0c6">
<div class="highlight"><pre><span></span>   git checkout -- .
</pre></div>

<p>
This is suboptimal - not using this anymore - you can rather use the
<a href="#org1c3351d">Discarding directly through Magit</a> - more user-friendly way.
</p>
</div>
</div>

<div id="outline-container-org3f2addc" class="outline-3">
<h3 id="org3f2addc">On stash</h3>
<div class="outline-text-3" id="text-org3f2addc">
<p>
So this is a powerful command.
</p>

<p>
This is essentially used to put some changes in some buffer that
you can then pop somewhere else.
</p>

<p>
For instance say that you did changes on the master branch, but you
actually should have done them in some other branch. If you try to
change branch you will get errors cause you cannot change branch
until you staged these commits.
</p>

<p>
The different possibility is to put them in the stash
stack/buffer.
</p>

<p>
Then you can switch branch and pop that stash in the branch of
choice after changing it.
</p>

<p>
Another option is the one of stashing, pulling and then unstashing,
making ultimately a rebase after including the pull.
</p>

<p>
Everything is explain as well <a href="https://www.quora.com/Whats-the-difference-between-git-stash-and-git-stage">here</a>.
</p>
</div>
</div>

<div id="outline-container-org2146d66" class="outline-3">
<h3 id="org2146d66">On renaming commits</h3>
<div class="outline-text-3" id="text-org2146d66">
<p>
This is quite useful as you might decide to alter the structure of
your project.
</p>

<p>
Think for instance about changing a commit to a different jira
ticket or so.
</p>

<p>
Then you can do it with the <code>rebase</code> property.
</p>

<p>
You can then rename the different commits according to the
following schema:
</p>

<img src="../../images/Screenshot%202022-09-19%20115422.png" class="center">
</div>
</div>
</div>


<div id="outline-container-orgfbe47f1" class="outline-2">
<h2 id="orgfbe47f1">Magit component</h2>
<div class="outline-text-2" id="text-orgfbe47f1">
</div>
<div id="outline-container-org1c3351d" class="outline-3">
<h3 id="org1c3351d">Discarding directly through Magit</h3>
<div class="outline-text-3" id="text-org1c3351d">
<p>
This is quite useful.
</p>

<p>
In the sense you might often introduce a space by error or other
minor changes that you are not really interested in.
</p>

<p>
You do not want to commit everything. This will over-water too much
your code such that you will not be able anymore to distinguish
important commits from trivial  things.
</p>

<p>
Think for instance the clutter in your magit-blame component.
</p>

<p>
Then how you simply do it is by going to a particular commitment
and use the <code>k</code> flag.
</p>

<p>
This will discard all of the relevant modifications for that
particular component/file.
</p>
</div>
</div>

<div id="outline-container-org8f3c7dc" class="outline-3">
<h3 id="org8f3c7dc">On worktree</h3>
<div class="outline-text-3" id="text-org8f3c7dc">
<p>
Ok so here some notes about magit itself.
</p>

<p>
So one of the best things is for ediffing. I already talked about it
in a different post. Go to check this out when you have time.
</p>

<p>
So one of the features I particularly like is the one of showing the
worktree. There you can view the history. You can open individual
commits and see what you changed in each etc.
</p>

<p>
Now say that you want to go back to a previous commit… <b>exactly
that one</b>.. you can reset based on that commit.
</p>
</div>
</div>

<div id="outline-container-org9227e7a" class="outline-3">
<h3 id="org9227e7a">Checking changes between two commits</h3>
<div class="outline-text-3" id="text-org9227e7a">
<p>
Then you can change exactly what you changed on a given file between
two commits.
</p>

<p>
Then you can open the log worktree <code>l</code> in magit console, with
<code>Ctrl-space</code> you select the range of commits. Then <code>E</code> for Ediff
and finally <code>r</code> for range.
</p>

<p>
This will open up your ediff buffer from which you can work as per
your merging post etc.
</p>
</div>
</div>

<div id="outline-container-org8805fb4" class="outline-3">
<h3 id="org8805fb4">Magit reverting to a particular commit.</h3>
<div class="outline-text-3" id="text-org8805fb4">
<p>
Magit reversion is bounded to <code>V</code> in magit.
</p>

<p>
What magit does is then to create a new commit with the specific
reversion.
</p>

<p>
There are two options that you can check in more depth for making
that reversion. I understand that the difference between the two is
minimal. I think it is something in the direction do you want to
edit and insert the commit message yourself or not.
</p>

<p>
In any case the only bit you should remember is the following.
</p>

<p>
To decide which commits to revert you first enter your worktree <code>l
   l</code> in the magit console.
</p>

<p>
Then you select the commits of interest (recall with <code>SPC</code> bar) and
just then, when the commits are selected you revert. 
</p>
</div>
</div>

<div id="outline-container-org0e97d81" class="outline-3">
<h3 id="org0e97d81">Cherry Picking in Magit</h3>
<div class="outline-text-3" id="text-org0e97d81">
<p>
This is a very nice feature. The essential is to say don't merge
everything from the other branch but just a specific commit.
</p>

<p>
You can see how to do that in the plain way from the shell at the
following <a href="https://mattstauffer.com/blog/how-to-merge-only-specific-commits-from-a-pull-request/">entry</a>.
</p>

<p>
In magit - at least my version you do it in the following way.
</p>

<p>
You open your graph with all of the commits. <b>You go on the branch
where your commit sits</b> - the commit you want to pick and import
into another branch.
</p>

<p>
You open the commit tree there <code>l l</code>.
</p>

<p>
Then you go on the commit you want to copy (or potentially you
highlight a couple of commits C-Space and select the relevant).
</p>

<p>
Then you go with <code>A A</code>. You will then select the branch you want
to import the commit to and badaboom, you are done.
</p>
</div>
</div>

<div id="outline-container-orge2cbf71" class="outline-3">
<h3 id="orge2cbf71">Gitignore in magit</h3>
<div class="outline-text-3" id="text-orge2cbf71">
<p>
So that was quite annoying as well.
</p>

<p>
For some reason gitignore was not working.
</p>

<p>
I.e. it was not read by magit.
</p>

<p>
This even after removing all of the files from the
cache. I.e. after <code>git rm -rf --cached .</code>
</p>

<p>
So what I did then was invoking the <code>magit-ignore</code> command.
</p>

<p>
There you specify one file you wish to ignore. A new .gitignore
file was created and magit was then in sync with it.
</p>

<p>
So do not understand exactly why that was the case but take it as
good and create the gitignore in such a way. Then everything will
work for your magit. 
</p>
</div>
</div>

<div id="outline-container-orgb46466b" class="outline-3">
<h3 id="orgb46466b">HEAD</h3>
<div class="outline-text-3" id="text-orgb46466b">
<p>
Note that this is important for the reflog of your work.
</p>

<p>
You can check where your head is on Magit by opening the log
option.
</p>

<p>
There you will have a <code>HEAD</code> and a <code>ORIGIN_HEAD</code> option where you
can track the HEAD.
</p>

<p>
Via CLI you can use the following:
</p>

<p>
<code>git rev-parse HEAD</code>: will point to the commit the head is pointing
at.
</p>

<p>
<code>git symbolic-ref HEAD</code>: will point to the branch that the HEAD is
pointing at.
</p>
</div>
</div>

<div id="outline-container-orga609764" class="outline-3">
<h3 id="orga609764">Magit-blame</h3>
<div class="outline-text-3" id="text-orga609764">
<p>
This is a nice way to see the specific commit for a specific bit of
code.
</p>

<p>
It happened to me recently that there was a new piece of logic in
the code base that was not there before and was breaking my
workflow.
</p>

<p>
Could not understand it and set it into a frame.
</p>

<p>
So I wanted to understand who committed it in order to ask for the
reasoning behind it such that I could deal at best with it.
</p>

<p>
It turns out that <code>git blame</code> was the solution. It is a nice way in
order to inspect this specific bit of information.
</p>

<p>
Again magit is integrated with it. In order to work with it I
simply had to be in the file where the relevant bit of code sits
in, then you can simply type <code>magit-blame-addition</code>.
</p>

<p>
Then you are basically in magit blame mode. You can then go the
file of a particular commit, open the specifications for the
changes relevant for the particular commit.
</p>

<p>
You can finally quit it with <code>q</code>.
</p>
</div>
</div>

<div id="outline-container-org72d585f" class="outline-3">
<h3 id="org72d585f">Ediffing</h3>
<div class="outline-text-3" id="text-org72d585f">
<p>
Putting it here for consistency.
</p>
</div>
</div>

<div id="outline-container-org8f2c3c1" class="outline-3">
<h3 id="org8f2c3c1">Git stash</h3>
<div class="outline-text-3" id="text-org8f2c3c1">
<p>
In order to leverage this feature, use the <code>z</code> command.
</p>

<p>
Then you can find the official documentation <a href="https://magit.vc/manual/magit/Stashing.html">here</a>.
</p>

<p>
Then simply understand that for instance in order to work in the
most easy way use <code>z</code> <code>z</code> to put the commits in the stash and then
<code>z</code> <code>p</code> to pop it. 
</p>
</div>
</div>

<div id="outline-container-org27ae43f" class="outline-3">
<h3 id="org27ae43f">Renaming Commits Messages</h3>
<div class="outline-text-3" id="text-org27ae43f">
<p>
This can be quite handy at times as it might be easy to write a
wrong message when committing or insert a wrong jira ticket.
</p>

<p>
The idea in this case is to go on the relevant commit, press <code>r</code>
and then select the reword option <code>w</code>.
</p>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../spark-session-initalization/" rel="prev" title="Spark Session Initialization, RDD and DataFrames">Previous post</a>
            </li>
            <li class="next">
                <a href="../Docker/" rel="next" title="Docker">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents © 2022         <a href="mailto:marco.hassan30@gmail.com">Marco Hassan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </section><script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
