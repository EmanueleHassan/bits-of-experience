<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>C++ Quick Refresher | Bits of Experience</title>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://marcohassan.github.io/bits-of-experience/posts/c%2B%2B-quick-refresher/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Marco Hassan">
<link rel="prev" href="../things-to-do-in-zh/" title="A personal Repo - Movies, Art and Things to Do" type="text/html">
<link rel="next" href="../quantitative-finance-some-quick-and-dirty-notes/" title="Quantitative Finance - Some Quick and Dirty Notes" type="text/html">
<meta property="og:site_name" content="Bits of Experience">
<meta property="og:title" content="C++ Quick Refresher">
<meta property="og:url" content="https://marcohassan.github.io/bits-of-experience/posts/c%2B%2B-quick-refresher/">
<meta property="og:description" content="img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-06-08T19:42:09+02:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="oop">
</head>
<body>
    <a href="#page-content" class="sr-only sr-only-focusable">Skip to main content</a>
    
    <section class="social"><ul>
<li><a href="../../pages/aboutme/" title="About me"><i class="fa fa-user-circle"></i></a></li>
            <li><a href="../../pages/bits-of-experience-a-readable-view-on-my-study-adventures/" title="Home"><i class="fa fa-home"></i></a></li>
            <li><a href="../../index.html" title="Blog"><i class="fa fa-edit"></i></a></li>
            <li><a href="../../pages/emacs/" title="A life Configuring Emacs"><i class="fa fa-code"></i></a></li>
            <li><a href="../../pages/papers/" title="Term and Research Papers"><i class="fa fa-university"></i></a></li>
            <li><a href="../../pages/foto-blog/" title="Foto Blog"><i class="fa fa-camera-retro"></i></a></li>
            <li><a href="https://github.com/MarcoHassan" title="My Github"><i class="fab fa-github"></i></a></li>
            <li><a href="https://stackoverflow.com/users/9731177/mhass" title="My Stack"><i class="fab fa-stack-overflow"></i></a></li>
            <li><a href="../../rss.xml" title="RSS"><i class="fa fa-rss"></i></a></li>
            <li><a href="../../categories/index.html" title="Tags"><i class="fa fa-tags"></i></a></li>
    
    

        </ul></section><section class="page-content"><div class="content" rel="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../c%2B%2B-quick-refresher/" class="u-url">C++ Quick Refresher</a></h1>

        <div class="metadata">
            <p class="dateline"><a href="../c%2B%2B-quick-refresher/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2018-06-08T19:42:09+02:00" itemprop="datePublished" title="2018-06-08 19:42">2018-06-08 19:42</time></a></p>
            <p class="byline author vcard"> <i class="fa fa-user"></i> <span class="byline-name fn" itemprop="author">
                    Marco Hassan
            </span></p>
            
        <p class="sourceline"><a href="../c%2B%2B-quick-refresher/index.org" class="sourcelink"><i class="fa fa-file-code"></i> Source</a></p>

            

            
    <div class="tags">
<h3 class="metadata-title">
<i class="fa fa-tags"></i> Tags:</h3>
        <ul itemprop="keywords" class="tags-ul">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
        </ul>
</div>

        </div>
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <style>
img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>
<p>
Ok. This should be a lesson to you. I did quite some notes two years
ago when I was working with it. Also on object oriented programming
etc.
</p>

<p>
Then badaboom; I did not have this blog yet and did not save the notes
in the cloud. Turns out that two years later I will have to work a bit
in C++ for finishing my thesis and implementing everything into the
code. And badaboom; could not work with the previous notes and had to
start from scratch. 
</p>

<p>
Plus I am upskilling my OOP knowledge and make it more theoretical. As
in one of the interviews I lost quite some points as I was not able to
answer quite basic questions of OOP but did not recall all of the
names semantics etc. and got under stress.
</p>

<!-- TEASER_END -->

<div id="outline-container-orgb57712e" class="outline-2">
<h2 id="orgb57712e">Reminder of c++</h2>
<div class="outline-text-2" id="text-orgb57712e">
</div>
<div id="outline-container-orgc2c874b" class="outline-3">
<h3 id="orgc2c874b">Declaration of pointer</h3>
<div class="outline-text-3" id="text-orgc2c874b">
<p>
Note that there are two different things you can declare with the
<code>&amp;</code> operator. You should not confuse these. They look similar but
are not.
</p>

<p>
On the one hand you have <code>references</code> on the other one you have
<code>pointers</code>.
</p>

<p>
These are not the same and should not be confused.
</p>

<p>
So on the one hand you have references. These are implemented as
follows:
</p>

<p>
So you have a reference to x.
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">10.7</span><span class="p">;</span>

      <span class="kt">float</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

      <span class="n">rx</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"the value of the x is: %f "</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
So you see that when you modify <code>rx</code> you are actually also
modifying <code>x</code>. This is the entire idea of reference. You have a
new variable referencing the other one.
</p>

<p>
Note then that there are other subtle things you can do. For
instance passing a reference with <code>const</code> such that you can just
read the referenced variable but you cannot write it itself.
</p>

<p>
See for instance the below that would yield an error.
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">10.7</span><span class="p">;</span>

      <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

      <span class="n">rx</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"the value of the x is: %f "</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
But check that the following works:
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">10.7</span><span class="p">;</span>

      <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

      <span class="n">x</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"the value of the rx is: %f "</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
Check at pointers next.
</p>
</div>

<div id="outline-container-orgb777b7b" class="outline-4">
<h4 id="orgb777b7b">Importance of references in c++</h4>
<div class="outline-text-4" id="text-orgb777b7b">
<p>
Note that references are especially important in c++ as with it
you can specify arguments to pass to functions.
</p>

<p>
It is actually a fun idea. so you see that there is the
difference that you do not have to pass a variable do the
operations and <b>return</b> the object at the end of the function
with the performed operations and finally assign it again to the
memory. you save some operations in this sense.
</p>

<p>
See also the second benefit of passing by reference:
</p>

<blockquote>
<p>
a function can use the reference parameter to return multiple values to the calling
function. Passing by value allows only one result as a return value, unless you
resort to using global variables
</p>
</blockquote>

<p>
Such that it is immediate to see why the above is especially
important that is straightforward. You can perform operations on
<b>Multiple values</b>
</p>

<p>
Check for instance the following:
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">void</span> <span class="nf">test</span><span class="p">(</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">a</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">;}</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">10.7</span><span class="p">;</span>

      <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">;</span>

      <span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"the value of the x, y is: %f, %f "</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
So you see that the above is working as a charm and a is a
reference to x in the function.
</p>

<p>
Note that the return type of a function can also be a referenced
object.
</p>

<p>
Consider the following:
</p>

<div class="highlight"><pre><span></span>    <span class="n">string</span><span class="o">&amp;</span> <span class="nf">message</span><span class="p">()</span> <span class="c1">// Reference!</span>
    <span class="p">{</span>
    <span class="k">static</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Today only cold cuts!"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
Then it is immediate to understand that the above would create a
reference to a static string with the content defined above.
</p>

<p>
Then you can also make the referenced objects returned by a
function read only by passing the <code>const</code> operator in the
following way so to say:
</p>

<div class="highlight"><pre><span></span>    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">();</span> <span class="c1">// Read-only</span>
</pre></div>

<p>
It is therefore clear and immediate that c++ as a language allows
you a much richer modeling set.
</p>
</div>
</div>
</div>


<div id="outline-container-org2fe7234" class="outline-3">
<h3 id="org2fe7234">Pointers and Addresses</h3>
<div class="outline-text-3" id="text-org2fe7234">
<p>
So here is the syntax for defining pointers.
</p>

<p>
Recall that a pointer is an expression that represents both the
address and type of another object.
</p>

<p>
You can either note that creating the address operator <code>&amp;</code> for a
<b>given object</b> creates a pointer to that object.
</p>

<p>
So you can for instance get the address of a defined <code>int var</code>
with the following: <code>&amp;var</code>.
</p>

<p>
A pointer points to a memory address and simultaneously <i>indicates
by its type</i> how the memory address can be read or written to.
</p>

<p>
You can as well define <i>pointer variables</i>. This are used as
variables to store pointers references.
</p>

<p>
See for instance the following to understand this:
</p>

<div class="highlight"><pre><span></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">// or: int* ptr; // creates a variable to store a pointer to an int.</span>
</pre></div>

<p>
After declaring a pointer variable, you must point the pointer at
a memory address. The program on the opposite page does this using
the statement
</p>

<div class="highlight"><pre><span></span>    <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">;</span>
</pre></div>

<p>
So once you defined your pointers, as in the following, this is
generally the syntax you work with
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

      <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">;</span>

      <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Let px point to x.</span>
      <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="mf">12.3</span><span class="p">;</span> <span class="c1">// Assign the value 12.3 to x</span>
      <span class="o">*</span><span class="n">px</span> <span class="o">+=</span> <span class="mf">4.5</span><span class="p">;</span> <span class="c1">// Increment x by 4.5.</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"the value of the x, px: %f, %f "</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>  
</pre></div>

<p>
So you see that the way you operate with pointers and references
is the same. What changes is the fact the one is a distinct object
and the other is not.
</p>

<p>
Notice as well the following syntax for pointer declaration:
</p>

<div class="highlight"><pre><span></span>    <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</pre></div>

<p>
The above essentially means: you create a pointer <code>ptr</code> pointing
to a <code>long*</code> i.e. an address with a long value. This is it essentially.
</p>

<img src="../../images/Bildschirmfoto_2021-06-09_um_17.07.34.png" class="center"><p>
Note that this is the difference among adress reference &amp;variable
and pointer. A pointer is a separate object. It can changes
referenced object. If you declare a reference when initializing a
variable say <code>a = &amp;x</code> you are creating an alias for the object
x. This reference cannot change at a later point. and the variable
has not an address in memory that references <code>a</code> itself. This is
different when working with pointers.
</p>

<p>
often references are used when declaring functions. these are
passed as arguments. as you do not have to pass entire objects to
the function then but rather you point to the objects of interest
in memory.
</p>
</div>
</div>


<div id="outline-container-org981c477" class="outline-3">
<h3 id="org981c477">Passing by pointer - this is a third option apart from passing by reference and value.</h3>
<div class="outline-text-3" id="text-org981c477">
<p>
The idea is the following:
</p>

<p>
you declare a function parameter to allow an address to be passed
to the function as an argument.
</p>

<p>
you can then do this as follows:
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="kt">float</span> <span class="o">*</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Prototype of swap()</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>

     <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">11.1F</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">22.2F</span><span class="p">;</span>

     <span class="n">swap</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">);</span>

     <span class="n">printf</span><span class="p">(</span><span class="s">"value of x: %f </span><span class="se">\n</span><span class="s">value of y: %f"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>

     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">}</span> 

    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="kt">float</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span> <span class="c1">// so notice that you pass a pointer</span>
				     <span class="c1">// to x, and then this extract the</span>
				     <span class="c1">// value in pointer syntax</span>
    <span class="p">{</span>
     <span class="kt">float</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// Temporary variable</span>
     <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span> <span class="c1">// At the above call p1 points</span>
     <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="c1">// to x and p2 to y.</span>
     <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
So you can see that this is ultimately extremely close to the
reference idea in the way it works. It is just an added layer of
customizing and making your code more granular.    
</p>
</div>
</div>


<div id="outline-container-org80a0e1d" class="outline-3">
<h3 id="org80a0e1d">Diff point and references</h3>
<div class="outline-text-3" id="text-org80a0e1d">
<p>
References are similar to pointers: both refer to an object in
memory. However, a pointer is <b>not merely an alias</b> but an
<b>individual object that has an identity separate from the object</b> it
references.
</p>

<p>
A pointer has its own memory address and can be manipulated by
pointing it at a <i>new memory address</i> and thus referencing a
different object.
</p>
</div>
</div>


<div id="outline-container-orgad8a496" class="outline-3">
<h3 id="orgad8a496">typedef</h3>
<div class="outline-text-3" id="text-orgad8a496">
<p>
this is a simple way to give a new name to your specified
objects.
</p>

<p>
For instance you might rephrase an <code>unsigned char</code> to a <code>BYTE</code> by:
</p>

<p>
<code>typedef unsigned char BYTE</code>
</p>
</div>
</div>




<div id="outline-container-org6cd89fc" class="outline-3">
<h3 id="org6cd89fc">constructors and member initialization functions</h3>
<div class="outline-text-3" id="text-org6cd89fc">
<div class="highlight"><pre><span></span>    <span class="n">factor</span><span class="p">(</span><span class="n">factor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">v_</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">t_</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">t_</span><span class="p">),</span> <span class="n">c_</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">c_</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">};</span>
</pre></div>

<p>
This is the <i>member initializer notation</i>.
</p>

<p>
Understand the initializer notation in the following example:
</p>

<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">Box</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
	<span class="c1">// Default constructor</span>
	<span class="n">Box</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// with no elemnts</span>

	<span class="c1">// Initialize a Box with equal dimensions (i.e. a cube)</span>
	<span class="k">explicit</span> <span class="n">Box</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_width</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">m_length</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">m_height</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// member init list</span>
	<span class="p">{}</span> 

	<span class="c1">// Initialize a Box with custom dimensions</span>
	<span class="n">Box</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
	    <span class="o">:</span> <span class="n">m_width</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">m_length</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">m_height</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="kt">int</span> <span class="n">Volume</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_width</span> <span class="o">*</span> <span class="n">m_length</span> <span class="o">*</span> <span class="n">m_height</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
	<span class="c1">// Will have value of 0 when default constructor is called.</span>
	<span class="c1">// If we didn't zero-init here, default constructor would</span>
	<span class="c1">// leave them uninitialized with garbage values.</span>
	<span class="kt">int</span> <span class="n">m_width</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">m_length</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">m_height</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="p">};</span>
</pre></div>

<p>
The general page for understanding constructors <a href="https://docs.microsoft.com/en-us/cpp/cpp/constructors-cpp?view=msvc-160">is this</a>.
</p>

<p>
Another example for the constructor is this:
</p>

<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">TelList</span>
    <span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
      <span class="n">Element</span> <span class="n">v</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span> <span class="c1">// The array and the current</span>
      <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// number of elements</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">TelList</span><span class="p">(){</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgc489a98" class="outline-3">
<h3 id="orgc489a98">size<sub>t</sub>
</h3>
<div class="outline-text-3" id="text-orgc489a98">
<p>
this is used everywhere in the code. and I needed to make sense of
it. turns out that it is a standard library method.
</p>

<p>
<code>std::size_t</code> can store the maximum size of a theoretically possible
object of any type (including array). A type whose size cannot be
represented by <code>std::size_t</code> is ill-formed (since C++14) On many
platforms (an exception is systems with segmented addressing)
<code>std::size_t</code> can safely store the value of any non-member pointer,
in which case it is synonymous with std::uintptr<sub>t</sub>.
</p>

<p>
<code>std::size_t</code> is commonly used for array indexing and loop
counting. Programs that use other types, such as unsigned int, for
array indexing may fail on, e.g. 64-bit systems when the index
exceeds UINT<sub>MAX</sub> or if it relies on 32-bit modular arithmetic.
</p>
</div>
</div>


<div id="outline-container-org258dadc" class="outline-3">
<h3 id="org258dadc">arrays</h3>
<div class="outline-text-3" id="text-org258dadc">
<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">MAXCNT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Constant</span>
    <span class="kt">float</span> <span class="n">arr</span><span class="p">[</span><span class="n">MAXCNT</span><span class="p">],</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// Array, temp. variable so like this you</span>
			  <span class="c1">// declare both the array as the temporal</span>
			  <span class="c1">// variable x as floats.</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span> <span class="c1">// Index, quantity</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter up to 10 numbers </span><span class="se">\n</span><span class="s">"</span>
    <span class="o">&lt;&lt;</span> <span class="s">"(Quit with a letter):"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXCNT</span> <span class="o">&amp;&amp;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The given numbers:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

<p>
An array contains multiple objects of identical types stored
sequentially in memory.
</p>


<p>
The definition includes the array name and the type and number of
array elements.
</p>

<p>
An example:
</p>

<div class="highlight"><pre><span></span>    <span class="kt">int</span> <span class="n">myFirstArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// Array name</span>
</pre></div>

<p>
If you want to initialize the arrays directly when you initialize
them use the following notation passing a list with the elements:
</p>

<div class="highlight"><pre><span></span>    <span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span> <span class="p">};</span>
</pre></div>

<p>
If the array length is explicitly stated in the definition and is
larger than the number of initial values, any remaining array
elements are set to zero.
</p>

<p>
Locally defined arrays are created on the stack at program
runtime. Arrays that occupy a large amount of memory (e.g., more
than one kbyte) should be defined as global or static.
</p>

<p>
you can also use arrays to save objects of a given class. this can
be done in the following way:
</p>

<div class="highlight"><pre><span></span>    <span class="o">&lt;</span><span class="n">class_name</span><span class="o">&gt;</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="c1">// where 10 = dimension.</span>
</pre></div>

<p>
Such class arrays can be initialized using class arrays
</p>

<div class="highlight"><pre><span></span>    <span class="n">Result</span> <span class="n">temperatureTab</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="c1">// this is your class array. containing all of the objects you</span>
      <span class="c1">// will save in the array in memory.</span>
    <span class="n">Result</span><span class="p">(</span> <span class="mf">-2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span>
    <span class="n">Result</span><span class="p">(</span> <span class="mf">3.5</span><span class="p">),</span> <span class="c1">// At present time</span>
    <span class="mf">4.5</span><span class="p">,</span> <span class="c1">//  Instead of using a constructor with one argument, you can</span>
	 <span class="c1">//  simply supply the argument. The default constructor is</span>
	 <span class="c1">//  then called for the remaining elements.</span>
    <span class="n">Result</span><span class="p">(</span> <span class="n">temp1</span><span class="p">),</span> <span class="c1">// Copy constructor</span>
    <span class="n">temp2</span> <span class="c1">// Just so</span>
    <span class="p">};</span>
</pre></div>


<p>
If the size of an array is not stated explicitly, the number of
values in the initialization list defines the size of the array.
</p>

<p>
The public interface of the objects in the array is available for
use as usual. I.e. you can call methods in the following way:
</p>

<div class="highlight"><pre><span></span>    <span class="n">temperatureTab</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">setTime</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">21</span><span class="p">);</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgd7f7cbf" class="outline-3">
<h3 id="orgd7f7cbf">vectors</h3>
<div class="outline-text-3" id="text-orgd7f7cbf">
<p>
Vectors are implemented in the <code>standard template library</code>.
</p>

<p>
Specifically used to work with dynamic data, C++ vectors <b>may
expand depending on the elements they contain</b>. That makes it
different from a fixed-size array.
</p>

<p>
C++ vectors can automatically manage storage. It is efficient if
you add and delete data often.
</p>

<p>
In C++ vectors, automatic reallocation happens whenever the total
amount of memory is used.
</p>

<p>
The syntax for declaring a vector is the following
</p>

<div class="highlight"><pre><span></span>    <span class="n">vector</span> <span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">variable</span> <span class="p">(</span><span class="n">elements</span><span class="p">)</span>
</pre></div>

<p>
So for instance
</p>

<div class="highlight"><pre><span></span>    <span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rooms</span> <span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</pre></div>

<p>
Note that the number of elements is optional. this because as
mentioned we can enlarge or decrease the size of the vectors at
runtime.
</p>

<p>
To resize a vector to match a given shape - i.e. number of
elements use the following structure:
</p>

<div class="highlight"><pre><span></span>    <span class="n">rooms</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

<p>
check at the initializer with <code>-1</code> and understand what this <code>-1</code>
is exactly doing:
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hello</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span> <span class="c1">// so notice that the second argument is the intializator number for the vector. </span>

       <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hello</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

       <span class="n">printf</span><span class="p">(</span><span class="s">"check at the size of this vector: %d"</span><span class="p">,</span> <span class="n">hello</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
     <span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org371ce06" class="outline-3">
<h3 id="org371ce06">templates</h3>
<div class="outline-text-3" id="text-org371ce06">
<p>
check at <a href="https://www.youtube.com/watch?v=a-3hcS-tEn0">this video</a> for understanding templates. basically it is
nothing new. you just specify blueprints that you can then call by
name. the properties are then derived for such a template.
</p>
</div>
</div>


<div id="outline-container-org0491fae" class="outline-3">
<h3 id="org0491fae">conditional operator</h3>
<div class="outline-text-3" id="text-org0491fae">
<p>
I guess this is as in your javascript notes.
</p>

<p>
This basically means if the expression <code>m_evidence.empty()</code>
evaluates to true then return <code>false</code> otherwise return <code>true</code>
</p>

<div class="highlight"><pre><span></span>    <span class="kt">bool</span> <span class="n">plainEvidence</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_evidence</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</div>


<div id="outline-container-org17376d4" class="outline-3">
<h3 id="org17376d4">some standard functions</h3>
<div class="outline-text-3" id="text-org17376d4">
<div class="highlight"><pre><span></span>    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">m_lockedFactors</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_lockedFactors</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
	    <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">" "</span><span class="p">));</span>
</pre></div>

<p>
like this you pass each of the locked factors from begin to end to
the set to the ostream<sub>iterator</sub> that would then cout these.
</p>
</div>
</div>



<div id="outline-container-org2e13089" class="outline-3">
<h3 id="org2e13089">linker</h3>
<div class="outline-text-3" id="text-org2e13089">
<p>
puahh.. I recall that was messy. I have to ask again the pc to
martina to get back all of my notes and build on that. was quite
annoying with the linker stuff etc. 
</p>
</div>
</div>


<div id="outline-container-orgafac106" class="outline-3">
<h3 id="orgafac106">Macros</h3>
<div class="outline-text-3" id="text-orgafac106">
<p>
There is no big point for Macros to this stage. You can generally
think as them as global variables and functions. 
</p>

<p>
So I mean the point for it is normal. Nothing new.
</p>

<p>
You usually define a header file where you define all of the
Macros relevant for your program. Then you import the header to
the relevant scripts of your program.
</p>

<img src="../../images/Bildschirmfoto_2021-06-01_um_10.19.00.png" class="center">b

<p>
Note that the Macros has benefit in the way they are operated by
the compiler. This goes low level and is not that interesting to
me at the moment.
</p>

<p>
Note that you can use with <code>conditional inclusion</code> when working
with Macros. The idea is to tell the compiler to just compile the
section if a the macro is definedâ€¦
</p>

<div class="highlight"><pre><span></span>    <span class="cp">#ifdef name</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="c1">// Block, which will be compiled</span>
    <span class="c1">// if name is defined.</span>
    <span class="cp">#endif</span>
</pre></div>

<p>
Note that you can also work with <code>#ifndef</code> there the idea is to
compile the source block up until the next <code>#endif</code> statement.
</p>

<p>
See for instance in this sense in Merlin the following strucutre
</p>

<div class="highlight"><pre><span></span>    <span class="cm">/*</span>
<span class="cm">     * util.h</span>
<span class="cm">     *</span>
<span class="cm">     *  Created on: 24 Mar 2015</span>
<span class="cm">     *      Author: radu</span>
<span class="cm">     *</span>
<span class="cm">     * Copyright (c) 2015, International Business Machines Corporation</span>
<span class="cm">     * and University of California Irvine. All rights reserved.</span>
<span class="cm">     *</span>
<span class="cm">     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span>
<span class="cm">     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm">     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm">     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="cm">     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm">     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="cm">     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm">     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="cm">     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm">     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm">     */</span>

    <span class="c1">/// \file util.h</span>
    <span class="c1">/// \brief Various utilities</span>
    <span class="c1">/// \author Radu Marinescu radu.marinescu@ie.ibm.com</span>


    <span class="cp">#ifndef IBM_MERLIN_UTIL_H_</span>
    <span class="cp">#define IBM_MERLIN_UTIL_H_</span>

    <span class="c1">// code.....</span>
    <span class="c1">// code.....</span>

    <span class="cp">#endif </span><span class="c1">// re-include</span>
</pre></div>


<p>
So I do not see exactly the point of why this is used. but
probably cause you might call this from multiple places in the
code such that it is just complied one time.
</p>

<p>
This is in fact what happens above as:
</p>

<blockquote>
<p>
A symbol without a substitute text is often used to identify header files and avoid
multiple inclusion.
</p>
</blockquote>
</div>
</div>


<div id="outline-container-org8a7c050" class="outline-3">
<h3 id="org8a7c050">Object Oriented Programming</h3>
<div class="outline-text-3" id="text-org8a7c050">
<p>
This has a quite easy syntax. Think for instance to the following:
</p>

<div class="highlight"><pre><span></span>    <span class="c1">// car.h: Definition of baseclass Car and</span>
    <span class="c1">// of the derived class PassCar</span>
    <span class="c1">// --------------------------------------------------</span>
    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">Car</span> <span class="c1">// Base class</span>
    <span class="p">{</span>

    <span class="k">private</span><span class="o">:</span>

      <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
      <span class="n">string</span> <span class="n">producer</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="c1">// Default Constructor:</span>
      <span class="n">Car</span><span class="p">(</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">0L</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">prod</span> <span class="o">=</span> <span class="s">""</span><span class="p">);</span>

      <span class="c1">// Access methods:</span>
      <span class="kt">long</span> <span class="nf">getNr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nr</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="nf">setNr</span><span class="p">(</span> <span class="kt">long</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">getProd</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">producer</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">setProd</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">){</span> <span class="n">producer</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">display</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Display a car</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">PassCar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="c1">// Derived class</span>
    <span class="p">{</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">passCarType</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">sunRoof</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="c1">// Constructor:</span>
      <span class="n">PassCar</span><span class="p">(</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sd</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">h</span> <span class="o">=</span> <span class="s">""</span><span class="p">);</span>

      <span class="c1">// Access methods:</span>
      <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">getType</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">passCarType</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">setType</span><span class="p">(</span> <span class="k">const</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">passCarType</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">bool</span> <span class="n">getSunRoof</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sunRoof</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">setSunRoof</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">b</span> <span class="p">)</span> <span class="p">{</span> <span class="n">sunRoof</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="p">};</span>
</pre></div>

<p>
So you see the syntax. You have a function with the class name in
order to create the class.
</p>

<p>
Then you have simply functions; these are the methods of the
class. As long as they are in the public space they can be
accessed by the usual <code>.</code> notation.
</p>

<p>
Notice the following important characteristic of the derived
classes:
</p>

<img src="../../images/Bildschirmfoto_2021-06-01_um_15.38.32.png" class="center"><p>
I.e. just the public methods are available in the derived class.
</p>

<p>
This ultimately means that methods belonging to derived classes
only have <b>indirect</b> access to the private data members of the base
class.
</p>

<p>
Note that then you can instantiate an object of a class and
perform operations on it via the following syntax:
</p>

<div class="highlight"><pre><span></span>    <span class="kt">void</span> <span class="n">PassCar</span><span class="o">::</span><span class="n">display</span><span class="p">(</span> <span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Car number: "</span>
	   <span class="o">&lt;&lt;</span> <span class="n">getNr</span><span class="p">();</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Producer: "</span>
	   <span class="o">&lt;&lt;</span> <span class="n">getProd</span><span class="p">();</span>  <span class="c1">// note that here you do not have to pass the object as being called from within a constructor what this actually evaluates to is with pointer syntax this-&gt;getProd()</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Type: "</span><span class="o">&lt;&lt;</span> <span class="n">passCarType</span><span class="p">;</span>  
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Type: "</span><span class="o">&lt;&lt;</span> <span class="n">passCarTyp</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">sunRoof</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yes"</span><span class="p">;</span>
	<span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" no"</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>  
</pre></div>
</div>
</div>



<div id="outline-container-org3ef7f82" class="outline-3">
<h3 id="org3ef7f82">Private, protected and public variables and methods</h3>
<div class="outline-text-3" id="text-org3ef7f82">
<p>
when you make this division you decide from where to expose the
data and methods associated to a method.
</p>

<p>
I.e. <code>public</code> it is accessible from everywhere. I.e. even when
running the code inside of the class code - i.e. in a method of
it - you might access the variable. 
</p>

<p>
I.e. <code>private</code> you might just access to the methods and variables
from the very same class they are declared in. I.e. through
methods specified in there etc.
</p>

<p>
I.e. <code>protected</code> you might just access to the methods and variables
from the very same class they are declared in as well as classes
derived from such class.
</p>

<p>
In this sense understand the strucutre of your c++ projects. You
specify the structure and variables in header files together with
the access properties. This will make it much easier for you to
get all of the structure in a quick way.
</p>

<p>
Based on that you would then expand and write the actual code
etc. 
</p>
</div>
</div>

<div id="outline-container-orgd8532a9" class="outline-3">
<h3 id="orgd8532a9">Name Lookup</h3>
<div class="outline-text-3" id="text-orgd8532a9">
<p>
This are general questions you should know the answer for. Last
time at the interview you were tricked by it.
</p>

<p>
When the compiler finds a function as the <code>getProd()</code> above, the
usual way to evaluate it is the following:
</p>

<ul class="org-ul">
<li>the compiler looks for the name of the method called in the derived class first</li>

<li>if the name cannot be found, the compiler walks one step up the
tree and looks for a public method with that name.</li>
</ul>
<p>
This has important consequences, as when defining a derived class
you can overwrite some methods.
</p>

<p>
if a member is redefined in a derived class, it will mask the
corresponding member in the base class.
</p>
</div>
</div>


<div id="outline-container-org2ae58f5" class="outline-3">
<h3 id="org2ae58f5">Overloading</h3>
<div class="outline-text-3" id="text-org2ae58f5">
<p>
Note that you can have multiple methods with the same name but
different arguments. Such that you can keep redefining within the
same class.
</p>

<p>
This is termed <i>overloading</i>.
</p>

<p>
Even if you have redefined a method in a derived class, you can
still call the method in the parent class calling:
<code>bas_class::derived_class();</code>
</p>

<p>
This in the code for a derived class object.
</p>
</div>
</div>


<div id="outline-container-org32a0ec8" class="outline-3">
<h3 id="org32a0ec8">Object initialization</h3>
<div class="outline-text-3" id="text-org32a0ec8">
<p>
Notice that in the classes above you have specified default
constructors. You can however specify other constructors.
</p>

<p>
The constructor of a derived class is required to create an object
of the derived class type.
</p>

<p>
To initialize a constructor for the derived class you must
pass all of the elements necessary to construct an object of the
derived class. In this case the two <code>strings</code>, one <code>bool</code> and one
<code>int</code>.
</p>

<div class="highlight"><pre><span></span>    <span class="c1">// first version</span>

    <span class="n">PassCar</span><span class="o">::</span><span class="n">PassCar</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">hs</span><span class="p">)</span> <span class="c1">/// so notice there that you have to pass everything.</span>
    <span class="p">{</span>
     <span class="c1">// here implicitly the default constructor is called //</span>

     <span class="c1">// then you specify the arguments for your class as follows //</span>
     <span class="n">setNr</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// Initial values for data</span>
     <span class="n">setProd</span><span class="p">(</span><span class="n">hs</span><span class="p">);</span> <span class="c1">// members of the base class.</span>

     <span class="n">passCarType</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span> <span class="c1">// Initial values for data memsunRoof = sr; // bers of the derived class</span>
    <span class="p">}</span>
</pre></div>

<p>
Notice that the above is not the usual recommended method.
</p>

<p>
This because of the following. The <b>default constructor</b> must be
available in the base class. Moreover, initialization with
incorrect values <i>before assigning live values</i> impacts the response
of the program. I.e. you might get errors in that phase.
</p>

<p>
In this sense a better initialization method is the following
</p>

<div class="highlight"><pre><span></span><span class="c1">// Second version of the constructors of PassCar</span>
<span class="c1">// ----------------------------------------------------</span>
<span class="n">PassCar</span><span class="o">::</span><span class="n">PassCar</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">hs</span><span class="p">)</span> <span class="o">:</span> <span class="n">Car</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span> <span class="c1">// so notice that this is how you define the initialization of an object</span>
<span class="p">{</span>
<span class="n">passCarType</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span> <span class="c1">// Initial values for data memsunRoof = sr; // bers of the derived class</span>
<span class="p">}</span>
</pre></div>

<p>
Note that the third way to initialize an object via a class is
with the following syntax:
</p>

<div class="highlight"><pre><span></span>    <span class="c1">// Third version of the constructor of PassCar</span>
    <span class="c1">// ----------------------------------------------------</span>
    <span class="n">PassCar</span><span class="o">::</span><span class="n">PassCar</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">hs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Car</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">hs</span><span class="p">),</span> <span class="n">passCarType</span><span class="p">(</span> <span class="n">tp</span> <span class="p">),</span> <span class="n">sunRoof</span><span class="p">(</span> <span class="n">sr</span> <span class="p">)</span> <span class="c1">// so notice the</span>
						    <span class="c1">// syntax. with a</span>
						    <span class="c1">// comma separed</span>
						    <span class="c1">// values and taking</span>
						    <span class="c1">// the arguments from</span>
						    <span class="c1">// the first object</span>
    <span class="p">{</span>
    <span class="c1">// There remains nothing to do</span>
    <span class="p">}</span>
</pre></div>

<p>
The only thing that you have to understand is that you start
creating an object passing all of the arguments necessary for the
base class constructor and then you expand from this core
outwards.
</p>

<p>
Note that in a similar way when the an object is destroyed, the
destructor of the derived class is first called, followed by the
destructor of the base class. The reverse order of the constructor
calls applies.
</p>

<p>
Notice the power of <code>C++</code> and <code>Java</code> with their type declared
variables. With such constructors defined in the <code>car.h</code> file you
can then instantiate object, for instance as <code>const</code>. In such a
way you might just be able to call reading methods for the
objects. But when calling methods trying to modify the object you
get errors.
</p>
</div>
</div>


<div id="outline-container-org992705b" class="outline-3">
<h3 id="org992705b">Calling Redefined Methods</h3>
<div class="outline-text-3" id="text-org992705b">
<p>
Note that when calling a redefined method, defined in multiple
classes, you would actually access the method of the class the
object belongs to.
</p>

<p>
Nothing new in this sense and makes totally sense.
</p>
</div>
</div>



<div id="outline-container-org8c4d4ba" class="outline-3">
<h3 id="org8c4d4ba">Implicit Conversion among Objects</h3>
<div class="outline-text-3" id="text-org8c4d4ba">
<p>
Note that when you have objects of derived classes you have
implicitly defined the characteristic of the object belonging to
the base class - so to say.
</p>

<p>
In this sense it is interesting that you can define methods that
access the base object from an object instantiated from the
derived class.
</p>

<p>
Think for instance to the following strucutre:
</p>

<img src="../../images/Bildschirmfoto_2021-06-08_um_18.12.49.png" class="center"><p>
This is a very interesting use case in that the above allows you
to access an object of base class from an object of the derived
class.
</p>

<p>
So given this possibility the question is <i>when the conversion
takes place</i>?
</p>

<p>
And basically there are the following cases where the conversion
takes place:
</p>

<ul class="org-ul">
<li>when you assign derived objects to baseclass objects</li>

<li>pointers and references <b>to the base class</b>
</li>
</ul>
<p>
You can see an example in the picture above. There you see that
you pass by reference as in the image above is the following: you
are in fact creating a reference to a in the form of an object of
base class. And note that the above works well even in the
arguments of a function - but recall in this sense the peculiarity
of c++ when you pass objects in there. 
</p>

<p>
The other mentioned possibility is the one of assigning directly
to an object of the base class. Think for instance to the
following:
</p>

<div class="highlight"><pre><span></span>    <span class="n">Car</span> <span class="k">auto</span><span class="p">;</span>
    <span class="n">PassCar</span> <span class="nf">bmw</span><span class="p">(</span><span class="s">"520i"</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">4325</span><span class="p">,</span> <span class="c1">// derived class</span>
    <span class="s">"Bayerische Motorenwerke"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="o">=</span> <span class="n">bmw</span><span class="p">;</span>  <span class="c1">// convert derived class object to base class object</span>
</pre></div>

<p>
The last method - the one of pointer is the more annoying.
</p>

<p>
There the idea is to pass the address of derived class object and
set a pointer of <b>base class</b> to it.
</p>

<p>
Then through such a pointer you will just be able to access base
class methods with that weird arrow <code>-&gt;</code> notation.
</p>

<p>
Check the following to understand properly:
</p>

<div class="highlight"><pre><span></span>    <span class="n">Car</span><span class="o">*</span> <span class="n">carPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cabrio</span><span class="p">;</span>  <span class="c1">// cabrio object of derived class</span>

    <span class="n">carPtr</span> <span class="o">-&gt;</span> <span class="n">display</span><span class="p">();</span> <span class="c1">// display method of base class.</span>

    <span class="n">carPtr</span><span class="o">-&gt;</span><span class="n">setSunRoof</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// Error; method of derived class. cannot be accessed.</span>

    <span class="c1">// Note that the following is also an error</span>
    <span class="n">PassCar</span> <span class="k">auto</span><span class="p">;</span> <span class="c1">// derived class</span>
    <span class="k">auto</span> <span class="o">=</span> <span class="o">*</span><span class="n">carPtr</span><span class="p">;</span> <span class="c1">// Error! Pointer to derived object; true. But of **Base** class</span>
</pre></div>

<p>
It is also possible to downcast. However this is not
recommended. <b>Avoid it</b>.
</p>

<p>
There you have to make the casting explicitly. Check at it online
in case of interest.
</p>
</div>
</div>


<div id="outline-container-org6ff8eba" class="outline-3">
<h3 id="org6ff8eba">Polymorphism</h3>
<div class="outline-text-3" id="text-org6ff8eba">
<p>
That is plenty in this project is the idea that depending on the
method arguments (with possible overloading) the method performs
different tasks.
</p>

<p>
Come from greek <i>multiform</i>.
</p>

<p>
The general case is the following. You have a base class with a
<b>virtual method</b>. This is essential for polymorphic structures as
we will see next.
</p>

<p>
Consider in fact the following:
</p>

<img src="../../images/Bildschirmfoto_2021-06-09_um_16.59.02.png" class="center"><p>
So what you have is a <b>pointer</b> to a <b>base</b> class. Then recall
that when you have a pointer of base class type and you assign to
this a derived object you can just call base class methods.
</p>

<p>
So what you actually have in the above picture is an invocation of
the base class <b>virtual method</b>.
</p>

<p>
Virtual methods are then quintessential to the idea of
polymorphism in the sense that when they are invoking what you
actually call is still the method of the <b>derived class</b>.
</p>

<p>
So notice that this goes against the idea of data conversion we
previously discussed but for some methods (the one where you
define the virtual method) it might well make sense to have such a
behaviour.
</p>

<p>
This for instance in the case of the <code>display</code> method as in the
example above. There you do not want to just get the base
attributes of the base class object but you might want to get the
attributes of the object of interest. By allowing virtual classes
you will make sure that the right method will be called getting
all of the arguments depending on the object <b>sub-class</b>. In this
sense the invocation of the method of the base class becomes
polymorphic and adjusts to the object class type referred.
</p>

<p>
Virtual methods are defined declaring the <code>virtual</code> type class;
see for instance the following example:
</p>

<img src="../../images/Bildschirmfoto_2021-06-09_um_18.00.45.png" class="center"><p>
Note that when defining the method of the derived classes, they
should be virtual as well. However, notice that you can omit the
virtual keyword there. The compiler will understand that by its
own as recall that it starts building the object from the inside
to the outside; i.e. from the base class on. Don't think it in the
opposite direction though - a base class method does not become
virtual just because it is declared as virtual in a derived class.
</p>

<p>
However, note the following <b>important point</b>:
</p>

<p>
If you use a different signature or return type of a virtual base
class method to define a method in a derived class, this simply
creates a new method with the same name. The method will not
necessarily be virtual!
</p>

<p>
Note as well the following: If you use a base class pointer to
manage an object, the appropriate virtual methods of the derived
class are called. However, non-virtual methods will always execute
the base class version.
</p>

<p>
This goes together with the <i>static</i> and <i>dynamic</i> memory
allocation when calling virtual and non-virtual methods.
</p>

<p>
Note as well that if a virtual method is called via an <i>objectâ€™s
name</i>, the appropriate version of this method is also known at
time of compilation. So this is also a case of early binding. 
</p>

<p>
When a non-virtual method is called, the address of the function
is known at time of compilation. The address is inserted directly into
the machine code. This is also referred to as static or early
binding.
</p>

<p>
This in contrast to the case of making the call via pointers to
the base classes and the virtual method. Then <i>dynamic</i> memory
allocation occurs. 
</p>

<p>
Note moreover that there quite some few low level stories that you
will have to well manage. i.e. if you have a pointer to the base
class, which you assign an object of a derived class, and then
subsequently delete such pointer, i.e.
</p>

<div class="highlight"><pre><span></span>    <span class="n">Car</span> <span class="o">*</span><span class="n">carPtr</span><span class="p">;</span>
    <span class="n">carPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PassCar</span><span class="p">(</span><span class="s">"500"</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="s">"Geo"</span><span class="p">);</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="k">delete</span> <span class="n">carPtr</span><span class="p">;</span>
</pre></div>

<p>
then the destructor for the base class is called but not for the
derived class. As the PassCar destructor is not called, neither is
the destructor called for the data member passCarType, which is
additionally defined in the derived class. The data member
passCarType is a string, however, and occupies dynamically
allocated memoryâ€” this memory <i>will not be released</i>.
</p>

<p>
So be careful:
</p>

<p>
If multiple objects are created dynamically in the derived class,
a dangerous situation occurs. More and more unreferenced memory
blocks will clutter up the main memory without you being able to
reallocate themâ€”this can seriously impact your programâ€™s response
and even lead to external memory being swapped in.
</p>

<p>
The solution to this is to use <b>virtual destructors</b>. The idea
with such virtual destructors is that in such a way, just like any
<i>other virtual method</i>, the appropriate version of the destructor
<i>will be executed</i>.
</p>

<p>
Note the following important piece:
</p>

<blockquote>
<p>
A class used as a base class for other classes should <b>always have
a virtual destructor</b> defined. Even if the base class does not need a
destructor itself, it should at least contain a dummy destructor, that
is, a destructor with an empty function body.
</p>
</blockquote>
</div>
</div>



<div id="outline-container-org5a8ae07" class="outline-3">
<h3 id="org5a8ae07">Data Abstraction</h3>
<div class="outline-text-3" id="text-org5a8ae07">
<p>
Here the idea is to create a class describing the objects.
</p>

<p>
I.e. you will define a class with all of the relative virtual
methods that will pose the structure and base for all of the
derived methods.
</p>

<p>
That is basically very quickly the idea, when you keep it to the
bone.
</p>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../things-to-do-in-zh/" rel="prev" title="A personal Repo - Movies, Art and Things to Do">Previous post</a>
            </li>
            <li class="next">
                <a href="../quantitative-finance-some-quick-and-dirty-notes/" rel="next" title="Quantitative Finance - Some Quick and Dirty Notes">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents Â© 2021         <a href="mailto:marco.hassan30@gmail.com">Marco Hassan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </section><script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
