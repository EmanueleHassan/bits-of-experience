#+BEGIN_COMMENT
.. title: On Algorithms
.. slug: on-algorithms
.. date: 2023-01-15 14:35:32 UTC+01:00
.. tags: Algorithms, software-engineering
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT

So I am starting this post as always in order to keep structure and
leverage on it thorugh time.

The idea is essentially the same of the other post about classical
architectures - and the idea of Da Vinci. Have the map and then
leverage on it thorugh time.

I will also create a relevant post for the data structures. I studied
most of them and have made manual notes.

Also at some point when making leetcode exercises I improved quite a
bit on them. Make that post as you know how easy it is to foget things
and if you do not have a way to structure the way you work you will be
lost. 


{{{TEASER_END}}}


* On the general types of algorithms

  So there are essentially 7 types of algorithms that you should be
  aware of - and always keep in the back of your mind.

  These are:

  1. Brute Force Algorithms

     Just try all of the relevant combinations until you find the
     result that you are looking forward to.

     Think of grid-search etc. 

  2. Recursive Algorithms

     Recursion is key here.

     It is resolved by breaking it down into subproblems of a similar
     nature and repeating the process over and over until it is
     resolved with the help of a base condition.

  3. Dynamic Programming Algorithms

     Here the core is *memoization* = to transform the results of a
     function into something to remember.

     Note that this technique is also important for the other personal
     project you are currently doing. Check for instance the way to
     /compute the fibonacci series/ through it.

     Note that this types of algorithm is key to /Reinforcement
     Learning/ techniques. 

  4. Divide and Conquer Algorithms

     Here the basic idea is to split the problem and work and reduce
     the size of the problem. So always work by splitting / dividing -
     conquering and finally coming to your desired result. 
     
  5. Greedy Algorithms

     These create a solution portion by portion.

     Meaning it selects at each iteration a local optimum. By
     iteratively computing local optima you will come to global
     optimum.

     Think for instance when you do your math operations by hand. You
     compute local stuff iteratively coming to the global.

  6. Backtracking Algorithms

     This searches for the solution by eleminating solutions that fail
     to meet the requirements.

     I.e. constuct the answer and eliminate solutions that faill to
     meet the criteria. 
     
  7. Randomized Algorithms

     A randomized algorithm is an algorithm that employs a degree of
     randomness as part of its logic or procedure. The algorithm
     typically uses uniformly random bits as an auxiliary input to
     guide its behavior.

     This is an algortihm that you have to use as well in your
     project. I mean you are using it every second of your life
     without even being aware of it. But the beauty is that everything
     is connected - everything carries all of the information.

     So gather that randomness and use it to create the whiteness as
     you are doing in - white noise. Also when reading this very
     complex book that you are reading. 

  Note that you have already already seen most of them.

  When working on a problem it might be useful to leverage these in
  order to classify your approach or delevlop a meaningful one by
  yourself. Or at least to understand at the high level what you are
  doing. 

  
* On different types of Algorithms

** On sorting algorithms

   So coming to the sorting algorithms there are multiple
   possibilities for implementing such.

   You can find an exhaustive list of them [[https://www.freecodecamp.org/news/sorting-algorithms-explained-with-examples-in-python-java-and-c/][here]].
   
*** Counting Sort Algorithm

    I will work now with the counting sort algorithm. This is the one I
    need for performing an assignment.

    It is good cause when sorting it also keeps track of the
    occurrences of items. This is exactly what I need.

    So while there might be sorting algorithms that are faster for the
    particular application which is of a low-order /n/ this is quite
    satisfying as with it you kills two birds with one stone.

    #+begin_src java :results output drawer :classname CountingSort 
    import java.util.*;

    class CountingSort {

	static void countSort(int[] arr)  // Passing by referece. Work with it.
	{

	    int max = 14;
	    int min = 1;
	    int range = max - min + 1;  // plus 1 cause 0

	    int count[] = new int[range];
	    int output[] = new int[arr.length];

	    for (int i = 0; i < arr.length; i++) {
		count[arr[i] - min]++;
	    }

	    // So below you see - sum all of the occurrences up to the index.
	    for (int i = 1; i < count.length; i++) {
		count[i] += count[i - 1]; 
	    }

	    for (int i = arr.length - 1; i >= 0; i--) {    // -1 cause it starts at 0 the index.
		output[count[arr[i] - min] - 1] = arr[i];  // count [10 + 10] = sum counts until count [5] -1.
		count[arr[i] - min]--;                     // this is the reason why the above works.
	    }

	    printArray (count);	 // count reverse - subtract.

	    for (int i = 0; i < arr.length; i++) {
		arr[i] = output[i];
		// Simply copy the output
		// array. You could work by value
		// and not reference and return
		// the output array instead of
		// copying it.
	    }

	}

	static void printArray(int[] arr)
	{
	    for (int i = 0; i < arr.length; i++) {
		System.out.print(arr[i] + " ");
	    }
	    System.out.println("");
	}

	// Driver code
	public static void main(String[] args)
	{
	    //int[] arr = { -5, -10, 0, -3, 8, 5, -1, 10 };

	    int[] arr = { 10, 11, 14, 12, 13 };

	    // Function call
	    countSort(arr);
	    printArray(arr);
	}
    }
    #+end_src
    
     #+RESULTS:
     :results:
     0 0 0 0 0 0 0 0 0 0 1 2 3 4 
     10 11 12 13 14 
     :end:
    


*** TODO write on the high level about other possible solutions

    You could follow [[https://www.freecodecamp.org/news/sorting-algorithms-explained-with-examples-in-python-java-and-c/][this arcticle]].

    



