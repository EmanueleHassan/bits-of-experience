#+BEGIN_COMMENT
.. title: Object Oriented Programming - Some Notes
.. slug: object-oriented-programming-some-notes
.. date: 2021-11-17 16:37:49 UTC+01:00
.. tags: oop
.. category: 
.. link: 
.. description: 
.. type: text
.. status: 
#+END_COMMENT


#+begin_export html
<style>
img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>
#+end_export


So here are some notes on concepts you have to use when working in a
proper OOP way.

Once upon a time, I had written some notes about major OOP
concepts. Unfortunately it got lost. Learn your lesson from it as this
is a real pity.

In any case start anew here. Basically this should cover a little bit
of Software Design best practices. Add some notes for instance through
the following sources

- [[https://refactoring.guru/design-patterns][design-patterns and refactoring]] - online source. 

- [[http://www.javier8a.com/itc/bd1/articulo.pdf][desing patterns]] - apparently /THE BOOK/ in order to write proper
  software .

So when you read the book it is immediate that the design patterns
ultimately depend on the OOP concepts, such as composition,
inheritance, delegation etc. So basically these are the atoms of OOP
and patterns are based on such atoms. So in the book you start from
the atoms. Otherwise it makes sense to read a separate book completely
dedicated to it, such as: /Object-Oriented Thought Process/.

It is a good investement learning such patterns. You will be then much
better able to decompose the existing applications. This will help you
to navigate big existing legacy applications where no description of
it is attached to it.

{{{TEASER_END}}}

* Design Patterns

  So taking now a moment to dig into design patterns.

  Basically understand that they are broadly defined in to 3
  categories:

  - =Creational patterns=: provide object creation mechanisms that
    increase flexibility and reuse of existing code.

  - =Structural patterns=: explain how to assemble objects and classes
    into larger structures, while keeping the structures flexible and
    efficient.

  - =Behavioral patterns=: take care of effective communication and
    the assignment of responsibilities between objects.

  At the end you will see that many things you already started to use
  out of the box after a couple of month working more in an OOP way.

** Map of Design Patterns
  
   Generally keep in mind the following overview:
  
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-25 085656.png" class="center">
   #+end_export

   Note that above *object patterns* refer to object relationships that
   can be changed at *run-time*. In contrast *classes patterns* refer
   to reletionships among classes, meaning these are static and fixed
   at *compile time*.


** Relation Among the Patterns
   
   Important is as well to understand that there is a relation among
   patterns. I.e. it is quite common to combine them in order to
   perform the necessary logic of your programs.

   #+begin_export html
    <img src="../../images/Screenshot 2022-08-25 090514.png" class="center">
   #+end_export

   Note that some patterns are as well subsititute; think for instance
   of /prototype/ and /abstract factory/.


** Intent classification for the different Patterns

   So you can refer as well to the following for designing the thing.

   It will be useful as well, especially at the beginning, for
   understanding what patterns you want to apply when creating your
   code - less so for reverse engineering existing code - I might be
   wrong here though.

   Note that this is a copy and paste from the design patterns book
   p. 24-25. 

   #+begin_quote
1. Design patterns: Abstract Factory (87),Factory Method
   (107),Prototype (117).

   Creating an object by specifying a class explicitly. Specifying a
   class name when you create an object commits you to a particular
   implementation instead of a particular interface. This commitment
   can complicate future changes. *To avoid it, create objects
   indirectly*.

2. Design patterns: Chain of Responsibility (223),Command (233).

   Dependence on specific operations. When you specify a particular
   operation, you commit to one way of satisfying a request. By
   *avoiding hard-coded requests*, you make it easier to change the way
   a request gets satisfied both at compile-time and at run-time.

3. Design patterns: Abstract Factory(87),Bridge (151).

   Dependence on hardware and software platform. External operating
   system interfaces and application programming interfaces (APIs) are
   different on different hardware and software platforms.Software
   that depends on a particular platform will be harder to port to
   other platforms.It may even be difficult to keep it up to date on
   its native platform. It's important therefore to *design your system
   to limit its platform dependencies*.

4. Design patterns: AbstractFactory (87),Bridge (151), Memento (283),Proxy (207).

   Dependence on object representations or implementations. Clients
   that know how an object is represented, stored, located, or
   implemented might need to be changed when the object
   changes. *Hiding this information from clients keeps changes from
   cascading*. So this is the *concept of Transparency*.

5. Design patterns: Builder (97), Iterator (257), Strategy (315),
   Template Method (325),Visitor(331).

   Algorithmic dependencies. *Algorithms are often extended, optimized,
   and replaced* during development and reuse. Objects that depend on
   an algorithm will have to change when the algorithm
   changes. *Therefore algorithms that are likely to change should be
   isolated*.

   /Personal note:/ sounds much like transparency and the previous
   point. Once you have all the patterns studied and clear in the mind
   come back here.
   
6. Design patterns: AbstractFactory (87), Bridge (151), Chain of
   Responsibility (223), Command (233), Facade (185),Mediator (273),
   Observer (293).

   Tight coupling. Classes that are tightly coupled are hard to reuse
   in isolation, since they depend on each other. *Tight coupling
   leads to monolithic systems*, where you can't change or remove a
   class without understanding and changing many other classes. The
   system becomes a dense mass that's hard to learn, port, and
   maintain. -> Gordian Knot.
   
   *Loose coupling increases the probability* that a class can be reused
   by itself and that a system can be learned, ported, modified, and
   extended more easily. Design patterns use techniques such as
   abstract coupling and layering to promote loosely coupled systems.

   Note layering - old trick of CS - add a layer of indirection.
   
7. Design patterns: Bridge (151), Chain of Responsibility (223),
   Composite (163), Decorator (175), Observer (293),Strategy (315).

   Customizing an object by subclassing often isn't easy. Every new
   class has a fixed implementation overhead (initialization,
   finalization, etc.). Defining a subclass also requires an in-depth
   understanding of the parent class. For example, overriding one
   operation might require overriding another.An overridden operation
   might be required to call an inherited operation. And subclassing
   can lead to an explosion of classes, because you might have to
   introduce many new subclasses for even a simple extension.

   *Object composition in general and delegation* in particular
   provide flexible *alternatives to inheritance for combining
   behavior*. *New functionality* can be added to an application by
   *composing existing objects* in new ways rather than by defining
   new subclasses of existing classes. On the other hand, *heavy use
   of object composition can make designs harder to understand*. Many
   design patterns produce designs in which you can introduce
   customized functionality just by defining one subclass and
   composing its instances with existing ones.
   
8. Design patterns: Adapter (139),Decorator(175),Visitor(331).

   *Inability to alter classes conveniently - these design patterns
   fix it*.

   Sometimes you have to modify a class that can't be modified
   conveniently.Perhaps you need the source code and don't have it (as
   may be the case with a commercial class library). Or maybe any
   change would require modifying lots of existing subclasses. Design
   patterns offer ways to modify classes in such circumstances.
   #+end_quote


** Aspect that can vary per design pattern

   This is as well useful; in the sense that you can refer to the
   following to understand what you would like to keep flexible in
   your system and what not.

   #+begin_export html
    <img src="../../images/Screenshot 2022-08-25 164022.png" class="center">
   #+end_export
   

* Logic of OOP that makes some patterns possible

  So one of the mayor concept in OOP is the one of *dynamic
  binding*. This allows patterns such as the abstract factory.

  The essential idea is that when you trigger a method (a request),
  the behaviour is not simply defined by the method itself but it is
  rather a combination of *object* and *method*, this actually
  specifies the operation.

  #+begin_quote
The run-time association of a request to an object and one of its
operations (methods) is known as *dynamic binding*.
  #+end_quote 

  /Side note - the concept is clear. There is just a bit of new
  terminology. Do not get confused as everything boils down to:/

  #+begin_quote
Dynamic binding means that issuing a request doesn't commit you to a
particular implementation until run-time.
  #+end_quote
  
  
* Creational Patterns

  Creational class patterns defer some part of object creation to
  subclasses, while Creational object patterns defer it to another
  object.

  Note that creational patterns heavy leverage the Java future of
  reference variables. See for instance the following snippet for it
  on your Java notes in the following section.


** On reference variables using interafaces              :reference_variable:

    This is convenient. Recall that it was possible to define
    reference variables as superclasses and to reference then objects
    of subclasses. It was then possible to call the different abstract
    methods of the superclass that would then trigger the right call
    to the actual implementation of it in the subclass.

    In a similar way it is possible to create reference variables as
    interfaces and point then to the different objects of classes
    implementing such interface.

    *Any instance of any class that implements the declared interface
    can be referred to by such a variable*.

    The exact way the interface is implemented depends then on the
    type of object that the reference interface variable points
    at. This in a very similar way to what was already explained for
    the case of superclass reference variable.

    *Note:* interestingly when you implement a reference variable of
    type interface and then refer to an object of some class referring
    to that interface you can access all of the methods specified by
    the interface via the reference variable but *you cannot access
    any other members defined in the class* implementing the
    interface.
    
    The method to be executed is looked up dynamically at run time,
    allowing classes to be created later than the code which calls
    methods on them.

    #+begin_quote
CAUTION Because dynamic lookup of a method at run time incurs a
significant overhead when compared with the normal method invocation
in Java, you should be careful not to use interfaces casually in
performance-critical code.
    #+end_quote

  
** Factory Methods

   Basically this is the one I was already noting when making some
   notes generally about Java.

   This is very core in order to write a bit of solid code. You have to
   understand and interiorize it.

   Basically the idea is the following:

   - Define an interface for creating an object, but let subclasses
     decide *which class* (so you see this pattern is at class level -
     meaning compile time) to instantiate.

     Factory Method lets a class defer instantiation to subclasses.

   - So that is basically a /virtual/ constructor via a method.

   So the idea is essentailly the following:
  
   #+begin_export html
    <img src="../../images/Screenshot 2022-01-28 122956.png" class="center">
   #+end_export

   Note that this is called *method* for a reason. You have actually
   here a method in the interface and the ProductOne and ProductTwo in
   the above will *implement that method constructing an object from
   the desired class*. So actually the construction happens via method
   and not by reference assigning an object to a general
   interface. Keep this /well into your mind/.

   #+begin_export html
    <img src="../../images/Screenshot 2022-08-26 155654.png" class="center">
   #+end_export

**** On a side note in debugging

     So basically I am working quite a bit on some legacy code. You
     should be careful about such factory methods as when you have for
     instance interfaces which are implemented by similar but
     different objects - possibly in a hierarchical way -, say for
     instance =AbstractFeed= and =AbstractQuarterly=  (implementing
     Abstractfeed) and overwriting some methods, well then you see
     that it is easy to get confused.

     You will notice that factory structure by debugging the thing. 
     

** Abstract Factory

   This is another pattern that uses the concept of dynamic binding in
   OOP.

   Note that the way it uses such concept is quite elaborated.

   I will elaborate next but you see that such patterns are indeed
   swiss knifes. Meaning it is not something that you implement on the
   fly when you program. At least not at the beginning. You have to
   make some explicit thinking before and take quite some design
   steps.

   In general this pattern looks as follows:
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-26 162111.png" class="center">
   #+end_export

   And to understand that better think of the following
   implementation:
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-26 162847.png" class="center">
   #+end_export

   In this sense understand the following pseudo-code in order to
   understand the pattern - note that *factory methods* are used (you
   can also use other patterns such as prototypes there -:   

   #+begin_src java

   // The abstract factory interface declares a set of methods that
   // return different abstract products. These products are called
   // a family and are related by a high-level theme or concept.
   // Products of one family are usually able to collaborate among
   // themselves. A family of products may have several variants,
   // but the products of one variant are incompatible with the
   // products of another variant.
   interface GUIFactory is
       method createButton():Button
       method createCheckbox():Checkbox


   // Concrete factories produce a family of products that belong
   // to a single variant. The factory guarantees that the
   // resulting products are compatible. Signatures of the concrete
   // factory's methods return an abstract product, while inside
   // the method a concrete product is instantiated.
   class WinFactory implements GUIFactory is
       method createButton():Button is
	   return new WinButton()
       method createCheckbox():Checkbox is
	   return new WinCheckbox()

   // Each concrete factory has a corresponding product variant.
   // so you see this uses factory methods
   class MacFactory implements GUIFactory is
       method createButton():Button is
	   return new MacButton()
       method createCheckbox():Checkbox is
	   return new MacCheckbox()


   // Each distinct product of a product family should have a base
   // interface. All variants of the product must implement this
   // interface.
   interface Button is
       method paint()

   // Concrete products are created by corresponding concrete
   // factories.
   class WinButton implements Button is
       method paint() is
	   // Render a button in Windows style.

   class MacButton implements Button is
       method paint() is
	   // Render a button in macOS style.

   // Here's the base interface of another product. All products
   // can interact with each other, but proper interaction is
   // possible only between products of the same concrete variant.
   interface Checkbox is
       method paint()

   class WinCheckbox implements Checkbox is
       method paint() is
	   // Render a checkbox in Windows style.

   class MacCheckbox implements Checkbox is
       method paint() is
	   // Render a checkbox in macOS style.


   // The client code works with factories and products only
   // through abstract types: GUIFactory, Button and Checkbox. This
   // lets you pass any factory or product subclass to the client
   // code without breaking it.
   class Application is
       private field factory: GUIFactory
       private field button: Button

       constructor Application(factory: GUIFactory) is
	   this.factory = factory

       method createUI() is
	   this.button = factory.createButton()

       method paint() is
	   button.paint()


   // The application picks the factory type depending on the
   // current configuration or environment settings and creates it
   // at runtime (usually at the initialization stage).
   class ApplicationConfigurator is
       method main() is
	   config = readApplicationConfigFile()

	   if (config.OS == "Windows") then
	       factory = new WinFactory()
	   else if (config.OS == "Mac") then
	       factory = new MacFactory()
	   else
	       throw new Exception("Error! Unknown operating system.")

	   Application app = new Application(factory)

   #+end_src
   

** Builder

   You use this pattern in order to create very laborious objects that
   require a lot of effort being created.

   In this sense what you do is to define a builder with all of the
   different components that you need for creating the complex
   objects. You can then call directly from your client the builder
   components that you need to instantiate your complex objects - and
   forms, derivatives of it -.

   Another option is to work with a second type of objects - /a
   Director/.

   The idea is well sum-up in the following:

   #+begin_quote
If the client code needs to assemble a special, fine-tuned model of a
car, it can work with the builder directly. On the other hand, the
client can delegate the assembly to the director class, which knows
how to use a builder to construct several of the most popular models
of cars.
   #+end_quote
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-29 084214.png" class="center">
   #+end_export

   So you see for instance in the pattern above that the Director
   holds all of the different types of car categories. These are
   mapped to the relevant input parameters in the director, which uses
   then the general builder objects to create them.


** Prototype

   Prototype is a creational design pattern that lets you copy
   existing objects without making your code dependent on their
   classes.

   The essential idea why you need a pattern for it is threefold:

   #+begin_quote
1. Not all objects can be copied that way because some of the object’s
   fields may be private and not visible from outside of the object
   itself.

2. Since you have to know the object’s class to create a duplicate,
   your code becomes dependent on that class. If the extra dependency
   doesn’t scare you, there’s another catch.

3. Sometimes you only know the interface that the object follows, but
   not its concrete class, when, for example, a parameter in a method
   accepts any objects that follow some interface.
   #+end_quote

   The pattern works as follows:

   #+begin_quote
The pattern declares a common interface for all objects that support
cloning. This interface lets you clone an object without coupling your
code to the class of that object.

Usually, such an interface contains just a single clone method.

An object that supports cloning is called a prototype. When your
objects have dozens of fields and hundreds of possible configurations,
cloning them might serve as an alternative to subclassing.
   #+end_quote

   The pattern looks as follows:
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-29 091559.png" class="center">
   #+end_export

   As always understand it via the concrete case; it is much more
   simple to digest it then:
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-29 100157.png" class="center">
   #+end_export

   So that is it. Quite easy to understand; or maybe I am just getting
   into the pattern mentality.
   

** Singleton

   This is again the usual concept in CS. It is to have a single
   access to the resources or objects such that you apply exclusivity
   =a la= lord of the flies.

   It is the concept of /Single Responsibility Principle/.

   Here’s how it works: imagine that you created an object, but after
   a while decided to create a new one. Instead of receiving a fresh
   object, *you’ll get the one you already created*.

   Note that this behavior is impossible to implement with a regular
   constructor since a constructor call must always return a new
   object by design.

   Note that the above is the general concept and people most often
   refer as Singleton an Object solving that issue. *Important to
   note* is that it is much more.

   The general idea for implementing this is the following:

   #+begin_quote
Make the default constructor private, to prevent other objects from
using the new operator with the Singleton class.

Create a static creation method that acts as a constructor. Under the
hood, this method calls the private constructor to create an object
and saves it in a static field.

All following calls to this method return the cached object.
   #+end_quote

   This is as well pretty simple to implement. You can think about it
   in the following way:
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-29 102854.png" class="center">
   #+end_export


* Structural Patterns

  The Structural class patterns use inheritance to compose classes,
  while the Structural object patterns describe ways to *assemble
  objects*.

* Behavioural Patterns

  The Behavioral class patterns use inheritance to describe
  /algorithms and flow of control/, whereas the Behavioral object
  patterns describe how a group of objects /cooperate/ to perform a
  task that no single object can carry out alone.
  
  
* Some core OOP principles you just have to keep on your mind


** Polymorphism

   Overridden methods are another way that Java implements the “one
   interface, multiple methods” aspect of polymorphism.

   Part of the key to successfully applying polymorphism is understanding
   that the superclasses and subclasses form a hierarchy which moves from
   lesser to greater specialization.  Used correctly, the superclass
   provides all elements that a subclass can use directly. It also
   defines those methods that the derived class must implement on its
   own. This allows the subclass the flexibility to define its own
   methods, yet still enforces a consistent interface.

** Encapsulation

   The idea of OOP is the one of keeping data and methods operating on
   them together.

   In such a way you can keep the internal state of the object hidden
   from the outside world.

   
  
** Key Concept - Favour Prgramming by Interface over Implementation

   The idea is that in OOP you can work through the reference
   variables mechanism. You can refresh them: [[file:java-notes-history-syntax-and-tricks.org::*Superclass reference Subclass][Superclass reference
   Subclass]], [[file:java-notes-history-syntax-and-tricks.org::*On reference variables using interafaces][On reference variables using interafaces]] (note set the
   index for emacs locally on www site it will not work).

   This is in fact many the idea behind creational patterns as you
   already got when learning about the concept. 
   
   #+begin_export html
    <img src="../../images/Screenshot 2022-08-26 093006.png" class="center">
   #+end_export

** Key Concept - Favour Object Composition over Inheritance

   So in order to understand this, you have to start from the
   disadvantages of Inheritance.

   You can think about it in the following terms:

   #+begin_quote
1. You can't change the implementations inherited from parent classes
   at run-time, because inheritance is defined at compile-time.

2. Second, and generally worse, parent classes often define at least
   part of their subclasses' physical representation. Because
   inheritance exposes a subclass to details of its parent's
   implementation, it's often said that "inheritance breaks
   encapsulation" [Sny86]. The implementation of a subclass becomes
   *so bound up with the implementation of its parent class* that any
   change in the parent's implementation *will force the subclass to
   change*.

   Implementation dependencies can cause *problems when you're trying
   to reuse a subclass*.

   This dependency limits flexibility and ultimately reusability. From
   here the idea of using *object composition*.
   #+end_quote
      
*** Object Composition

    Object composition is defined dynamically at run-time through
    objects acquiring references to other objects.

    I.e. you encapsulate one object into antoher one. From here the
    idea of Object Composition.

    Because objects are accessed solely through their interfaces, we
    don't break encapsulation. Any *object can be replaced at run-time
    by another as long as it has the same type*.

    Favoring object composition over class inheritance helps you keep
    each class encapsulated and focused on one task.

    So this is the idea of the second principle:

    #+begin_quote
    Favor object composition over class inheritance.
    #+end_quote

    Nevertheless, our experience is that designers *overuse
    inheritance as a reuse technique*, and designs are often made more
    reusable (and simpler) by depending more on object
    composition. You'll see object composition applied again and again
    in the design patterns.

*** Delegation

    Delegation is a way of making composition as powerful for reuse as
    inheritance [Lie86, JZ911]. In delegation, two objects are
    involved in handling a request: a *receiving object delegates*
    operations to its delegate - which is encapsulated.

    The following window example makes quite the point:

    #+begin_quote
Window classmight reuse the behavior of Rectangle by keeping a
Rectangle instance variable and delegating Rectangle-specific behavior
to it.

In other words, instead of a Window being a Rectangle, it would have a
Rectangle.

Window must now forward requests to its Rectangle instance explicitly,
whereas before it would have inherited those operations.
    #+end_quote

    #+begin_export html
     <img src="../../images/Screenshot 2022-08-29 123626.png" class="center">
    #+end_export

    Note now the benefit as well, that if you want to change and
    create a window with a circle shape you just changing a Rectangle
    instance with a /Circle instance/ at run time.

    Delegation has a disadvantage it shares with other techniques that
    make softwaremore flexible through object composition: Dynamic,
    highly parameterized software is *harder to understand* than more
    static software. - layer of indirection; solves issues but more
    complex. Same as distributed microservices.

    There are also run-time inefficiencies, but the human
    inefficiencies are more important in the long run.

    Delegation is a good design choice only when it simplifies more
    than it complicates.

    Delegation is an extreme example of object composition. It shows
    that you can *always replace inheritance with object composition*
    as a mechanism for code reuse.

** Callback Methods

   So the basic idea is to create an interface with the methods that
   the callback will leverage.

   Then basically depedning on the object that will implement that
   intereface you will fallback to different implementations of it.

   Check as well at this event. [[https://www.tutorialspoint.com/Callback-using-Interfaces-in-Java][Equally good - if not better]]. 
  
   Say for instance the following

   #+begin_src java :results output raw  
// Java program to demonstrate callback mechanism
// using interface is Java
 
// Create interface
import java.util.Scanner;
interface STax {
    double stateTax();
}
 
// Implementation class of Punjab state tax
class Punjab implements STax {
    public double stateTax()
    {
        return 3000.0;
    }
}
 
// Implementation class of Himachal Pardesh state tax
class HP implements STax {
    public double stateTax()
    {
        return 1000.0;
    }
}
 
class TAX {
    public static void main(String[] args)
	throws ClassNotFoundException, IllegalAccessException, InstantiationException
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the state name");
        String state = sc.next(); // name of the state
 
        // The state name is then stored in an object c
        Class c = Class.forName(state);
 
        // Create the new object of the class whose name is in  c
        // Stax interface reference is now referencing that new object
        STax ref = (STax)c.newInstance();
 
        /*Call the method to calculate total tax
	  and pass interface reference - this is callback .
	  Here, ref may refer to stateTax() of Punjab or HP classes
	  depending on the class for which the object is created
	  in the previous step
	,*/
 
        calculateTax(ref);
    }
    static void calculateTax(STax t)
    {
        // calculate central tax
        double ct = 2000.0;
 
        // calculate state tax
        double st = t.stateTax();
        double totaltax = st + ct;
 
        // display total tax
        System.out.println("Total tax =" + totaltax);
    }
}
   #+end_src 

   Note that in your code - for instance in the case of the zipParser
   you use this concept coupled with the one of functional
   programming.

   I.e. your callback interface is implemented directly via functional
   programming and it is never explicitely written anywehere.

** Anonymous Inner Classes

   This is something quite interesting.

   Anonymous classes are /inner classes with no name/.

   Since they have no name, we can't use them in order to create
   instances of anonymous classes.

   As a result, we have to *declare and instantiate anonymous classes in
   a single expression at the point of use*. -> so essentially this is
   ultimately the idea.

   The way you declare this anonymous inner class with no name is the
   following:

   #+begin_quote
 new ParentClass (...) {}

 where:

 - ParentClass the class you want to create the inner class in

 - (...) here you have to pass the constructor arguments. Note that
   this is /necessary/ as you are creating a new object out of the
   box. 

 - {} here you have the methods your anonymous class should implement
   #+end_quote

   Example

   #+BEGIN_SRC java :results output drawer :classname
// Anonymous class - no name.
// It basically is an inner class of the parentclass: Book
myNewObject = new Book("Design Patterns") // constructors arguments of parent class
{
    @Override
    public String description() {   // inner class with this method
        return "Famous GoF book.";
    }
}
   #+END_SRC

   Note that this is essentially it. The question is then why it is an
   /inner/ class? Not that clear to me at this stage. I think that the
   naming is a bit confusing.

   Check at the following minor test that I did. You can in fact as
   well access the methods of the parent class. So it looks to me
   simply as an extended class object. So don't know keep it as an open
   question and do not spend too much time on it now... too many things
   to learn. 

   #+BEGIN_SRC java :results output drawer :classname TestAnnonymousInner
class Person{
    void eat(){};

    void helloWorld (){
	System.out.println ("hello world");
    };
}

class TestAnnonymousInner{
    public static void main(String args[]){
	Person p=new Person(){

		@Override
		void eat(){System.out.println("nice fruits");}
	    };

	p.eat();
	p.helloWorld ();
    }
}
   #+END_SRC

   #+RESULTS:
   :results:
   nice fruits
   hello world
   :end:

   *Finally note*: that it is very common as well to use the /abstract
   inner class/ patterns as well for interfaces. You can use this as
   well there.

   
