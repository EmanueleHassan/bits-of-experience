<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Gradle | Bits of Experience</title>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://marcohassan.github.io/bits-of-experience/posts/gradle/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Marco Hassan">
<link rel="prev" href="../git-flow/" title="Git-Flow" type="text/html">
<link rel="next" href="../on-the-full-cycle-development-model/" title="On the Full-Cycle Development Model" type="text/html">
<meta property="og:site_name" content="Bits of Experience">
<meta property="og:title" content="Gradle">
<meta property="og:url" content="https://marcohassan.github.io/bits-of-experience/posts/gradle/">
<meta property="og:description" content="img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-10-20T09:18:25+02:00">
<meta property="article:tag" content="java">
</head>
<body>
    <a href="#page-content" class="sr-only sr-only-focusable">Skip to main content</a>
    
    <section class="social"><ul>
<li><a href="../../pages/aboutme/" title="About me"><i class="fa fa-user-circle"></i></a></li>
            <li><a href="../../pages/bits-of-experience-a-readable-view-on-my-study-adventures/" title="Home"><i class="fa fa-home"></i></a></li>
            <li><a href="../../index.html" title="Blog"><i class="fa fa-edit"></i></a></li>
            <li><a href="../../pages/emacs/" title="A life Configuring Emacs"><i class="fa fa-code"></i></a></li>
            <li><a href="../../pages/papers/" title="Term and Research Papers"><i class="fa fa-university"></i></a></li>
            <li><a href="../../pages/foto-blog/" title="Foto Blog"><i class="fa fa-camera-retro"></i></a></li>
            <li><a href="https://github.com/MarcoHassan" title="My Github"><i class="fab fa-github"></i></a></li>
            <li><a href="https://stackoverflow.com/users/9731177/mhass" title="My Stack"><i class="fab fa-stack-overflow"></i></a></li>
            <li><a href="../../rss.xml" title="RSS"><i class="fa fa-rss"></i></a></li>
            <li><a href="../../categories/index.html" title="Tags"><i class="fa fa-tags"></i></a></li>
    
    

        </ul></section><section class="page-content"><div class="content" rel="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Gradle</a></h1>

        <div class="metadata">
            <p class="dateline"><a href="." rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2021-10-20T09:18:25+02:00" itemprop="datePublished" title="2021-10-20 09:18">2021-10-20 09:18</time></a></p>
            <p class="byline author vcard"> <i class="fa fa-user"></i> <span class="byline-name fn" itemprop="author">
                    Marco Hassan
            </span></p>
            
        <p class="sourceline"><a href="index.org" class="sourcelink"><i class="fa fa-file-code"></i> Source</a></p>

            

            
    <div class="tags">
<h3 class="metadata-title">
<i class="fa fa-tags"></i> Tags:</h3>
        <ul itemprop="keywords" class="tags-ul">
<li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
        </ul>
</div>

        </div>
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <style>
img {
display: block;
margin-top: 60px;
margin-bottom: 60px;
margin-left: auto;
margin-right: auto;
width: 70%;
height: 100%;
class: center;
}

.container {
  position: relative;
  left: 15%;
  margin-top: 60px;
  margin-bottom: 60px;
  width: 70%;
  overflow: hidden;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
  display:block;
  overflow-y: hidden;
}

.responsive-iframe {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  border: none;
  display:block;
  overflow-y: hidden;
}
</style>
<p>
So in this post I will make some notes on Gradle.
</p>

<p>
I could theoretically take it as a black box at work and do my work
with the current configuration.
</p>

<p>
I prefer to invest some time to understand how it works under the
hood. This will allow me more flexibility in the future. Moreover, it
will allow me to streamline my workflow in emacs once I have a more
profund understanding of it.
</p>

<p>
These notes are based on the book <a href="https://www.amazon.com/Gradle-Action-Benjamin-Muschko/dp/1617291307">gradle in action</a>. Interesting is
that this book works with Groovy, which is apparently a more flexible
Java that introduce some of the concepts of dynamic programming
languages. Look at the <a href="https://www.bbvaapimarket.com/en/api-world/why-groovy-gaining-popularity-among-java-developers/">following entry</a> in this sense. I must say that
I can well understand why Python is gaining so much traction over more
heavy languages as Java. It is not simply a thing about the learning
curve. I think that Java with its structured type-safe and OOP
appraoch is more solid than Python for larger system. I see the point
for using it at work. The only thing is that the developing experience
is slower. As you have to compile the entire code before running it,
you cannot develop on the fly and integrate the changes in the more
structured project as you used to do in interpreted languages.
</p>

<p>
Anyways, back to the book. Note that the book is very exhaustive.
Through it you will manage to get a broad overview on the topic and
you will even get to the point of continous integration and continouos
deployment.
</p>

<!-- TEASER_END -->

<div id="outline-container-org2add19c" class="outline-2">
<h2 id="org2add19c">General Idea</h2>
<div class="outline-text-2" id="text-org2add19c">
<p>
So basically this is nothing else than a tool that is system and OS
independent to create builds of your projects.
</p>

<p>
Basically in Python and these ecosystems you came from, this was
already done out of the box, i.e. you were writing directly
everything (your source files - no bytecode) in the repositories of
your choice. Dependencies were already handled as on your systempath
you had the libraries downloaded thorugh the package manager in the
right repository. Period. Here the story is more annoying and this
is the reason why you use such build-tools. 
</p>

<p>
So a build tool entails the logic of reaching your desired workflow
via a set of well-defined tasks. Think for instance at such a basic
concept:
</p>

<img src="../../images/Screenshot%202021-10-20%20101212.png" class="center"><p>
Straightforward. By <i>assemble a deliverable</i> we mean an entity that
contains the class files. A deliverable could be a ZIP file, for
example, that can be distributed to a runtime environment.
</p>

<p>
Note that internally the build tool models such different
tasks via DAGs. Your old friends of Bayesian Networks and
Spark.
</p>

<p>
Note that such DAGs are important constructs. This because, if two
different tasks depend on the task “source code compilation,” you
only want to execute it once. Meaning that you must have a
corresponding DAG representation of it in order to work smoothly.
</p>

<p>
Note that different tasks in the process might use input and produce
output. So the typical workflow of a build would look schematically
as follows:
</p>

<img src="../../images/Screenshot%202021-10-20%20102530.png" class="center">
</div>


<div id="outline-container-org5930847" class="outline-3">
<h3 id="org5930847">Build File</h3>
<div class="outline-text-3" id="text-org5930847">
<p>
So basically once you have in mind your desired build workflow, you
can specify it into a build-file. 
</p>
</div>
</div>


<div id="outline-container-org24dc7e2" class="outline-3">
<h3 id="org24dc7e2">Build Engine</h3>
<div class="outline-text-3" id="text-org24dc7e2">
<p>
The build-engine is the engine that takes the declarations of the
build-file and builds everything as specified in
there.
</p>

<p>
Note that the build-engine will need to process the relevant
dependencies for your project. I.e. it will have to resolve the
dependencies from multiple packages stored in <code>.jar</code> files, that
might be fetched over the internet or might reside on your local
file system. Recall that <code>.jar</code> files are ultimately (mainly) a
collection of compressed java Bytecode <code>.class</code> files.
</p>

<p>
Graphically, at high level:
</p>

<img src="../../images/Screenshot%202021-10-20%20105123.png" class="center"><p>
Such a very general overview holds generally irrespective of the
build tool you are using.
</p>

<p>
Next we will explore some build-tools in more depth. 
</p>
</div>
</div>
</div>

<div id="outline-container-org8170e19" class="outline-2">
<h2 id="org8170e19">On Ant and Maven</h2>
<div class="outline-text-2" id="text-org8170e19">
<p>
So I keep it short here but you can find in the book in the
introductory chapter some quick introduction to Ant and Maven. It
is well written and in a few pages you will get the overview of
it. 
</p>

<p>
So I was wondering why in Java you always work with very long
chains of empty repositories. The answer lies in such build tools.
</p>

<p>
While the Ant built-tool provides you with the flexibility of your
choice when building your project, maven started to impose some
standards. I.e. if you structure your project in adherence with
these standards, your build-tool will know out of the box where to
find the relevant pieces of your projects.
</p>

<p>
So basically you can then have minimal configuration and
consistency across your enterprise on how such projects are
managed. Note that such standard is to have code in the
<code>src/main/java</code> repo.
</p>

<p>
Moreover maven started to introduce a default build lifecyle that
would consist of the follwoing:
</p>

<ul class="org-ul">
<li>Compiling source code</li>

<li>Running unit and integration tests</li>

<li>Assembling the artifact (for example, a JAR file)</li>

<li>Deploying the artifact to a local repository</li>

<li>Releasing the artifact to a remote repository</li>
</ul>
<p>
so the workflow is now given.
</p>

<p>
Now you can call in maven the execution of a given <code>phase</code>
(i.e. step in the build lifecycle above) and all of the previous
steps will be performed.
</p>

<p>
Now this - obviously biased - book suggests the following
key-element to choose gradle over the other mentioned built-tools:
</p>

<blockquote>
<p>
Either you choose full flexibility and extensibility but get weak
project standardization, tons of boiler-plate code, and no support for
dependency management by picking Ant; or you go with Maven, which
offers a convention over configuration approach and a seamlessly
integrated dependency manager, but an overly restrictive mindset and
cumbersome plugin system.
</p>

<p>
Wouldn’t it be great if a build tool could cover a middle ground? Here are some
features that an evolved build tool should provide:
</p>

<ul class="org-ul">
<li>Expressive, declarative, and maintainable build language.</li>

<li>Standardized project layout and lifecycle, but full flexibility and
the option to fully configure the defaults.</li>

<li>Easy-to-use and flexible ways to implement custom logic.</li>

<li>Support for project structures that consist of more than one project
to build deliverable.</li>

<li>Support for dependency management.</li>

<li>Good integration and migration of existing build infrastructure,
including the ability to import existing Ant build scripts and tools
to translate existing Ant/ Maven logic into its own rule set.</li>

<li>Emphasis on scalable and high-performance builds. This will matter
if you have long-running builds (for example, two hours or longer),
which is the case for some big enterprise projects.</li>
</ul>
</blockquote>

<p>
I will see in time if I agree or not with the above.
</p>
</div>
</div>

<div id="outline-container-org92f1811" class="outline-2">
<h2 id="org92f1811">Gradle Syntax and Specifics</h2>
<div class="outline-text-2" id="text-org92f1811">
<blockquote>
<p>
Following a build-by-convention approach, Gradle allows for
declaratively modeling your problem domain using a powerful and
expressive domain-specific language (DSL) implemented in Groovy
instead of XML.
</p>

<p>
Because <b>Gradle is a JVM native</b>, it allows you to write custom logic
in the language you’re most comfortable with, be it Java or Groovy.
</p>
</blockquote>

<p>
Note that Gradle DSL is mapped to instances via the Gradle API.
</p>

<p>
An example is the following:
</p>

<img src="../../images/Screenshot%202021-10-20%20133902.png" class="center"><p>
You have to recall that via the API, wach element in a Gradle script
has a one-to-one representation with a Java class.
</p>

<p>
Note that the DSL is written in Groovy. Given that this is a flare
of Java, you can even extend the DSL language in plain Java.
</p>
</div>

<div id="outline-container-orgc3572aa" class="outline-3">
<h3 id="orgc3572aa">Gradle Conventions</h3>
<div class="outline-text-3" id="text-orgc3572aa">
<p>
Gradle’s conventions are similar to the ones provided by Maven, but
they don’t leave you feeling boxed in. Maven is very opinionated;
it proposes that a project only contains one Java source directory
and only produces one single JAR file. This is not necessarily
reality for many enterprise projects.
</p>

<p>
Gradle allows you to easily break out of the conventions. On the
opposite side of the spectrum, Ant never gave you a lot of guidance
on how to structure your build script, allowing for a maximum level
of flexibility. Gradle takes the middle ground by offering
conventions combined with the ability to easily change them.
</p>

<p>
Note the following visualization with the things the conventions
alter:
</p>

<img src="../../images/Screenshot%202021-10-20%20135837.png" class="center">
</div>
</div>


<div id="outline-container-orge9474c2" class="outline-3">
<h3 id="orge9474c2">On Scalable Builds - Incremental Builds</h3>
<div class="outline-text-3" id="text-orge9474c2">
<p>
For some companies, a large project with hundreds of modules is
reality. Building and testing minor code changes can consume a lot
of time. You may know from personal experience that deleting old
classes and resources by running a cleanup task is a natural
reflex.
</p>

<p>
All too often, you get burned by your build tool not picking up the
changes and their dependencies. What you need is a tool that’s
smart enough to only rebuild the parts of your software that
actually changed. Gradle supports incremental builds by specifying
task inputs and outputs.
</p>

<p>
Already in my first month I could experience something that goes
into this direction. It is for sure a topic to consider on the long
term.
</p>
</div>
</div>

<div id="outline-container-orgc633ca6" class="outline-3">
<h3 id="orgc633ca6">On Ant and Maven Integration</h3>
<div class="outline-text-3" id="text-orgc633ca6">
<p>
Note that Gradle fully supports Ant integration. For maven you
would still need to check in more detail as it is work in
progress.
</p>

<p>
You will probably not need it in the near future but keep it in
mind should it become necessary.
</p>
</div>
</div>

<div id="outline-container-orgd63ac88" class="outline-3">
<h3 id="orgd63ac88">Continouos Delivery.</h3>
<div class="outline-text-3" id="text-orgd63ac88">
<p>
Read the book that you recently downloaded.
</p>

<p>
In general you should have a pipeline comparable to the following:
</p>

<img src="../../images/Screenshot%202021-10-20%20155352.png" class="center"><p>
We are half way there in our team. Go back to it at some point when
you have time.
</p>
</div>
</div>

<div id="outline-container-org351afe2" class="outline-3">
<h3 id="org351afe2">Syntax</h3>
<div class="outline-text-3" id="text-org351afe2">
<div class="highlight"><pre><span></span>   <span class="c1">// In the build.gradle file</span>
   <span class="n">task</span> <span class="n">helloWorld</span> <span class="p">{</span>
       <span class="n">doLast</span> <span class="p">{</span>
	   <span class="n">println</span> <span class="err">'</span><span class="n">Hello</span> <span class="n">world</span><span class="o">!</span><span class="err">'</span>
	       <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// Other short version to perform the same thing</span>

   <span class="c1">// task helloWorld &lt;&lt; {</span>
   <span class="c1">//  println 'Hello world!'</span>
   <span class="c1">// }</span>
</pre></div>

<p>
The above specify a task. The <code>doLast</code> it is the last action
executed by the task.
</p>

<p>
You can then run the task by running in your shell
</p>

<div class="highlight"><pre><span></span>   gradle  q helloWorld
</pre></div>

<p>
A more involved example of gradle is the following
</p>

<div class="highlight"><pre><span></span>   <span class="n">task</span> <span class="n">startSession</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
    <span class="n">chant</span><span class="p">()</span>
   <span class="p">}</span>


   <span class="c1">// See the integration with Ant you briefly</span>
   <span class="c1">// touched upon higher above.</span>
   <span class="n">def</span> <span class="nf">chant</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ant</span><span class="p">.</span><span class="na">echo</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="err">'</span><span class="n">Repeat</span> <span class="n">after</span> <span class="n">me</span><span class="p">...</span><span class="err">'</span><span class="p">)</span> 
   <span class="p">}</span>

   <span class="c1">// major loop. groovy syntax. $it is replaced by the internals.</span>
   <span class="mf">3.</span><span class="n">times</span> <span class="p">{</span>
    <span class="n">task</span> <span class="s">"yayGradle$it"</span> <span class="o">&lt;&lt;</span> <span class="p">{</span> 
    <span class="n">println</span> <span class="err">'</span><span class="n">Gradle</span> <span class="n">rocks</span><span class="err">'</span>
    <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// dependsOn -&gt; important component. makes sure you run startSession before yayGradle0</span>
   <span class="n">yayGradle0</span><span class="p">.</span><span class="na">dependsOn</span> <span class="n">startSession</span> 
   <span class="n">yayGradle2</span><span class="p">.</span><span class="na">dependsOn</span> <span class="n">yayGradle1</span><span class="p">,</span> <span class="n">yayGradle0</span> 
   <span class="n">task</span> <span class="nf">groupTherapy</span><span class="p">(</span><span class="n">dependsOn</span><span class="p">:</span> <span class="n">yayGradle2</span><span class="p">)</span> 
</pre></div>

<p>
Given the above it is straightforward to see that the following
holds, when running the <code>groupTherapy</code>.
</p>

<div class="highlight"><pre><span></span>   $ gradle groupTherapy
</pre></div>

<pre class="example" id="org9d3e289">
:startSession
[ant:echo] Repeat after me...
:yayGradle0
Gradle rocks
:yayGradle1
Gradle rocks
:yayGradle2
Gradle rocks
:groupTherapy
</pre>

<p>
You can as well specify the tasks that you want to run by running
the following:
</p>

<div class="highlight"><pre><span></span>   <span class="n">$</span> <span class="n">gradle</span> <span class="n">yayGradle0</span> <span class="n">groupTherapy</span>
</pre></div>

<p>
Note that you can as well exclude a specific task from being run
through the <code>-x</code> flag.
</p>

<div class="highlight"><pre><span></span>   <span class="n">$</span> <span class="n">gradle</span> <span class="n">groupTherapy</span> <span class="o">-</span><span class="n">x</span> <span class="n">yayGradle0</span>
</pre></div>

<pre class="example" id="org13c13c2">
:yayGradle1
Gradle rocks
:yayGradle2
Gradle rocks
:groupTherapy
</pre>

<p>
Note that running tasks in such a way is not super informative. You
can include the following two more flags:
</p>

<ul class="org-ul">
<li>
<code>-i</code>: : In the default settings, a Gradle build doesn’t output a
lot of information. Use this option to get more informative
messages by changing Gradle’s logger to INFO log level. This is
helpful if you want to get more information on what’s happening
under the hood.</li>

<li>
<code>-s</code>: If you run into errors in your build, you’ll want to know
where they stem from. The option –s prints out an abbreviated
stack trace if an exception is thrown.</li>
</ul>
</div>
</div>


<div id="outline-container-orgace5a08" class="outline-3">
<h3 id="orgace5a08">Tasks overview (list them)</h3>
<div class="outline-text-3" id="text-orgace5a08">
<p>
Note that you have gradle integrated in your eclipse IDE.
</p>

<p>
I will explore how to run it from the command line such that I will
have the option to use my emacs-lsp integrated development
environment and run all of my build workflow from there by properly
triggering the relevant jobs.
</p>

<div class="highlight"><pre><span></span>   <span class="c1">## checks at all of the tasks specified in the workflow</span>
   gradle -q tasks
</pre></div>

<p>
Your reply will be the following:
</p>

<pre class="example" id="orgceffcef">
------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build Setup tasks 
-----------------
setupBuild - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks 
----------
dependencies - Displays the dependencies of root project 'grouptherapy'.
dependencyInsight - Displays the insight into a specific dependency in root 
➥ project 'grouptherapy'.
help - Displays a help message
projects - Displays the sub-projects of root project 'grouptherapy'.
properties - Displays the properties of root project 'grouptherapy'.
tasks - Displays the tasks runnable from root project 'grouptherapy' (some of
➥ the displayed tasks may belong to subprojects).

Other tasks 
-----------
groupTherapy 
</pre>

<p>
Note that out of the box, each build script exposes the task group
Help tasks without any additional work from the developer.
</p>

<p>
If a task doesn’t belong to a task group, it’s displayed under
<code>Other tasks</code>. This is where you find the task <code>groupTherapy</code>. You
can as well order tasks to groups.
</p>

<p>
The same command with the <code>--all</code> tag will as well provide the
information of the dependency tasks and not simply on the last
one.
</p>

<div class="highlight"><pre><span></span>   <span class="n">gradle</span> <span class="o">-</span><span class="n">q</span> <span class="n">tasks</span> <span class="o">--</span><span class="n">all</span>
</pre></div>
</div>
</div>

<div id="outline-container-org1703a1d" class="outline-3">
<h3 id="org1703a1d">Explore other available parameters</h3>
<div class="outline-text-3" id="text-org1703a1d">
<p>
this can be done through the <code>-h</code> tag as always.
</p>
</div>
</div>


<div id="outline-container-orgde552e0" class="outline-3">
<h3 id="orgde552e0">Java Project - The Java Plug-ins</h3>
<div class="outline-text-3" id="text-orgde552e0">
<p>
A plugin extends your project by introducing domain-specific
conventions and tasks with sensible defaults. One of the plugins
that Gradle ships with is the Java plugin. The <i>Java plugin</i> goes
far beyond the basic functionality of source code compilation and
packaging. It establishes a standard layout for your project and
makes sure that tasks are executed in the correct order so they
make sense in the context of a Java project.
</p>

<p>
In order to leverage such a plug-in and start to interact with
your java project you need to specify the plug-in in your
<code>build.gradle</code> file.
</p>

<pre class="example" id="orgb22d4b5">
apply plugin: 'java'
</pre>

<p>
Note that with such a plug-in the gradle build tool will expect
your source code to be in <code>src/main/java</code>. So this in a similar
way to the structure imposed by maven.
</p>

<p>
Note that such a plug-in will provide you with the <code>build</code> task.
</p>

<p>
Such a task will:
</p>

<ul class="org-ul">
<li>compile your code</li>

<li>run your tests</li>

<li>assembles the <code>jar</code> file</li>
</ul>
<p>
you can see by running such a task. You will get the following flow:
</p>

<img src="../../images/Screenshot%202021-10-21%20090747.png" class="center"><p>
<b>Important:</b> The <code>UP-TO-DATE</code> tag in above, means that Gradle’s
<i>incremental build support</i> automatically identified that no work
needed to be done.
</p>

<p>
Note that unit-tests where skipped. This is because for the given
project example no unit tests was present in the default directory
<code>src/test/java</code> (default test directory of gradle - write your
unit tests there).
</p>

<p>
Note that after running the build command your application is
packaged in the <code>build</code> repository. This will look as follows:
</p>

<pre class="example" id="org0de6228">
.
├── build
│ ├── classes                      ## here you have your application bytecode that can be run on the JVM
│ ├── dependency-cache
│ ├── libs                         ## here you have your compressed jar files
│ │ └── todo-app.jar 
│ ├── reports
│ │ └── tests
│ ├── test-results
│ └── tmp
│    └── jar
│        └── MANIFEST.MF           ## temporary manifest used in the jar file 
└── build.gradle
</pre>

<p>
Note that you can find a similar structure in the projects you are
working on. Not perfectly the same but almost so.
</p>

<p>
Now you can run your enty point java bytecode.
</p>

<p>
You can either run directly the app by specifying the path of your
main <code>.class</code> file or you can include the <code>Main-Class header to
    JAR file’s manifest</code> and run directly the application by running
the <code>.jar</code> file.
</p>

<p>
An example of the way you can do it in <code>Gradle</code> is the following:
</p>

<div class="highlight"><pre><span></span>    <span class="n">version</span> <span class="o">=</span> <span class="mf">0.1</span> 
    <span class="n">sourceCompatibility</span> <span class="o">=</span> <span class="mf">1.6</span> 
    <span class="n">jar</span> <span class="p">{</span>
     <span class="n">manifest</span> <span class="p">{</span> 
     <span class="n">attributes</span> <span class="err">'</span><span class="n">Main</span><span class="o">-</span><span class="n">Class</span><span class="err">'</span><span class="p">:</span> <span class="err">'</span><span class="n">com</span><span class="p">.</span><span class="na">manning</span><span class="p">.</span><span class="na">gia</span><span class="p">.</span><span class="na">todo</span><span class="p">.</span><span class="na">ToDoApp</span><span class="err">'</span>   <span class="c1">// specify main class in header</span>
     <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

<p>
You can then run: <code>java –jar build/libs/myapp-0.1.jar</code>
</p>

<p>
You can then read in the book how you can make similar
modifications in your project, i.e. where the source code is,
where the build goes etc. Google it in case of need.
</p>
</div>


<div id="outline-container-orgbb41389" class="outline-4">
<h4 id="orgbb41389">Specify Source Repository from where you fetch your libraries</h4>
<div class="outline-text-4" id="text-orgbb41389">
<p>
This you can do with the following entry in your <code>build.gradle</code> file.
</p>

<div class="highlight"><pre><span></span>    <span class="n">repositories</span> <span class="p">{</span>
     <span class="n">mavenCentral</span><span class="p">()</span> 
    <span class="p">}</span>
</pre></div>

<p>
You can then specify the dependencies to specific libraries in
there in the following way:
</p>

<div class="highlight"><pre><span></span>    <span class="n">dependencies</span> <span class="p">{</span>
     <span class="n">compile</span> <span class="n">group</span><span class="p">:</span> <span class="err">'</span><span class="n">org</span><span class="p">.</span><span class="na">apache</span><span class="p">.</span><span class="na">commons</span><span class="err">'</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="err">'</span><span class="n">commons</span><span class="o">-</span><span class="n">lang3</span><span class="err">'</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="err">'</span><span class="mf">3.1</span><span class="err">'</span>
    <span class="p">}</span>
</pre></div>

<p>
<b>Important note:</b> you have to specify to which configuration group
your dependencies belong to. Note that one default group is the
<code>compile</code> group. This group consists of all of the dependencies
that are needed at compile time. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe33eb5" class="outline-3">
<h3 id="orgbe33eb5">War Plug-in</h3>
<div class="outline-text-3" id="text-orgbe33eb5">
<p>
This is the plug-in for running your java web-applications.
</p>

<p>
I already mentioned that the War plugin extends the Java plugin. In
practice, this means that you don’t have to apply the Java plugin
anymore in your build script.
</p>

<p>
You can specify it like this:
</p>

<pre class="example" id="org558e224">
apply plugin: 'war'
</pre>

<p>
So once you have it in your build config, gradle can package your
application as a war file that you can then run on your
web-application servers.
</p>

<p>
Note that by applying the plug-in you will have at your
availability new dependency configuration groups.
</p>

<ul class="org-ul">
<li>
<p>
<code>providedCompile</code>: here you specify the dependency you use for
the Servlet. It’s used for dependencies that are required for
compilation but <b>not used by the runtime</b>.
</p>

<p>
This means that packages specified in here will only be available
at compile time but will not be available at runtime. It
means, those JAR will not be included in archive.
</p>
</li>

<li>
<p>
<code>runtime</code>: this is the tag to reach exactly the opposite logic of
the above. Runtime dependencies like the JSTL library aren’t
needed for the compilation process, but are needed at
runtime. They’ll become part of the WAR file.
</p>

<p>
When you run <code>gradle build</code> you will have a packaged <code>.war</code>
file. You can then run your webapplication with it.
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgdadaf6d" class="outline-3">
<h3 id="orgdadaf6d">Running in an Embedded web-container</h3>
<div class="outline-text-3" id="text-orgdadaf6d">
<p>
So basically the book is written with the example of the <code>Jetty</code>
webserver. I can imagine that the same holds for similar concepts
for <code>tomcat</code>.
</p>

<p>
Basically the idea is that you apply the plug-in:
</p>

<div class="highlight"><pre><span></span>  apply plugin: 'jetty'
</pre></div>

<p>
Then you can run the web-app server via:
</p>

<pre class="example" id="orgf9ddbde">
gradle jettyRun
</pre>

<p>
Internally, the Jetty plugin does know all of the relevant
dependencies and is able to find and execute the <code>war</code>. As the War
plugin exposes all this information, it can be accessed at runtime
by the Jetty plugin.
</p>

<p>
You can finally set some tasks and change the relevant deployment
statndards by specifying the following:
</p>

<div class="highlight"><pre><span></span>  <span class="n">jettyRun</span> <span class="p">{</span> 
   <span class="n">httpPort</span> <span class="o">=</span> <span class="mi">9090</span>
   <span class="n">contextPath</span> <span class="o">=</span> <span class="err">'</span><span class="n">todo</span><span class="err">'</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org7aa7710" class="outline-3">
<h3 id="org7aa7710">Gradle Wrapper</h3>
<div class="outline-text-3" id="text-org7aa7710">
<p>
This is useful as it guarantees that you run your gradle build with
the same version of the gradle software.
</p>

<p>
In such a way you will not suffer from issues arising due to
different software versions.
</p>

<div class="highlight"><pre><span></span>   <span class="n">task</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">type</span><span class="p">:</span> <span class="n">Wrapper</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gradleVersion</span> <span class="o">=</span> <span class="err">'</span><span class="mf">1.7</span><span class="err">'</span>
   <span class="p">}</span>
</pre></div>

<p>
Once you specified this task you can execute it
</p>

<pre class="example" id="org1cc0e85">
$ gradle wrapper
:wrapper
</pre>

<p>
You will then have the following generated files:
</p>

<img src="../../images/Screenshot%202021-10-21%20144131.png" class="center"><p>
You see that among the many files that you obtain by running such a
task you have the <code>gradlew</code> file.
</p>

<p>
You can then basically use that script in order to run the
build with the specified gradle version. 
</p>

<p>
You can visualize the build process as follows:
</p>

<img src="../../images/Screenshot%202021-10-21%20144841.png" class="center"><p>
Finally, note that you can costumize the wrapper to download the
zipped gradle files from a specific location.
</p>
</div>
</div>

<div id="outline-container-org5bbb9c2" class="outline-3">
<h3 id="org5bbb9c2">Testing</h3>
<div class="outline-text-3" id="text-org5bbb9c2">
<p>
Recall the three types of tests:
</p>

<ul class="org-ul">
<li>unit testing: with it you test the smallest components of your
code. Here you avoid testing the interaction with external
systems. (for example DB or file system). In order to not
interact with the other components you use <code>Mocks</code> and <code>Stub</code>.</li>

<li>integration testing: make sure that the interaction across
components works as expected. For instance the interaction among
application and database.</li>

<li>functional testing: test end-to-end functionality of an
application including the interaction with all external systems
from a user's perspective.</li>
</ul>
<p>
Note that Gradle's Java plugin does all of the heavy lifiting for
you. It introduces a standard directory structure for testing your
code, moreover, it introduces test code compilation and execution
<code>into the build's lifecycle</code>.
</p>

<p>
Note that in gradle you have the following standard for structuring
your tests. You put them all in the <code>src/test/java</code>
repository. Moreover, you put the required files by the tests in
the <code>src/test/resources</code> repository.
</p>

<p>
After compiling test source code, the class files end up in the
output directory <code>build/classes/test</code>, nicely separated from the
compiled production class files.
</p>

<p>
Note that the results of running such tests are usually generated
in XML. This is less interesting to you as you will generally use
some tool to operate with them such that you will only marginally
deal with them.
</p>

<p>
Once again in order to set up your build-configuration in a proper
way, you have to understand the two groups available to you in the
java built-in:
</p>

<ul class="org-ul">
<li>
<code>testCompile</code>: here you specify libraries dependencies required
for test code compilation.</li>

<li>
<code>testRuntime</code>: here you specify dependencies needed for test
code execution. I.e. these are dependencies that are not needed
during the compilation phase of your tests, but are needed at
runtime during test execution.</li>
</ul>
<p>
Note the following schema. It is written in a difficult way in the
book. The secret souce is the following and something quite
intuititve. I.e. you might need some compile dependencies from
your production code as you are testing it. So that is it.
</p>

<img src="../../images/Screenshot%202021-10-21%20175028.png" class="center">
</div>

<div id="outline-container-org77eac66" class="outline-4">
<h4 id="org77eac66">Automatic test detection</h4>
<div class="outline-text-4" id="text-org77eac66">
<p>
Note that gradle automatically detects the tests in your projects
that sit in <code>build/classes/test</code> through the following:
</p>

<ul class="org-ul">
<li>Any class or superclass that extends either
<code>junit.framework.TestCase</code> or <code>groovy.util.GroovyTestCase</code>.</li>

<li>Any class or superclass that’s annotated with <code>@RunWith</code>.</li>

<li>Any class or superclass that contains at least one method
annotated with <code>@Test</code>.</li>
</ul>
<p>
Given that you structured your repository in the proper way and
you wrote your tests in there you can run the following in order
to run your tests. 
</p>

<pre class="example" id="org8225f50">
gradle :repository:test
</pre>

<p>
If you want more informative content don't forget the <code>-i</code> flag.
</p>

<p>
You are not an individual that cares a lot about the front-end
experience in your development. You would not work with Emacs
would that be the case.
</p>

<p>
In any case you will find an html report of your tests under
<code>build/reports/test</code> should you ever be interested in it.
The thing would then look as following:
</p>

<img src="../../images/Screenshot%202021-10-22%20093615.png" class="center">
</div>
</div>

<div id="outline-container-orga6c091f" class="outline-4">
<h4 id="orga6c091f">Multiple Testing Frameworks</h4>
<div class="outline-text-4" id="text-orga6c091f">
<p>
For bigger projects it is well possible to start having multiple
testing frameworks at work.
</p>

<p>
You can see the following example, that uses, junit, spock and
testNG for writing your tests.
</p>

<p>
You can introduce the additional requirement by following the
following naming convention  for test classes in your project:
</p>

<pre class="example" id="org5e96b29">
- JUnit: All tests class names end with *Test.java.
- TestNG: All test class names end with *NGTest.java.
- Spock: All test class names end with *Spec.groovy.
</pre>

<p>
Both Junit and Spock tests are run out of the box in the default
<code>test</code> class. On the contrary you have to specify a task for
running <code>testNG</code> tests.
</p>

<p>
You can then achieve the testing using the three of them by using
the following gradle config
</p>

<pre class="example" id="org6daff17">
project(':repository') {

 apply plugin: 'groovy'

 repositories {
  mavenCentral()
 }

 dependencies {
  compile project(':model')
  testCompile 'junit:junit:4.11'
  testCompile 'org.testng:testng:6.8'
  testCompile 'org.codehaus.groovy:groovy:2.0.6'
  testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
 }

 task testNG(type: Test) { 
  useTestNG()
 }

 test.dependsOn testNG 
}
</pre>

<p>
I.e. the logic is simple. You make your test depending on the task
<code>testNG</code> that triggers the tests. Such that once the <code>test</code> task
runs it triggers the testNG as well as the Junit and Spock tests
as default.
</p>

<p>
Visually you would have the follwoing:
</p>

<img src="../../images/Screenshot%202021-10-22%20100802.png" class="center">
</div>
</div>



<div id="outline-container-org2b41f17" class="outline-4">
<h4 id="org2b41f17">On running a subclass of tests</h4>
<div class="outline-text-4" id="text-org2b41f17">
<p>
Note that when your projects grows larger you do not want to
execute then entire tests suites. You might want to run individual
tests or even just a couple of tests by pattern.
</p>

<p>
In order to run tests by pattern you can use the following:
</p>

<pre class="example" id="org6b8392d">
$ gradle -Dtest.single=**/*Spec :repository:test
</pre>

<p>
I.e. note the notation: <code>&lt;taskName&gt;.single =
    &lt;testNamePattern&gt;</code>. Note that other options are as well
available. Check at the documentation for it, should you be
interested.
</p>

<p>
Note that for this reason you should structure your test naming
conventions in the proper way, meaning with the suffix
<code>IntegTest</code>.
</p>

<p>
You can then set up the testing of the different components  in
different tasks. See for instance the following:
</p>

<div class="highlight"><pre><span></span>    project(':repository') {
     repositories {
	mavenCentral()
     }

     dependencies {
	compile project(':model')
	runtime 'com.h2database:h2:1.3.170' 
	testCompile 'junit:junit:4.11'
     }

     test {
	exclude '**/*IntegTest.class' 
	reports.html.destination = file ("$reports.html.destination/unit") 
	reports.junitXml.destination = file("$reports.junitXml.destination/unit") 
     }

     task integrationTest(type: Test) {
	include '**/*IntegTest.class'

     reports.html.destination = file("$reports.html.destination/integration") 
     reports.junitXml.destination = file("$reports.junitXml.destination/integration") 
     }

     check.dependsOn integrationTest 
    }
</pre></div>

<p>
You see that in the last command you specify the integration tests
as dependency to check task.
</p>

<hr>
<p>
<b>More elegant solution to the above:</b> you see books are good but
sometimes to didactic. I wonder why they do not just skip some
stuff and go straight to the correct way of doing things.
</p>

<p>
The idea is that, although the above schema is functional it is
not the best thing in town. This due to the follwoing reason: you
have to instruct all of the devs in your team to use the same
naming convention, which is unconvenient.
</p>

<p>
A better approach is the one of creating a separate repository
where you can write your integration tests. Say for instance
<code>src/integTest/java</code>. You can then keep your unit tests in the
<code>src/test/java</code> directory and differentiate among the two in such
a way.
</p>

<p>
In order to do that you can use the following:
</p>

<div class="highlight"><pre><span></span>    sourceSets {
     integrationTest {
     java.srcDir file('src/integTest/java') 
     resources.srcDir file('src/integTest/resources') 
     compileClasspath = sourceSets.main.output + configurations.testRuntime 
     runtimeClasspath = output + compileClasspath 
     }
    }
</pre></div>

<p>
Here, quote on quote on the book:
</p>

<blockquote>
<p>
you have to assign the compilation classpath, which consists of the
production code classes and all dependencies assigned to the
configuration testRuntime. You’ll also need to define the runtime
classpath consisting of the compiled integration test classes directly
accessible through the variable output and the compilation classpath.
</p>
</blockquote>

<p>
Note that after setting that source, your default deviates from
the gradle default. In this sense you need to configure your <code>Test</code>
to be able to read from the new repository.
</p>

<p>
You can do that in the following way:
</p>

<pre class="example" id="org4fc6898">
task integrationTest(type: Test) {
 testClassesDir = sourceSets.integrationTest.output.classesDir 
 classpath = sourceSets.integrationTest.runtimeClasspath 
}
</pre>

<p>
You can then run everything with the
</p>

<p>
<code>gradle :repository:build</code>
</p>

<p>
command.
</p>

<p>
Note that a similar approach holds for the <i>functional tests</i>.
</p>

<p>
Finally note that there are ways to start your dependencies with
gradle. I.e. for instance the databse for the integration server
and the web-app server for the functional tests. Check at it in
more depth in the book if interested.
</p>

<p>
For illustrative purposes:
</p>

<img src="../../images/Screenshot%202021-10-22%20140729.png" class="center">
</div>
</div>


<div id="outline-container-org736258c" class="outline-4">
<h4 id="org736258c">On remote debugging</h4>
<div class="outline-text-4" id="text-org736258c">
<p>
<b>Important:</b> this is probably very important to you. As this is
the way emacs operates most of the time. I can well imagine that
lots of integration have been constructed on the top of it.
</p>

<p>
Being able to remotely debug your tests with an IDE is an
invaluable tool to have in your toolbox. Gradle provides a
convenient shortcut for enabling remote debugging:
<code>&lt;taskName&gt;.debug</code>, which means you can use it for other tasks as
well. Using this startup parameter will start a server socket on
port 5005 and block task execution until you actually connect to
it with your IDE.
</p>

<p>
I.e. you can for instance run
</p>

<pre class="example" id="orgfe3951e">
$ gradle -Dtest.debug :repository:test
</pre>
</div>
</div>


<div id="outline-container-orgfb28dfc" class="outline-4">
<h4 id="orgfb28dfc">Understanding the Test API representation</h4>
<div class="outline-text-4" id="text-orgfb28dfc">
<p>
This is important. As in such a way you can leave the command line
and start working in a proper way via the API.
</p>

<p>
Note that you have tons of options to customize the way gradle
runs your tests. You can refer to the book for a genral
overiview. Otherwise just refer to the Javadocs of the project.
</p>

<p>
Note that sometimes you might want to write to standard output in
order to monitor your code. One of Gradle’s Test configuration
options is to flip a Boolean flag that prints <i>standard output and
error</i> messages to the terminal.
</p>

<p>
You can specify it in the following way:
</p>

<pre class="example" id="org6e88cba">
test {
 testLogging {
 showStandardStreams = true 
 }
}
</pre>

<p>
You can as well to the terminal events triggers for tests such as
<code>started</code>, <code>passed</code>, <code>skipped</code>, <code>failed</code> etc..
</p>

<p>
You can as well fine tune the way you run your tests by specifying
some piece of code in gradle that has to be run:
</p>

<ul class="org-ul">
<li>beforeSuite: before a test suite is executed</li>

<li>afterSuite: after a test suite is executed</li>

<li>beforeTest: before a test class is executed</li>

<li>afterTest: after a test class is executed</li>
</ul>
<p>
You will then have the following schema:
</p>

<img src="../../images/Screenshot%202021-10-22%20113024.png" class="center"><p>
You can then check in the book for examples of gradle scripts that
use such hooks. For instance there is an example in groovy to
calculate the elapsed execution time for tests and send this
information as a notification to the desktop. Quite useless as
many of these features are implemented in your IDE but you get the
gist of the idea should you ever want to do something with it.
</p>
</div>
</div>

<div id="outline-container-org1f2a3d3" class="outline-4">
<h4 id="org1f2a3d3">Parallel Execution</h4>
<div class="outline-text-4" id="text-org1f2a3d3">
<p>
This is as well an extension to the gradle test API. I write the
notes for it in this separate section as it is one of particular
importance.
</p>

<p>
Basically the idea is that when your projects start to grow larger
it will take too much time for you to run all of the tests for
them.
</p>

<p>
The API provides a convenient way to execute your tests in
parallel. All you need to specify is the number of forked JVM
processes. In addition, you can set the number of maximum test
classes to execute per forked test process.
</p>

<p>
The syntax is quite simple and intuitive:
</p>

<pre class="example" id="orgb76a0ed">
test {
 forkEvery = 5 
 maxParallelForks = Runtime.runtime.availableProcessors() / 2 
}
</pre>

<p>
You can immediately make sense of the above via the following
overview:
</p>

<img src="../../images/Screenshot%202021-10-22%20111939.png" class="center">
</div>
</div>
</div>

<div id="outline-container-org8d45410" class="outline-3">
<h3 id="org8d45410">Better understand your work environment gradle build</h3>
<div class="outline-text-3" id="text-org8d45410">
<p>
That will not be easy. It is a very long build config with multiple
files calling each other.
</p>

<p>
So not that trivial and it will take some time to tackle it
down. Good to have that understanding at some point.
</p>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../git-flow/" rel="prev" title="Git-Flow">Previous post</a>
            </li>
            <li class="next">
                <a href="../on-the-full-cycle-development-model/" rel="next" title="On the Full-Cycle Development Model">Next post</a>
            </li>
        </ul></nav></aside></article><footer id="footer"><p>Contents © 2021         <a href="mailto:marco.hassan30@gmail.com">Marco Hassan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </section><script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
