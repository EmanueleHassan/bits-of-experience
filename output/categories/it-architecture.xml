<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bits of Experience (Posts about IT Architecture)</title><link>https://marcohassan.github.io/bits-of-experience/</link><description></description><atom:link href="https://marcohassan.github.io/bits-of-experience/categories/it-architecture.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:marco.hassan30@gmail.com"&gt;Marco Hassan&lt;/a&gt; </copyright><lastBuildDate>Wed, 05 Feb 2020 13:25:52 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Openshift and Kubernetes Commands</title><link>https://marcohassan.github.io/bits-of-experience/posts/openshift-and-kubernetes-commands/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
This post outlines some of the commands to operate on your Kubernetes
and Openshift cluster via CLI.
&lt;/p&gt;

&lt;br&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/openshift-and-kubernetes-commands/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/openshift-and-kubernetes-commands/</guid><pubDate>Wed, 05 Feb 2020 12:26:21 GMT</pubDate></item><item><title>Helm</title><link>https://marcohassan.github.io/bits-of-experience/posts/helm/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;


&lt;p&gt;
This post contains the basic logic of Helm and should act as a
repository listing the most important ways to work with Helm.
&lt;/p&gt;

&lt;br&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/helm/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/helm/</guid><pubDate>Wed, 05 Feb 2020 12:13:30 GMT</pubDate></item><item><title>Cloud Storage</title><link>https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
In the cloud environment, when deploying an application through a
kubernetes cluster a question that naturally arise is how to save
data and general information. 
&lt;/p&gt;

&lt;p&gt;
What you actually want to achieve is to mount a file system on your
containers and read it as it was local.
&lt;/p&gt;

&lt;p&gt;
This posts tries to make the point for the general approached used to
tackle the issue.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><category>Storage</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Cloud%20Storage/</guid><pubDate>Wed, 18 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Kubernetes</title><link>https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
A strong orchestrator tool that operates above the container level and
allows to manage a cluster to handle containers.
&lt;/p&gt;

&lt;p&gt;
It is essentially the tool set that lets you manage containers.
&lt;/p&gt;

&lt;p&gt;
Enterprises can use it to manage the life cycle of containerized apps
in a cluster of nodes, which is a collection of worker machines such
as virtual machines (VMs) or physical machines.
&lt;/p&gt;

&lt;p&gt;
In general kubernetes try to leverage clusters in order to avoid
having a single point of failure.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Kubernetes/</guid><pubDate>Fri, 06 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Microservices</title><link>https://marcohassan.github.io/bits-of-experience/posts/Microservices/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
Microservices refer to an application architectural style that divides
an application into components, where each component is a full, but
miniature, application that is focused on producing a single business
task.
&lt;/p&gt;

&lt;p&gt;
Each microservice has a well-defined interface and dependencies (to
other microservices and to external resources) so that it can run
fairly independently, and the team can develop it fairly
independently.
&lt;/p&gt;

&lt;p&gt;
Microservices enable developers to accomplish meaningful work working
in small teams. Small teams allow developers to be more productive
because they spend less time in meetings and decrease the need for
communication and coordination that is needed with a large team.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Microservices/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Microservices/</guid><pubDate>Fri, 06 Sep 2019 16:21:43 GMT</pubDate></item><item><title>Docker</title><link>https://marcohassan.github.io/bits-of-experience/posts/Docker/</link><dc:creator>Marco Hassan</dc:creator><description>&lt;div&gt;&lt;br&gt;
&lt;br&gt;

&lt;p&gt;
&lt;i&gt;Disclaimer; very much of the material under this page is directly copied from various sources on the internet. Check at the Literature section below to get to the source of the post.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
The basic idea of Docker is to allow the possibility to save all of
the configuration of an application in one single image. This should
be considered as a safe environment that once properly set up can be
easily shared among different teams and once images are instantiated
all of the different teams can be sure to operate and leverage the
right configuration for running their application.
&lt;/p&gt;

&lt;p&gt;
A simple and straight forward overview about the advantage of Docker
might be found in this sense at &lt;a href="https://www.tutorialspoint.com/docker/docker_architecture.htm"&gt;docker architecture&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
To sum up before starting the basic idea is to create images and to
create containers based on that, which will run then the application
as defined in the docker image.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://marcohassan.github.io/bits-of-experience/posts/Docker/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Container Management</category><category>IT Architecture</category><guid>https://marcohassan.github.io/bits-of-experience/posts/Docker/</guid><pubDate>Mon, 02 Sep 2019 16:21:43 GMT</pubDate></item></channel></rss>